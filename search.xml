<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docsify</title>
    <url>/archives/2eeac462.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录Docsify的基本使用。</p><a id="more"></a><h2 id="官方及文档"><a href="#官方及文档" class="headerlink" title="官方及文档"></a>官方及文档</h2><ul><li>官方地址：<a href="https://docsify.js.org/#/" target="_blank" rel="noopener external nofollow noreferrer">https://docsify.js.org/#/</a></li><li>推荐教程：<a href="https://segmentfault.com/a/1190000017576714" target="_blank" rel="noopener external nofollow noreferrer">https://segmentfault.com/a/1190000017576714</a></li></ul><h2 id="Dosify特性"><a href="#Dosify特性" class="headerlink" title="Dosify特性"></a>Dosify特性</h2><ul><li>无需构建，写完文档直接发布</li><li>容易使用并且轻量（~19kb gzipped）</li><li>智能的全文搜索</li><li>提供多套主题</li><li>丰富的 API</li><li>支持 Emoji</li><li>兼容 IE10+</li><li>支持 PWA</li><li>支持 SSR</li></ul><h2 id="Docsify-本地运行"><a href="#Docsify-本地运行" class="headerlink" title="Docsify 本地运行"></a>Docsify 本地运行</h2><p>使用 <code>docsify-cli</code> 来进行本地开发。具体步骤如下：</p><ol><li><code>npm i docsify-cli -g</code> , 全局安装 doscify 脚手架工具</li><li><code>mkdir weblog</code> , 寻找本地磁盘，新建项目目录</li><li><code>cd weblog</code> , 进入项目目录文件中</li><li><code>docsify init ./docs</code> , 初始化一个项目，会生成一些文件</li><li><code>docsify serve ./</code> ， 本地启动服务，即可及时刷新预览</li></ol><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><ol><li>编辑 <code>index.html</code> 中 <code>window.$docsify</code> 的 <code>coverpage</code> 参数，和创建 <code>_coverpage.md</code> 文件即可展示封面。</li><li>替换 <code>index.html</code> 中 的 <code>css</code> 样式，即可改变主题。</li><li>编辑 <code>index.html</code> 中 <code>window.$docsify</code> 的 <code>loadSidebar</code> 参数，和创建 <code>_sizebar.md</code> 文件即可自定义菜单栏。</li><li>github设置中，开启 <code>GitHub Pages</code> 功能并选择 <code>master branch / docs folder</code> 选项。</li></ol><h2 id="特殊的渲染语法"><a href="#特殊的渲染语法" class="headerlink" title="特殊的渲染语法"></a>特殊的渲染语法</h2><ol><li><p><code>!&gt; Time is money!</code>: 重要内容</p></li><li><p><code>?&gt; You are my friend</code>: 普通提示</p></li><li><p><code>[link](/demo &#39;:target=_blank&#39;)</code>: 设置超链接的打开方式（<code>_black/_self</code>）</p></li><li><p><code>[link](/demo &#39;:disaled&#39;)</code>: 超链接禁止点击</p></li><li><p><code>![image](url &#39;:size=50%&#39;)</code>: 图片显示大小（<code>&#39;:size=50x100&#39;/&#39;:size=100&#39;/&#39;:size=20%&#39;</code>）</p></li><li><p>隐藏/展开详情</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">summary</span>&gt;</span></span>展示文章<span class="xml"><span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span></span><br><span class="line">这是隐藏的内容    </span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>文档</category>
        <category>Docsify</category>
      </categories>
      <tags>
        <tag>Docsify</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo特色语法</title>
    <url>/archives/5d6bbf47.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>这是一篇关于hexo一些进阶写法的样式文章。</p><a id="more"></a><h3 id="文本居中引用"><a href="#文本居中引用" class="headerlink" title="文本居中引用"></a>文本居中引用</h3><blockquote class="blockquote-center"><p>预测未来的最好方式是创造未来</p></blockquote><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="普通-markdown-写法"><a href="#普通-markdown-写法" class="headerlink" title="普通 markdown 写法"></a>普通 markdown 写法</h4><blockquote><p>I’am Devin.</p><p>I like coding.</p></blockquote><h4 id="hexo-写法"><a href="#hexo-写法" class="headerlink" title="hexo 写法"></a>hexo 写法</h4><blockquote><p>I’am Devin. I like coding.</p></blockquote><h4 id="hexo-作者引用"><a href="#hexo-作者引用" class="headerlink" title="hexo 作者引用"></a>hexo 作者引用</h4><blockquote><p>I’am Devin. I like coding.</p><footer><strong>—Devin</strong></footer></blockquote><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><div class="note default"><p>default 提示块标签</p></div><div class="note primary"><p>primary 提示块标签</p></div><div class="note success"><p>success 提示块标签</p></div><div class="note info"><p>info 提示块标签</p></div><div class="note warning"><p>warning 提示块标签</p></div><div class="note danger"><p>danger 提示块标签</p></div><h4 id="不携带icon"><a href="#不携带icon" class="headerlink" title="不携带icon"></a>不携带icon</h4><div class="note warning no-icon"><p>warning 提示块标签</p></div><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><span class="label default">默认</span> <span class="label primary">主要</span> <span class="label success">成功</span> <span class="label info">信息</span> <span class="label warning">警告</span> <span class="label danger">危险</span> <span class="label success">这是成功的信息</span><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><a class="btn" href="https://20202030.cc/"><i class="fa fa-link fa-fw"></i>链接 </a><a class="btn" href="https://20202030.cc/" title="这是子俊的私人领域"><i class="fa fa-home fa-fw"></i>首页 </a><a class="btn" href="https://20202030.cc/" title="豆瓣电影"><i class="fa fa-film fa-fw"></i>观影 </a><a class="btn" href="https://20202030.cc/" title="豆瓣读书"><i class="fa fa-book fa-fw"></i>阅读</a><h3 id="选项卡"><a href="#选项卡" class="headerlink" title="选项卡"></a>选项卡</h3><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">A</a></li><li class="tab"><a href="#tab-2">B</a></li><li class="tab"><a href="#tab-3">C</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><p><strong>选项卡 A</strong></p></div><div class="tab-pane" id="tab-2"><p><strong>选项卡 B</strong></p></div><div class="tab-pane" id="tab-3"><p><strong>选项卡 C</strong> 名字为C</p></div></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>文档</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo踩坑</title>
    <url>/archives/7c55949b.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>主要记录hexo使用过程中的一些Bug，Hexo的踩坑之路。</p><a id="more"></a><h3 id="本地预览ok，部署有问题"><a href="#本地预览ok，部署有问题" class="headerlink" title="本地预览ok，部署有问题"></a>本地预览ok，部署有问题</h3><ul><li><p>Bug描述：</p><p>部署生产，标签文章打开出现 404，但是，本地预览 无此问题。</p></li></ul><ul><li><p>Bug解决：</p><p>出现的问题的原因是：git中设置了大小写不敏感。所以，可以修改 git 设置不忽略大小写。进入项目文件夹，进入 <code>git</code> 目录：<code>.deploy_git</code> , 修改 <code>.git</code> 文件中的配置文件 <code>config</code> , 修改 <code>ignorecase</code> 属性：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignorecase = <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="404页面错误"><a href="#404页面错误" class="headerlink" title="404页面错误"></a>404页面错误</h3><ul><li><p>Bug描述：</p><p>生产环境，404显示不正确，渲染成了post页面，而不是需要的页面。</p></li><li><p>Bug解决：</p><p>在 <code>source</code> 目录下新建 <code>404.html</code> 文件，写入以下代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>404<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">homePageUrl</span>=<span class="string">"/"</span> <span class="attr">homePageName</span>=<span class="string">"返回"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在主题配置文件中修改 <code>menu</code> 属性：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">commonweal:</span> <span class="string">/404</span> <span class="string">||</span> <span class="string">heartbeat</span></span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>文档</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Github使用Netlify加速</title>
    <url>/archives/ec0de0bc.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录github访问加速和账户验证。</p><a id="more"></a><h2 id="github访问加速"><a href="#github访问加速" class="headerlink" title="github访问加速"></a>github访问加速</h2><ol><li>打开 <a href="https://zijunwork.github.io/weblog/#/" target="_blank" rel="noopener external nofollow noreferrer">Netlify</a> 官网 -&gt; [注册] -&gt; 关联 GitHub 登录 -&gt; [New site from Git] -&gt; 选择GitHub</li><li>进入Github的认证授权页面，点击 <code>Authorize Netlify by Netlify</code></li><li>点击 <code>All repositories</code> 直接选择授权所有仓库，这个授权在设置中可以改</li><li>选择一个项目 如果是 docsify 项目，选择 <code>Base directory</code> 为 <code>/docs</code> 点击 [Deploy site] 发布即可</li><li>部署完成后，Netlify会自动生成一个随机的二级域名 <code>xxx.netlify.com</code>，点击[Site Settings]可以修改为自定义的二级域名</li><li>Site details下点击[Change site name]，可以为这个站点设置一个自定义的名字</li></ol><h2 id="账户验证"><a href="#账户验证" class="headerlink" title="账户验证"></a>账户验证</h2><ol><li><p>Basic 验证</p><p>填写对应的用户名和密码即可验证。</p></li><li><p>OAuth 验证，e.g. SourceTee验证用户方式之一</p><p>[github] -&gt; [Settings] -&gt; [Developer settings] -&gt; [OAuth Apps] 应用的名称随便填，主页 URL 填写<code>http://localhost:8080</code>，跳转网址填写 <code>http://localhost:8080/oauth/redirect</code>。</p></li><li><p>Token 验证，e.g. Webstorm 登录github方式之一</p><p>[github] -&gt; [Settings] -&gt; [Developer settings] -&gt; [Personal access tokens] 生成新的token，用token登录即可。</p></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Git</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git生成SSH</title>
    <url>/archives/64992bff.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录Git的安装，常用命令，生成SSH密钥等。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载地址：<a href="http://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener external nofollow noreferrer">git-for-windows镜像</a></p><h2 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h2><p>查看用户名：<code>git config user.name</code></p><p>查看用户邮箱：<code>git config user.email</code></p><h2 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h2><p>修改用户名：<code>git config --global user.name “Zi Jun”</code></p><p>修改邮箱：<code>git config --global user.email “zijun2030@163.com”</code></p><h2 id="检查是否已经存在SSH密钥"><a href="#检查是否已经存在SSH密钥" class="headerlink" title="检查是否已经存在SSH密钥"></a>检查是否已经存在SSH密钥</h2><p><code>cd ~/.ssh</code> 如果能进入说明已经存在</p><h2 id="生成SSH密钥"><a href="#生成SSH密钥" class="headerlink" title="生成SSH密钥"></a>生成SSH密钥</h2><p><code>ssh-keygen -t rsa -C “zijun2030@163.com”</code> 按3个回车键，密码为空</p><p>文件存放位置 <code>~/.ssh</code>,如果是window的话，Administrator用户，位置：<code>C:\User\Administrator.ssh</code> 下面，如果是其他用户，需要换成对应的用户</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Git</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Sourcetree使用</title>
    <url>/archives/f0db4be8.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录Sourcetree的基本使用及常见踩坑问题。</p><a id="more"></a><h2 id="安装跳过注册安装"><a href="#安装跳过注册安装" class="headerlink" title="安装跳过注册安装"></a>安装跳过注册安装</h2><ol><li><p>安装SrouceTree，下载地址: <a href="https://www.sourcetreeapp.com/，执行到选择bitbucket的界面退出" target="_blank" rel="noopener external nofollow noreferrer">https://www.sourcetreeapp.com/，执行到选择bitbucket的界面退出</a></p></li><li><p>到 <code>C:\Users\{用户名}\AppData\Local\Atlassian\SourceTree\</code> 这个路径下创建 <code>accounts.json</code>,并写入以下代码</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"$id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"$type"</span>: <span class="string">"SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity"</span>,</span><br><span class="line">    <span class="attr">"Authenticate"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"HostInstance"</span>: &#123;</span><br><span class="line">      <span class="attr">"$id"</span>: <span class="string">"2"</span>,</span><br><span class="line">      <span class="attr">"$type"</span>: <span class="string">"SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount"</span>,</span><br><span class="line">      <span class="attr">"Host"</span>: &#123;</span><br><span class="line">        <span class="attr">"$id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"$type"</span>: <span class="string">"SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount"</span>,</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"atlassian account"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"BaseUrl"</span>: <span class="string">"https://id.atlassian.com/"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Credentials"</span>: &#123;</span><br><span class="line">      <span class="attr">"$id"</span>: <span class="string">"4"</span>,</span><br><span class="line">      <span class="attr">"$type"</span>: <span class="string">"SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account"</span>,</span><br><span class="line">      <span class="attr">"Username"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"Email"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"IsDefault"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">]Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li><li><p>打开 <code>SourceTree.exe_Url_iayhtc13zv3obzuz5vchezjs1az2q5ef</code> (该目录与版本有关，可能不一致)，进入 <code>user.config</code> 文件，增加以下代码</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;setting name="AgreedToEULA" serializeAs="String"&gt;</span><br><span class="line">    &lt;value&gt;True&lt;/value&gt;</span><br><span class="line">&lt;/setting&gt;</span><br><span class="line">&lt;setting name="AgreedToEULAVersion" serializeAs="String"&gt;</span><br><span class="line">    &lt;value&gt;20160201&lt;/value&gt;</span><br><span class="line">&lt;/setting&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li><li><p>重新点击 SourceTree.exe 安装，弹框选择最后一项 [我不想使用Mercuial] 即可</p></li></ol><h2 id="设置-SSH"><a href="#设置-SSH" class="headerlink" title="设置 SSH"></a>设置 SSH</h2><ol><li>[工具] -&gt; [选项] -&gt; [SSH客户端配置]<ol><li>[SSH客户端] 选择 [OpenSSH]</li><li>[SSH密钥] 选择本地的 <code>id_rsa</code> 私钥文件（Git章节有详细教程）</li></ol></li><li>添加公钥到服务器，以GitHub为例：<ol><li>[github] -&gt; [Settings] -&gt; [SSH and GPG keys] -&gt; [New SSH key] 添加 <code>~/.ssh/id_rsa.pub</code> 文件内容到里面</li></ol></li></ol><h2 id="账户验证"><a href="#账户验证" class="headerlink" title="账户验证"></a>账户验证</h2><ol><li><p>Basic 验证</p><p>填写对应的用户名和密码即可验证</p></li><li><p>OAuth 验证</p><p>[github] -&gt; [Settings] -&gt; [Developer settings] -&gt; [OAuth Apps] 应用的名称随便填，主页 URL 填写<code>http://localhost:8080</code>，跳转网址填写 <code>http://localhost:8080/oauth/redirect</code></p></li></ol><h2 id="解决gitflow无法正常使用"><a href="#解决gitflow无法正常使用" class="headerlink" title="解决gitflow无法正常使用"></a>解决gitflow无法正常使用</h2><ol><li><p>点击 设置 -&gt; 编辑配置文件</p></li><li><p>修改配置选项：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[gitflow <span class="string">"prefix"</span>]</span><br><span class="line">    feature = feature/</span><br><span class="line">    bugfix = bugfix/</span><br><span class="line">    release = release/</span><br><span class="line">    hotfix = hotfix/</span><br><span class="line">    support = support/</span><br><span class="line">    versiontag =</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Git</category>
        <category>Sourcetree</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Sourcetree</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题整理(一)</title>
    <url>/archives/d7ca445d.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本次主要记录整理-<code>JavaScript</code>：意外全局变量、数组的length属性、鹰眼测试、自动分号插入、闭包、浮点数计算、变量提升这几个问题。</p><p>原链接名：《JS-7个简单但棘手的JavaScript面试问题》</p><a id="more"></a><h3 id="意外全局变量"><a href="#意外全局变量" class="headerlink" title="意外全局变量"></a>意外全局变量</h3><p><strong>问题</strong></p><p>以下代码段中用于运算 <code>typeof a</code> 和 <code>typeof b</code> 的内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = b = <span class="number">0</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="keyword">typeof</span> a;</span><br><span class="line"><span class="keyword">typeof</span> b;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>undefined number<br>这里需要注意的是: <code>let a = b = 0;</code> 和 <code>let a = 0, b = 0;</code> 的区别。<br><ul><li><code>let a = b = 0;</code> 相当于 <code>b = 0;</code> <code>let a = b;</code>。注意, <code>b = 0</code> 的前面是没有 <code>let</code> 声明的,所以这句代码就相当于 <code>window.b = 0;</code>,所以, <code>b</code> 就是一个全局变量。以上代码在浏览器中执行的详情如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="built_in">window</span>.b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">window</span>.b;</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>let a = 0, b = 0;</code> 相当于 <code>let a = 0; let b = 0;</code>。</li></ul></details><h3 id="数组的length属性"><a href="#数组的length属性" class="headerlink" title="数组的length属性"></a>数组的length属性</h3><p><strong>问题</strong></p><p>以下代码中<code>clothes[0]</code> 的值是什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clothes = [<span class="string">'jacket'</span>, <span class="string">'t-shirt'</span>];</span><br><span class="line">clothes.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(clothes[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><details><summary>答案</summary>undefined<br>数组对象的 `length` 属性具有特殊的行为：减少length属性的值就是删除自己的数组元素。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">clothes.length = <span class="number">0</span>; <span class="comment">// &lt;=&gt; clothes = [];</span></span><br></pre></td></tr></table></figure></details><h3 id="鹰眼测试"><a href="#鹰眼测试" class="headerlink" title="鹰眼测试"></a>鹰眼测试</h3><p><strong>问题</strong></p><p><code>numbers</code> 数组的内容是什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> length = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> numbers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++); &#123;</span><br><span class="line">    numbers.push(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(numbers);</span><br></pre></td></tr></table></figure><details><summary>答案</summary>5<br>注意分号的位置！以上代码等效于：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> length = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> numbers = [];</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  <span class="comment">// do nothing                    </span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  numbers.push(i + <span class="number">1</span>);                      </span><br><span class="line">&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(numbers);</span><br></pre></td></tr></table></figure></details><h3 id="自动分号插入"><a href="#自动分号插入" class="headerlink" title="自动分号插入"></a>自动分号插入</h3><p><strong>问题</strong></p><p><code>arrayfromValue()</code> 返回什么值？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayFromValue</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  [item];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arrayFromValue[<span class="number">10</span>]);</span><br></pre></td></tr></table></figure><details><summary>答案</summary>undefined<br>注意 <code>return</code> 和 <code>[item]</code> 表达式之间的换行符。此换行符会使JavaScript自动在 <code>return</code> 和 <code>[item]</code> 表达式之间插入分号。以下是等效代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayFromValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  [item];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="经典为题：棘手的闭包"><a href="#经典为题：棘手的闭包" class="headerlink" title="经典为题：棘手的闭包"></a>经典为题：棘手的闭包</h3><p><strong>问题</strong></p><p>以下代码将输出什么到控制台？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">  setTimeout(log, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>3 3 3<br><code>log()</code>是一个捕获变量 <code>i</code>的闭包，此变量在 <code>for()</code> 循环的外部范围中定义。执行此代码有两个阶段。<br>Phase 1:<br>1. <code>for()</code> 重复3次，在每次迭代过程中，都会创建一个新的函数 <code>log()</code> 来捕获变量 <code>i</code>。然后， <code>setTimeout()</code> 计划执行 <code>log()</code>。<br>2. 当 <code>for()</code> 循环完成时，<code>i</code> 变量的值为3。<br>Phase 2:<br>1. 第二阶段发生在100ms之后， <code>setTimeout()</code> 调用了3次计划的 <code>log()</code>。<code>log()</code> 读取变量 <code>i</code>的当前值为3，并记录到控制台。</details><h3 id="浮点数计算"><a href="#浮点数计算" class="headerlink" title="浮点数计算"></a>浮点数计算</h3><p><strong>问题</strong></p><p>这个等式的结果是什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>);</span><br></pre></td></tr></table></figure><details><summary>答案</summary>false<br>由于以二进制方式对浮点数进行编码，因此像浮点数相加之类的操作会产生舍入误差。简而言之，直接比较浮点数并不精确。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span>; <span class="comment">// -&gt; 0.30000000000000004</span></span><br></pre></td></tr></table></figure></details><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><strong>问题</strong></p><p>如果在声明前访问 <code>myVar</code> 和 <code>myConst</code>，会发生什么情况？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(myVar);</span><br><span class="line"><span class="built_in">console</span>.log(myConst);</span><br><span class="line"><span class="keyword">var</span> myVar = <span class="string">"value"</span>;</span><br><span class="line"><span class="keyword">const</span> myConst = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>undefined error<br><code>var</code>具有变量提升的属性，所以，在<code>var</code> 声明变量，变量开始初始化为 <code>undefined</code>。</details><!-- rebuild by neat -->]]></content>
      <categories>
        <category>面试</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题整理(二)</title>
    <url>/archives/3f44ae09.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录一些进阶型的面试问题：防抖/节流、get/post、模块化、npm安装机制、ES6继承等问题。</p><p>原链接名：《30道经典面试题》</p><a id="more"></a><h3 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？"></a>什么是防抖和节流？有什么区别？如何实现？</h3><p><strong>防抖：</strong>高频事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。主要是限制高频事件被触发的频率。</p><p><strong>节流：</strong>在指定时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。</p><p><strong>区别：</strong></p><ul><li>函数防抖和函数节流都是防止某一时间内频繁触发函数，但是实现原理不一样</li><li>函数防抖是某一段时间内只执行一次（触发频率影响最终时间）；而函数节流是间隔时间执行（触发频率不影响最终时间）</li></ul><p><strong>运用场景：</strong></p><ul><li><p>防抖(<code>debounce</code>)</p><ul><li>Search搜索联想，用户在不断输入值时，用防抖来节约请求资源</li><li>Window触发Resize的时候，不断调整浏览器窗口大小会不断触发这个事件，用防抖让其只触发一次</li></ul></li><li><p>节流(<code>throttle</code>)</p><ul><li>验证码在指定时间内只发送一次</li><li>监听滚动事件，比如是否滑到底部自动加载更多</li></ul></li></ul><p><strong>如何实现：</strong></p><ul><li>防抖：每次触发事件时都取消之前的延时调用方法</li><li>节流：每次触发事件时都判断当前是否有等待执行的延时函数</li></ul><div class="note primary"><p>详细的防抖和节流，可查看 <a href="/archives/a635d2be.html">链接</a></p></div><h3 id="get和post请求的误区"><a href="#get和post请求的误区" class="headerlink" title="get和post请求的误区"></a>get和post请求的误区</h3><p><strong>误区：</strong>get请求参数的大小存在限制，而post请求的参数大小是无限制的。</p><p>实际上HTTP协议从未规定GET/POST的请求长度限制是多少，对get请求参数的限制是来源于浏览器或web服务器，浏览器或web服务器限制了url的长度。</p><ul><li>HTTP协议未规定GET和POST的长度限制</li><li>GET的最大长度显示是因为浏览器和web服务器限制了URI的长度</li><li>不同的浏览器和web服务器，限制的最大长度不一样</li><li>要支持IE,则最大长度为2083byte，若只支持Chrome，则最大长度8182byte</li></ul><p>get和post在缓存方面的区别：</p><ul><li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存</li><li>post不同，post做的一般是修改和删除工作，所以必须与数据库交互，所以不能使用缓存</li></ul><h3 id="模块化发展历程"><a href="#模块化发展历程" class="headerlink" title="模块化发展历程"></a>模块化发展历程</h3><p>可以从IIFE -&gt; CommonJS -&gt; AMD -&gt; CMD -&gt; UMD -&gt; Webpack -&gt; ES Module几个过程考虑。模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p><p><strong>IIFE：</strong>使用自执行函数来编写模块化。</p><ul><li>特点：在一个单独的函数作用域中执行代码，避免变量冲突。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		data: []</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p><strong>CommonJS：</strong>node.js中自带的模块化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br></pre></td></tr></table></figure><p><strong>AMD：</strong>使用requireJS来编写模块化。</p><ul><li>特点：依赖必须提前声明好。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="string">"./index.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>)) </span>&#123;</span><br><span class="line">	<span class="comment">// code 就是 index.js 返回的内容       </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CMD：</strong>使用seaJS来编写模块化。</p><ul><li>特点：支持动态导入依赖文件。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">"./index.js"</span>);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UMD：</strong>兼容AMD，CommonJS模块化语法。</p><p><strong>Webpack：</strong>Webpack版本中的代码分割。</p><p><strong>ES Modules：</strong>ES6引入的模块化，支持import来导入另一个js。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><div class="note primary"><p>更多的模块化详解，可查看 <a href="/archives/b92372a3.html">链接</a></p></div><h3 id="npm模块安装机制"><a href="#npm模块安装机制" class="headerlink" title="npm模块安装机制"></a>npm模块安装机制</h3><ol><li>发出 <code>npm install</code> 命令</li><li>查询 node_modules 目录中是否已经存在指定模块</li><li>如存在，不再重新安装</li><li>如不存在，npm 向 registry 查询模块压缩包的网址</li><li>下载压缩包，存放在根目录的 <code>.npm</code> 目录里</li><li>解压压缩包到当前项目的 node_modules 目录</li></ol><h3 id="ES5与ES6的继承区别"><a href="#ES5与ES6的继承区别" class="headerlink" title="ES5与ES6的继承区别"></a>ES5与ES6的继承区别</h3><ul><li>ES5的继承是通过 <code>prototype</code> 或构造函数机制来实现。ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 <code>this</code> 上（<code>Parent.apply(this)</code>）</li><li>ES6的继承机制完全不同，实质上是先创建父类的实例对象 <code>this</code> (所以必须先调用父类的 <code>super()</code> 方法)，然后再用子类的构造函数修改 <code>this</code></li></ul><p><strong>ES5实现继承 - 原型链实现</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型链继承 子类的原型指向父类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance1); <span class="comment">// =&gt; SubType</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// =&gt; ["red", "blue", "green"]</span></span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// =&gt; ["red", "blue", "green", "black"]</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// =&gt; ["red", "blue", "green", "black"]</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>原型链继承共享属性，属于引用类型，引用副本实例属性的修改必然会引起其他副本实例属性的修改</li><li>不能像父类构造函数随时传递参数，很不灵活</li></ul><p><strong>ES5实现继承 - 构造函数</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 借用构造函数继承 在执行Child构造函数时，将</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance3 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(instance3); <span class="comment">// =&gt; Child: &#123;colors: ["red", "blue", "green"]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance3.colors); <span class="comment">// =&gt; ["red", "blue", "green"]</span></span><br><span class="line">instance3.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance3.colors); <span class="comment">// =&gt; ["red", "blue", "green", "black"]</span></span><br><span class="line"><span class="keyword">let</span> instance4 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(instance4.colors); <span class="comment">// =&gt; ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>单独使用无法达到函数复用，因为每一个函数和属性都需要在构造函数中定义</li><li><code>instance of</code> 操作无法确定子类实例和父类之间的关系，因为子类的 <code>prototype</code> 和父类无关</li></ul><p><strong>ES6实现继承 - Class</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class实现继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance5 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(instance5); <span class="comment">// =&gt; Child: &#123;colors: ["red", "blue", "green"]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance5.colors); <span class="comment">// =&gt; ["red", "blue", "green"]</span></span><br><span class="line">instance5.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance5); <span class="comment">// =&gt; Child: &#123;colors: ["red", "blue", "green", "black"]&#125;</span></span><br><span class="line"><span class="keyword">let</span> instance6 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(instance6.colors); <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>面试</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式-单例模式</title>
    <url>/archives/1fbfc57.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript的设计模式-单例模式。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>单例模式(Singleton)：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>单例模式的实现在于保证一个特定类只有一个实例，第二次使用同一个类创建新对象的时候，应该得到与第一次创建对象完全相同的对象。</p><p><code>JavaScript</code> 的单例应该视作初始化后不被修改的变量。如此看来，其实单例模式是 <code>Javascript</code> 里应用最广泛的设计模式，使用CDN引入的所有库文件的入口都是单例，比如大名鼎鼎的 <code>jQuery</code>。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如：线程池、全局缓存、浏览器中的window 对象等。</p><p>在 <code>JavaScript</code> 开发中，单例模式的用途同样广泛，比如 登录浮窗、购物车、ES6模块化、库文件（<code>jQuery</code>）、<code>webSocket</code>、vuex中的store 等。</p><h2 id="单例的实现"><a href="#单例的实现" class="headerlink" title="单例的实现"></a>单例的实现</h2><h3 id="最简单的对象字面量"><a href="#最简单的对象字面量" class="headerlink" title="最简单的对象字面量"></a>最简单的对象字面量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = &#123;</span><br><span class="line">  a: <span class="string">"aaa"</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> ton1 = singleton;</span><br><span class="line"><span class="keyword">let</span> ton2 = singleton;</span><br><span class="line"><span class="built_in">console</span>.log(ton1 === ton2); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>十分简单，并且非常使用，不足之处在于没有什么封装性，所有的属性方法都是暴露的。对于一些需要使用私有变量的情况就显得心有余而力不足了。当然在对于 this 的问题上也是有一定弊端的。</p><h3 id="静态属性中的实例"><a href="#静态属性中的实例" class="headerlink" title="静态属性中的实例"></a>静态属性中的实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Universe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> Universe.instance === <span class="string">"object"</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> Universe.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    Universe.instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> uni1 = <span class="keyword">new</span> Universe();</span><br><span class="line"><span class="keyword">let</span> uni2 = <span class="keyword">new</span> Universe();</span><br><span class="line"><span class="built_in">console</span>.log(uni1 === uni2); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>在构造函数的静态属性中缓存该实例，缺点在于 instance 属性是公开可访问的属性，在外部代码中可能会修改该属性。</p><h3 id="闭包中的实例"><a href="#闭包中的实例" class="headerlink" title="闭包中的实例"></a>闭包中的实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Universe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="keyword">this</span>;</span><br><span class="line">    Universe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> uni1 = <span class="keyword">new</span> Universe();</span><br><span class="line"><span class="keyword">let</span> uni2 = <span class="keyword">new</span> Universe();</span><br><span class="line"><span class="built_in">console</span>.log(uni1 === uni2); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>当第一次调用构造函数时，它正常返回 this ，然后在以后调用时，它将会执行重写构造函数，这个构造函数通过闭包访问了私有 <code>instance</code> 变量，并且简单的返回了该 <code>instance</code>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-ApplyCall</title>
    <url>/archives/495da9ad.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript中的 <code>call()</code> 和 <code>apply()</code> 方法。</p><a id="more"></a><p>每个函数都包含两个非继承而来的方法： <code>call()</code> 和 <code>apply()</code> 方法。他们的作用都是在特定的作用域中调用函数，等于设置函数体内 <code>this</code> 对象的值，以扩充函数赖以运行的作用域。</p><p><strong>换句话说，<code>call()</code> 和 <code>apply()</code> 都是用来重新定义 <code>this</code> 这个对象的。</strong></p><p>在解析他们之前，先看两个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e.g.1</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"zi jun"</span>, age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> myInfo = &#123;</span><br><span class="line">    name: <span class="string">"Devin"</span>,</span><br><span class="line">    realAge: <span class="keyword">this</span>.age,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我的名字："</span> + <span class="keyword">this</span>.name + <span class="string">", 年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(myInfo.realAge); <span class="comment">// =&gt; 20</span></span><br><span class="line"><span class="built_in">console</span>.log(myInfo.sayHello()); <span class="comment">// 我的名字：Devin, 年龄：undefined</span></span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call()"></a><code>call()</code></h3><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a><code>apply()</code></h3><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>apply</tag>
        <tag>call</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-严格模式</title>
    <url>/archives/fb69cc5d.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript严格模式的详解。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>除了正常运行模式，ECMAscript5 中添加了第二种运行模式：“严格模式”（strict mode）。顾名思义，<code>这种模式要求JavaScript</code> 在更严格的模式中运行。</p><p>设立“严格模式”的目的，主要有以下几个原因：</p><ul><li>消除 <code>JavaScript</code> 语法的一些不合理，不严谨之处，减少一些怪异行为</li><li>消除代码运行的一些不安全之处，保证代码运行的安全</li><li>提高编译效率，增加运行速度</li></ul><p>e.g. 浏览器中 <code>F12</code> 键进入调试模式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3.14</span>; <span class="comment">// 不会报错，正常</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"user strict"</span></span><br><span class="line">y = <span class="number">6.18</span>; <span class="comment">// Uncaught ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure><h2 id="进入标志"><a href="#进入标志" class="headerlink" title="进入标志"></a>进入标志</h2><p>进入“严格模式”的标志，是 <code>&quot;use strict&quot;;</code>。老版本的浏览器会把它当做一行普通的字符串，会忽略。</p><h2 id="如何调用"><a href="#如何调用" class="headerlink" title="如何调用"></a>如何调用</h2><p>“严格模式”有两种调用方式</p><ol><li><p>针对整个脚本文件</p><p>需要将 <code>&quot;use strict&quot;;</code> 放在脚本文件的第一行。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="meta">    "use strict"</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 以下代码为 严格模式</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 以下代码为 正常模式</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>针对单个函数</p><p>需要将 <code>&quot;use strict&quot;;</code> 放在函数体的第一行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="string">"user strict"</span>;</span><br><span class="line">    <span class="comment">// 以下代码为 严格模式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noStrict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 以下代码为 正常模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h2><ul><li><p>不允许使用未声明的变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">a = <span class="number">1</span>; <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;&#125; <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>不允许删除变量或对象，只有 <code>configurable</code> 设置为 <code>true</code> 的对象属性，才能被删除</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">// Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">delete</span> b.x; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><div class="note warning no-icon"><p>为什么 <code>var</code> / <code>let</code> / <code>const</code> 声明的变量无法删除？<br></p><p>在正常模式，变量或对象执行 <code>delete</code> 不会报错，但是删除操作不会成功。比如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> d = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">delete</span> c;</span><br><span class="line"><span class="keyword">delete</span> d;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><p><strong>究其原因，是因为用不管是在正常模式还是“严格模式”下，<code>var</code> 声明的变量，其属性是 <code>configuarable = false</code>，所以不能删除</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">'a'</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    configurable: false,</span></span><br><span class="line"><span class="comment">    enumerable: true,</span></span><br><span class="line"><span class="comment">    value: 1,</span></span><br><span class="line"><span class="comment">    writable: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>更多的 对象属性，可查看<a href="/archives/27b30017.html">《JavaScript进阶-对象属性》</a></p></div></li><li><p>不允许删除函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">delete</span> foo; <span class="comment">// Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br></pre></td></tr></table></figure></li><li><p>不允许变量重名</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, x</span>)</span>&#123;&#125; <span class="comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure></li><li><p>不允许使用八进制</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">010</span>; <span class="comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span></span><br></pre></td></tr></table></figure></li><li><p>不允许使用转义字符</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">let</span> x = \<span class="number">010</span>; <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure></li><li><p>不允许对只读属性赋值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"x"</span>, &#123;<span class="attr">value</span>:<span class="number">0</span>, <span class="attr">writable</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">obj.x = <span class="number">3.14</span>; <span class="comment">// Uncaught TypeError: Cannot assign to read only property 'x' of object '#&lt;Object&gt;'</span></span><br></pre></td></tr></table></figure></li><li><p>不允许对一个使用getter方法读取的属性进行赋值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="keyword">get</span> x() &#123;<span class="keyword">return</span> <span class="number">0</span>&#125; &#125;;</span><br><span class="line">obj.x = <span class="number">3.14</span>; <span class="comment">// Uncaught TypeError: Cannot set property x of #&lt;Object&gt; which has only a getter</span></span><br></pre></td></tr></table></figure></li><li><p>不允许删除一个不允许删除的属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">// Uncaught TypeError: Cannot delete property 'prototype' of function Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>变量名不能使用 <code>eval</code> 字符串</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span> = <span class="number">3.14</span>; <span class="comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span></span><br></pre></td></tr></table></figure></li><li><p>变量名不能使用 <code>arguments</code> 字符串</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="number">3.14</span>; <span class="comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span></span><br></pre></td></tr></table></figure></li><li><p>在作用域 <code>eval()</code> 创建的变量不能被调用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">eval</span> (<span class="string">"var x = 2"</span>);</span><br><span class="line">alert (x); <span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>禁止 <code>this</code> 关键字指向全局对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">f(); <span class="comment">// Uncaught TypeError: Cannot set property 'a' of undefined</span></span><br></pre></td></tr></table></figure></li><li><p>保留关键字（<code>implements</code>、<code>interface</code>、<code>let</code>、<code>package</code>、<code>private</code>、<code>protected</code>、<code>public</code>、<code>static</code>、<code>yield</code>）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> public = <span class="number">2</span>; <span class="comment">// Uncaught SyntaxError: Unexpected strict mode reserved word</span></span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-变量声明</title>
    <url>/archives/71a05d55.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript中变量和函数的声明，<code>let</code>, <code>const</code>, <code>function</code>, <code>var</code>。</p><a id="more"></a><p>要想搞清楚提升的本质，这里主要需要理解 <code>JavaScript</code> 变量的 <strong>创建</strong>(create)、<strong>初始化</strong>(initialize)、<strong>赋值</strong>(assign)。</p><h2 id="var声明"><a href="#var声明" class="headerlink" title="var声明"></a>var声明</h2><p>假设有如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// =&gt; undefined</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>以上代码解析：</p><ol><li><code>JavaScript</code>引擎编译阶段：创建变量 - 作用域创建函数变量 <code>fn</code> (<code>function fn(){...}</code>)</li><li><code>JavaScript</code>引擎执行阶段：进入 <code>fn</code>,为 <code>fn</code> 创建一个环境</li><li><code>JavaScript</code>引擎编译阶段：创建变量 - 作用域创建变量 <code>x</code>, <code>y</code></li><li><code>JavaScript</code>引擎编译阶段：初始化变量 - <code>x</code>, <code>y</code> 分别为 <code>undefined</code></li><li><code>JavaScript</code>引擎执行阶段：赋值 - <code>x</code> 赋值为1， <code>y</code> 赋值为2</li></ol><p>结论：<code>var</code> 声明会在代码执行之前（编译阶段）就完成了变量的 <strong>创建</strong>、<strong>初始化</strong>。这就解释了为什么在 <code>var x = 1;</code>之前，<code>console.log(x)</code> 会得到 <code>undefined</code>。</p><h2 id="function声明"><a href="#function声明" class="headerlink" title="function声明"></a>function声明</h2><p>假设有如下代码，也可以看上面的一段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn2();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>); <span class="comment">// =&gt; 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码解析：</p><ol><li><code>JavaScript</code>引擎编译阶段：创建变量 - 作用域创建函数变量 <code>fn2</code> (<code>function fn2(){...}</code>)</li><li><code>JavaScript</code>引擎执行阶段：进入 <code>fn2</code>,为 <code>fn2</code> 创建一个环境</li><li><code>JavaScript</code>引擎执行阶段：执行代码</li></ol><div class="note warning no-icon"><p><code>var a = 1;</code> 的提升，相当于在顶部执行了 <code>var a;</code> 和 <code>a = 1;</code> <strong>创建</strong> 和 <strong>初始化</strong></p><p><code>function fn(){}</code> 的创建相当于把这个函数整体提升到了顶部，<strong>创建</strong> 和 <strong>初始化</strong>，并不存在 <strong>赋值</strong> 一说，因为按照《你不知道的JavaScript(上卷)》的解释：</p><blockquote><p>如果将函数声明 <code>function fn(a) {..}</code> 概念化为普通的变量声明和赋值，比如 <code>var fn;</code> <code>fn = function(a){..}</code> 。如果这样理解的话，这个函数声明将需要进行LHS查询。实际上引擎在执行代码时，不会有专门用来将一个函数值 “分配给” <code>fn</code>。因此，将函数声明理解成LHS查询和赋值的形式并不合适。</p></blockquote></div><h2 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h2><p>假设有如下代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// Uncaught ReferenceError: Cannot access 'x' before initialization</span></span><br><span class="line">    <span class="keyword">let</span> x;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码解析：</p><ol><li><code>JavaScript</code>引擎编译阶段(块作用域)：创建变量 - 创建变量 <code>x</code></li><li><code>JavaScript</code>引擎执行阶段(块作用域)：执行代码 <code>console.log(x)</code>，RHS查询变量 <code>x</code></li><li><code>JavaScript</code>引擎执行阶段(块作用域)：初始化 - <code>x</code> 初始化 <code>x = undefined</code></li><li><code>JavaScript</code>引擎执行阶段(块作用域)：赋值 - 变量 <code>x</code> 赋值为2</li></ol><div class="note warning no-icon"><p>为何不是报错为 <code>undefined</code>？个人总结如下：</p><ul><li><code>defined/undefined</code> 界定的标准是：变量是否创建和初始化</li></ul></div><p>上面代码，可以直观感受到 <code>let</code> 中没有变量提升，因为在变量声明之前使用变量都报错了。如果按照 <code>var</code> 申明变量的逻辑分析，如果有变量提升，那么在对 <code>x</code> 进行RHS查询的时候，不应该报错。真的是 <code>let</code> 中没有变量提升吗？看以下例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// Uncaught ReferenceError: Cannot access 'x' before initialization</span></span><br><span class="line">    <span class="keyword">let</span> x;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码解析：</p><ol><li><code>JavaScript</code>引擎编译阶段(外层)：创建变量 - 创建变量 <code>x</code> 并初始化 <code>x = 1</code></li><li><code>JavaScript</code>引擎编译阶段(内层)：创建变量 - 创建变量 <code>x</code></li><li><code>JavaScript</code>引擎执行阶段(内层)：执行代码 <code>console.log(x)</code>，<code>RHL</code>查询变量 <code>x</code></li><li><code>JavaScript</code>引擎执行阶段(内层)：初始化 - <code>x = undefined</code></li><li><code>JavaScript</code>引擎执行阶段(内层)：赋值 - <code>x = 2</code></li></ol><p>从这段代码可以看出，内层环境中 <code>x</code> 变量肯定是有提升的，不然，按照作用域的查询规格，就会查找外层的 <code>x</code>。</p><div class="note warning no-icon"><p>以上2段的代码可以总结出：</p><ul><li><code>var</code> 声明变量，其创建和初始化都是在编译过程中完成的，赋值在执行阶段</li><li><code>let</code> 声明变量，其创建是在编译过程中完成的，初始化和赋值则是在执行过程中完成的</li><li><code>defined/undefined</code> 界定的标准是：变量是否创建和初始化</li><li><code>initialization</code> 界定的标准是：变量是否初始化</li></ul></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>var</code> 声明变量，在引擎编译阶段完成变量的创建和初始化，也就是创建和初始化被提升了，变量赋值在引擎执行阶段</li><li><code>let</code> 声明变量，在引擎编译阶段完成变量的创建，也就是创建被提升了，变量初始化和赋值在引擎执行阶段</li><li><code>function</code> 声明函数，在引擎编译阶段完成函数的创建和初始化，也就是创建和初始化被提升了，不存在赋值一说</li><li><code>const</code> 声明常量，在引擎编译阶段完成变量的创建，也就是创建被提升了，变量初始化在引擎执行阶段，不允许赋值</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-字面量</title>
    <url>/archives/3d4f90ed.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript中字面量的详解。</p><a id="more"></a><h3 id="什么是字面量"><a href="#什么是字面量" class="headerlink" title="什么是字面量"></a>什么是字面量</h3><p>字面量(literal)表示如何表达这个值，一般除去表达式，给变量赋值时，等号右边都可以认为是字面量</p><p>字面量</p><ul><li>字符串字面量</li><li>数组字面量</li><li>对象字面量</li><li>函数字面量</li></ul><p>示例：<code>let str = “hello world”;</code> <code>&quot;hello world&quot;</code> 就是字符串字面量，<code>str</code> 是变量名。</p><p><strong>字面量，简单理解，就是不用 <code>JavaScript</code> 的 <code>new</code> 操作符创建实例。</strong></p><h3 id="什么是对象字面量"><a href="#什么是对象字面量" class="headerlink" title="什么是对象字面量"></a>什么是对象字面量</h3><p><code>js</code> 创建对象的两种方式</p><ul><li>标准创建对象方式(<code>new</code>)</li><li>对象字面量创建方式</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准创建对象方式(new)</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.a = <span class="string">"aaa"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// =&gt; "aaa"</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象字面量创建方式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">"aaa"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// =&gt; "aaa"</span></span><br></pre></td></tr></table></figure><h3 id="对象字面量的特性"><a href="#对象字面量的特性" class="headerlink" title="对象字面量的特性"></a>对象字面量的特性</h3><ol><li><p>这种对象不是一个构造函数，不能使用 <code>new</code> 进行实例化</p></li><li><p>它是引用类型，也就意味着对象名是一个指针，当你把对象名赋值给另一个变量时，你在新变量上所做的任何操作都会影响源对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">"aaa"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = obj;</span><br><span class="line">b.b = <span class="string">"bbb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">// =&gt; "bbb"</span></span><br></pre></td></tr></table></figure></li><li><p>对象中的所有成员默认是公开的，如果想实现私有成员，只能采用ES6的 <code>Symbol</code> 来定义一个成员名，然后采用 <code>export</code> 模块化来达到隔离效果</p></li></ol><h3 id="测试字面量赋值效率"><a href="#测试字面量赋值效率" class="headerlink" title="测试字面量赋值效率"></a>测试字面量赋值效率</h3><p>在Chrome上做了对比：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"测试1"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"测试1"</span>); <span class="comment">// =&gt; 测试1: 0.256103515625ms</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"测试2"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"测试2"</span>); <span class="comment">// =&gt; 测试2: 0.6318359375ms</span></span><br></pre></td></tr></table></figure><p><strong>原因为：</strong> <code>{}</code> 是字面量，可以立即求值，而 <code>new Object()</code> 本质上是方法（只不过这个方法是内置的）调用，既然是方法调用，就涉及到在 <code>proto</code> 链中遍历该方法，当找到该方法后，又会生成方法调用调用必须的堆栈信息，方法调用结束后，还要释放该堆栈。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>字面量</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-对象属性</title>
    <url>/archives/27b30017.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要详细记录JavaScript中的对象属性：命名属性、数据属性、访问器属性、内部属性。</p><a id="more"></a><h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><h3 id="对象属性类型"><a href="#对象属性类型" class="headerlink" title="对象属性类型"></a>对象属性类型</h3><ul><li>命名属性 - 可直接通过 <code>.</code> 访问到的属性</li><li>数据属性 - 专门保存一个值的属性</li><li></li><li>访问器属性 - 保护数据属性的特殊属性，不实际存储数据</li><li>内部属性 - 不能通过 <code>.</code> 直接访问的属性，比如 <code>class</code>、<code>__proto__</code></li></ul><h3 id="涉及的属性方法"><a href="#涉及的属性方法" class="headerlink" title="涉及的属性方法"></a>涉及的属性方法</h3><ul><li><code>Object.getOwnPropertyDescriptor(obj, &quot;属性名&quot;)</code>：获取指定属性的描述（必须是自有属性，不适用于原型链的属性）</li><li><code>Object.defineProperty(obj, &quot;属性名&quot;, {特性})</code>：在指定对象上添加新属性或修改属性，如果是新增且为指定特性，则会将数据属性的默认值全部设为 <code>false</code></li></ul><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性的4大特性</p><ul><li><code>configuable</code>：是否可配置，表示能否通过 <code>delete</code> 删除属性，默认为 <code>true</code></li><li><code>enumerable</code>： 是否可枚举，表示能够通过 <code>for-in</code> 循环返回属性，默认为 <code>true</code></li><li><code>value</code>：包含这个属性的数据值</li><li><code>writable</code>：是否可读写，表示能否修改属性的值，默认为 <code>true</code></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">'zi jun'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"name"</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	configurable: true,</span></span><br><span class="line"><span class="comment">	enumberable: true,</span></span><br><span class="line"><span class="comment">	value: "zi jun",</span></span><br><span class="line"><span class="comment">	writable: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"name"</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	configurable: true,</span></span><br><span class="line"><span class="comment">	enumberable: true,</span></span><br><span class="line"><span class="comment">	value: "zi jun",</span></span><br><span class="line"><span class="comment">	writable: false</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><div class="note warning"><p>在正常模式下，<code>delete</code> 一个 <code>configurable</code> 为 <code>false</code> 的变量或对象，不会报错，只是会删除不成功。而在“严格模式”下，则会报错。</p></div><div class="note warning no-icon"><p>针对变量对象，在“严格模式”下：</p><ul><li><p>如果是用 <code>var</code> 声明的，可以理解为在 <code>window</code> 对象上定义了这个属性，可以利用 <code>Object.getOwnPropertyDescriptor(obj, &quot;属性名&quot;)</code> 查看可配置特性，查看是否可删除。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">'a'</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    configurable: false,</span></span><br><span class="line"><span class="comment">    enumerable: true,</span></span><br><span class="line"><span class="comment">    value: 1,</span></span><br><span class="line"><span class="comment">    writable: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure></li><li><p>如果是用ES6+的 <code>let</code> / <code>const</code> 声明的，不能删除，如何理解？</p></li></ul></div><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性的4大特性</p><ul><li><code>get</code>：函数或 <code>undefined</code>，在取属性值时被调用 <code>getter</code> 访问器</li><li><code>set</code>：函数或 <code>undefined</code>，在设置属性值时被调用 <code>setter</code> 访问器</li><li><code>enumerable</code>：是否可枚举，表示能够通过 <code>for-in</code> 循环返回属性，默认为 <code>true``value</code>：包含这个属性的数据值</li><li><code>configuable</code>：是否可配置，表示能否通过 <code>delete</code> 删除属性，默认为 <code>true</code></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    _name: <span class="string">'zi jun'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    <span class="keyword">set</span>: function(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = <span class="string">"new name: "</span> + value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person._name); <span class="comment">// =&gt; "zi jun"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// =&gt; "My name is zi jun"</span></span><br><span class="line">person.name = <span class="string">"Devin"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// =&gt; My name is new name: Devin</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-防抖节流</title>
    <url>/archives/a635d2be.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript的防抖和节流。</p><a id="more"></a><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>防抖确保了一个函数只有在一个固定的时间段内没有被调用过后，才会被调用。比如说只有在1毫秒过后，才允许执行这个函数。</p><p><strong>换句话说：防抖会等待事件不再高频触发，再触发。</strong></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay &#123;number&#125; 等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn &#123;Function&#125; 需执行函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">delay, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn(...args);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>节流限制了一个函数可以在短时间内被调用的次数。比如说在1毫秒内最多执行此函数1次。</p><p><strong>换句话说：节流会忽略在短时间内高频发生的事件，只按照计划好的频率触发。</strong></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay &#123;number&#125; 计划好的执行间隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn &#123;Function&#125; 需执行函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params">delay, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastCall = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> NOW = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</span><br><span class="line">        <span class="keyword">if</span>(NOW - lastCall &lt; delay) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastCall = NOW;</span><br><span class="line">        <span class="keyword">return</span> fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>防抖在我们关心高频事件发生过后，得到的那个结果的时候，比较有用，比如用户迅速输入完一串用户名，对其进行查重的结果</li><li>节流在我们不关心函数参数是什么的时候比较有用，比如鼠标移动，滚轮事件，我们在乎的是操作的频率</li></ul><h3 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h3><ul><li><p>防抖(<code>debounce</code>)</p><ul><li>Search搜索联想，用户在不断输入值时，用防抖来节约请求资源</li><li>Window触发Resize的时候，不断调整浏览器窗口大小会不断触发这个事件，用防抖让其只触发一次</li></ul></li><li><p>节流(<code>throttle</code>)</p><ul><li>验证码在指定时间内只发送一次</li><li>监听滚动事件，比如是否滑到底部自动加载更多</li></ul></li></ul><h3 id="为什么要用闭包"><a href="#为什么要用闭包" class="headerlink" title="为什么要用闭包"></a>为什么要用闭包</h3><p>如果页面只需要处理一个防抖/节流函数，不需要闭包也是可以实现的，可以将变量变成全局变量，比如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个防抖处理</span></span><br><span class="line"><span class="keyword">let</span> timer</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">delay, fn</span>) </span>&#123;</span><br><span class="line">        timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn(...args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样处理会出现如下问题：</p><ol><li>对于一个页面上需要多个防抖函数的时候，需要写很多重复代码</li><li>全局变量污染作用域</li></ol><p>这时候闭包的优势就体现出来了，保护全局作用域不被污染，又能做到函数复用。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>正则基础</title>
    <url>/archives/bfcd137d.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录正则表达式的基础。</p><a id="more"></a><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><p>正则表达式就是处理字符串的，也可以用它来处理一些复杂的字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出这个字符串中的所有数字</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'abc123de45fgh6789ijk0'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+/g</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)); <span class="comment">// &gt; ["123", "45", "6789", "0"]</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式的创建方式"><a href="#正则表达式的创建方式" class="headerlink" title="正则表达式的创建方式"></a>正则表达式的创建方式</h2><p>创建正则表达式有两种方式：</p><ul><li>字面量创建方式（常用方式）： <code>const reg = /pattern/flags;</code></li><li>实例创建方式: <code>const reg = new RegExp(parttern, flags);</code></li></ul><p>其中 <code>pattern</code> 为正则表达式，<code>flags</code> 为标识（修饰符）。</p><p>其中修饰符有3中：</p><ul><li><code>i</code>: 忽略大小写匹配</li><li><code>g</code>: 全局匹配，应用于所有字符串，而非在找到第一个匹配项时停止</li><li><code>m</code>: 多行匹配，到达一行文本末尾时不停止，继续下一行匹配</li></ul><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p><strong>代表特殊含义的元字符</strong></p><ul><li><code>\d</code>: 0-9之间的任意数字，<code>\d</code>只占一个位置</li><li><code>\w</code>: 数字，字母，下划线 0-9，a-z，A-Z</li><li><code>\s</code>: 空格或者空白</li><li><code>\D</code>: 除了数字</li><li><code>\W</code>: 除了数字，除了字母，除了下划线</li><li><code>\S</code>: 除了空格，除了空白</li><li><code>\n</code>: 匹配换行符</li><li><code>.</code>: 处理换行符的任意一个字符</li><li><code>\</code>: 转义字符</li><li><code>|</code>: 或者</li><li><code>()</code>: 分组</li><li><code>^</code>: 限定开始位置，本身不占用位置</li><li><code>$</code>: 限定结束位置，本身不占位置</li><li><code>[a-z]</code>: 任意字母，<code>[]</code>表示任意一个</li><li><code>[^a-z]</code>: 非字母， <code>[]</code> 中 <code>^</code>表示除了</li><li><code>[abc]</code>: abc三个字母中的任何一个</li><li><code>[^abc]</code>: 除了abc这三个字母中的任何一个字符</li></ul><p><strong>代表次数的量词元字符</strong></p><ul><li><code>*</code>: 0到多个</li><li><code>+</code>: 1到多个</li><li><code>?</code>: 0次或者1次，可有可无</li><li><code>{n}</code>: 正好n次</li><li><code>{n,}</code>: n到多次</li><li><code>{n, m}</code>: n到m次</li></ul><div class="note warning no-icon"><ul><li>量词出现在元字符后面，如 <code>\d+</code>， 表示限定出现在前面的元字符的次数</li><li>一般 <code>[]</code> 中的字符没有特殊含义</li><li><code>()</code>具有提高优先级的功能，凡是有 <code>|</code> 出现的时候，我们一定需要 <code>()</code> 来提高优先级</li></ul></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'1223334444'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d&#123;2&#125;/g</span>; <span class="comment">// 限定元字符的量级</span></span><br><span class="line"><span class="keyword">const</span> res = str.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &gt; ["12", "23", "33", "44", "44"]</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'  我这里是空格  '</span>;</span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/^\s+|\s+$/g</span>;</span><br><span class="line"><span class="keyword">const</span> res2 = str2.replace(reg2, <span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// &gt; 我这里是空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般[]中的字符没有特殊含义</span></span><br><span class="line"><span class="keyword">const</span> str1 = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'dbc'</span>;</span><br><span class="line"><span class="keyword">const</span> str3 = <span class="string">'.bc'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/[ab.]bc/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str1)); <span class="comment">// &gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)); <span class="comment">// &gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str3)); <span class="comment">// &gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配18-65年龄段</span></span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/(18|19)|[2-5]\d|6[0-5]/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg2.test(<span class="number">66</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ()提高优先级</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'aaabbb'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/(a+)(?:b+)/</span>;</span><br><span class="line"><span class="keyword">const</span> res = str.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &gt; ["aaabbb", "aaa", index: 0, input: "aaabbb", groups: undefined]</span></span><br></pre></td></tr></table></figure><h2 id="正则的特性"><a href="#正则的特性" class="headerlink" title="正则的特性"></a>正则的特性</h2><ul><li>贪婪性：所谓的贪婪性就是正则在捕获时，每一次会尽可能多的去捕获符合条件的内容。如果我们想尽可能的少去捕获符合条件的字符串的话，可以在量词元字符后加 <code>?</code></li><li>懒惰性：懒惰性则是正则在成功捕获一次后不管后面的字符串有没有符合条件的，都不再捕获。如果要捕获目标中所有符合条件的字符串，可以用标识符 <code>g</code> 标明全局捕获</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'123aa456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+/</span>; <span class="comment">// 懒惰性：只捕获一次，贪婪性：一次尽可能多的捕获</span></span><br><span class="line"><span class="keyword">const</span> res = str.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &gt; ["123", index: 0, input: "123aa456", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/\d+/g</span>; <span class="comment">// 解决懒惰性，但有贪婪性</span></span><br><span class="line"><span class="keyword">const</span> res2 = str.match(reg2);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// &gt; ["123", "456"]</span></span><br><span class="line"><span class="keyword">const</span> reg3 = <span class="regexp">/\d+?/</span>; <span class="comment">// 解决贪婪性，但有懒惰性</span></span><br><span class="line"><span class="keyword">const</span> res3 = str.match(reg3);</span><br><span class="line"><span class="built_in">console</span>.log(res3); <span class="comment">// &gt; ["1", index: 0, input: "123aa456", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reg4 = <span class="regexp">/\d+?/g</span>; <span class="comment">// 解决贪婪性、懒惰性</span></span><br><span class="line"><span class="keyword">const</span> res4 = str.match(reg4);</span><br><span class="line"><span class="built_in">console</span>.log(res4); <span class="comment">// &gt; ["1", "2", "3", "4", "5", "6"]</span></span><br></pre></td></tr></table></figure><h2 id="正则的相关方法"><a href="#正则的相关方法" class="headerlink" title="正则的相关方法"></a>正则的相关方法</h2><ol><li><code>reg.test(str)</code>: 验证字符串是否符合正则，符合返回 <code>true</code>， 否则返回 <code>false</code></li><li><code>reg.exec(str)</code>: 用来捕获符合规则的字符串</li><li><code>str.match(reg)</code>: 如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返 <code>null</code></li><li><code>str.replace(reg)</code>: 替换字符串</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reg.test(str)</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\w+/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)); <span class="comment">// &gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reg.exec(str)</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'abc123cba456aaa789'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str)); <span class="comment">// &gt; ["123", index: 3, input: "abc123cba456aaa789", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// str.match(reg)</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'abc123cba456aaa789'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)); <span class="comment">// &gt; ["123", "456", "789"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// str.replace(reg)</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'a111bc222de'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+/g</span>;</span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/\d/g</span>;</span><br><span class="line"><span class="keyword">const</span> res = str.replace(reg, <span class="string">'?'</span>);</span><br><span class="line"><span class="keyword">const</span> res2 = str.replace(reg2, <span class="string">'?'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &gt; a?bc?de</span></span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// &gt; a???bc???de</span></span><br></pre></td></tr></table></figure><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>用于查找在某些内容（但不包括这些内容）之前或之后的东西，这个位置应该满足一定的条件（即断言），因此也被称为零宽断言。</p><ul><li>零宽度正预测先行断言 <code>(?=exp)</code> 字符出现的位置的右边必须匹配到exp这个表达式</li><li>零宽读负预测先行断言 <code>(?!exp)</code> 字符出现的位置的右边不能是exp这个表达式</li><li>零宽度正回顾后发断言 <code>(?&lt;=exp)</code> 字符出现的位置的前边是exp这个表达式</li><li>零宽度负回顾后发断言 `(? 字符出现的位置的前边不是exp这个表达式</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (?=exp)</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"i'm singing and dancing"</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\w+(?=ing)/g</span>;</span><br><span class="line"><span class="keyword">const</span> res = str.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &gt; ["sing", "danc"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (?!exp)</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'nodejs'</span>;</span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/node(?!js)/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg2.test(str2)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (?&lt;=exp) </span></span><br><span class="line"><span class="keyword">const</span> str3 = <span class="string">'￥998$888'</span>;</span><br><span class="line"><span class="keyword">const</span> reg3 = <span class="regexp">/(?&lt;=\$)\d+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str3.match(reg3)); <span class="comment">// &gt; ["888"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (?&lt;!exp)</span></span><br><span class="line"><span class="keyword">const</span> str4 = <span class="string">'￥998$888'</span>;</span><br><span class="line"><span class="keyword">const</span> reg4 = <span class="regexp">/(?&lt;!\$)\d+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str4.match(reg4)); <span class="comment">// &gt; ["998", "88"]</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>正则</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>常用正则整理</title>
    <url>/archives/94c6a923.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要了常用的正则表达式，便于工作查询。</p><a id="more"></a><h2 id="校验数字"><a href="#校验数字" class="headerlink" title="校验数字"></a>校验数字</h2><ol><li>大于等于0的整数：<code>/^\d+$/</code></li><li>大于等于1的整数：<code>/^[1-9]\d*$/</code>·····1</li><li>大于等于2的整数：<code>/^([1-9]\d+|[2-9])$/</code></li><li>大于0（包括小数）：<code>/^(?!(0[0-9]{0,}$))[0-9]{1,}[.]{0,}[0-9]{0,}$/</code></li><li>大于等于0（包括小数）：<code>/^([0-9]+(\.\d+)?|0\.\d+)$/</code></li></ol><h2 id="校验字符"><a href="#校验字符" class="headerlink" title="校验字符"></a>校验字符</h2><ol><li>中文：<code>/[\u4E00-\u9FA5]/</code></li><li>英文和数字：<code>/^[A-Za-z0-9]+$/</code></li><li>数字、26个英文字母或者下划线组成：<code>^\w+$</code></li></ol><h2 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h2><ol><li>超链接：<code>/http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&amp;=]*)?/</code></li><li>身份证号码：<code>/^([0-9]){7,18}(x|X)?$/</code></li><li>用户名（只能包括数字、字母、下划线，4-12位）：<code>/^[a-zA-z]\w{3,11}$/</code></li><li>密码（只能包括数字、字母、下划线，6-12位）：<code>/^[a-zA-z]\w{5,11}$/</code></li><li>手机号码：<code>/^1\d{10}$/</code></li><li>座机号码：<code>/^0\d{2,3}-?\d{7,8}$/</code></li><li>邮箱：<code>/^(\w-*\.*)+@(\w-?)+(\.\w{2,})+$/</code></li><li>微信号：<code>/^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/</code></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>正则</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>Anywhere本地静态服务</title>
    <url>/archives/f1c4558.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录本地服务的开启，anywhere的使用，类似有live-server。</p><a id="more"></a><h2 id="开启本地静态服务"><a href="#开启本地静态服务" class="headerlink" title="开启本地静态服务"></a>开启本地静态服务</h2><ol><li><code>npm install anywhere -g</code> ， 全局安装 <code>anywhere</code></li><li>cmd键入到要启动静态服务的目录</li><li><code>anywhere</code> 或者 <code>anywhere -p 7890</code> 启动静态服务</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Windows</category>
        <category>Server</category>
      </categories>
      <tags>
        <tag>anywhere</tag>
        <tag>静态服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Live-Server本地静态服务</title>
    <url>/archives/eb7f8542.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录本地服务的开启，live-server的使用，类似有anywhere。</p><a id="more"></a><h2 id="开启本地静态服务"><a href="#开启本地静态服务" class="headerlink" title="开启本地静态服务"></a>开启本地静态服务</h2><ol><li><code>npm install live-server -g</code> ， 全局安装 <code>live-server</code></li><li>cmd键入到要启动静态服务的目录</li><li><code>live-server</code> 或者 <code>live-server --port=7876</code> 启动静态服务</li></ol><div class="note info"><p>live-server 对比 anywhere ：live-serve 支持热更新，而anywhere则需要手动刷新。</p></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Windows</category>
        <category>Server</category>
      </categories>
      <tags>
        <tag>静态服务</tag>
        <tag>live-server</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Cmd命令</title>
    <url>/archives/fd31ce3.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录cmd常用的一些命令。</p><a id="more"></a><h2 id="常用Cmd命令"><a href="#常用Cmd命令" class="headerlink" title="常用Cmd命令"></a>常用Cmd命令</h2><ul><li><code>dir</code> 查看当前文件夹下的文件及文件夹</li><li><code>cd</code> 切换目录/文件</li><li><code>cd file</code> 进入当前文件夹下的file文件夹</li><li><code>cd fold1/fold2</code> 或者 <code>cd fold1\fold2</code> 进入多层文件夹</li><li><code>cd ..</code> 进入上一层文件夹</li><li><code>cd ../folder</code> 进入上一层文件夹中的folder文件夹</li><li><code>mkdir myfolder</code> 或 <code>md myfolder</code> 在当前目录下创建myfolder文件夹</li><li><code>type nul &gt; my.txt</code> 创建空白的my.txt文件</li><li><code>echo content &gt; test1.py</code> 创建内容是content的my.txt文件</li><li><code>type test1.py</code> 查看在当前目录下的test1.py文件内容，把内容打印到cmd中</li><li><code>test1.py</code> 直接输入文件名，用默认程序打开此文件（相当于鼠标双击）</li><li><code>ren oldname newname</code> 重命名</li><li><code>del test1.py</code> 删除文件</li><li><code>del myfolder</code> 删除myfolder文件夹中的所有文件（文件夹保留）</li><li><code>rd myfolder</code> 或者 <code>rmdir myfolder</code> 删除myfolder文件夹</li><li><code>tree myfolder</code> 将myfolder文件夹下的所有文件夹展示成树状结构（不展示文件）</li><li><code>tree myfolder /f</code> 展示文件夹及文件树状结构</li><li><code>tree myfolder /f &gt; my.txt</code> 将结果输出到my.txt文件中（新建的文件）</li><li><code>cls</code> 清屏</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Windows</category>
        <category>Cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>读《你不知道的JavaScript(上卷)》</title>
    <url>/archives/3dacf7de.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录阅读《你不知道的JavaScript（上卷）》的一些笔记，主要内容为作用域和闭包、this和原型对象。</p><a id="more"></a><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p><strong>作用域</strong> 用一套设计好的规则来存储变量，并在之后能够方便的找到这些变量，这套规则称之为作用域。</p><p><strong><code>JavaScript</code>的工作原理</strong></p><ul><li><code>JavaScript</code>引擎：从头到尾负责整个 <code>JavaScript</code> 程序的编译及执行过程</li><li><code>JavaScript</code>编译器：负责语法分析及代码生成等<ol><li>分词/词法分析(Tokenizing/Lexing)：这个过程会将字符代码分解为有意义的代码块，这些代码块称为词法单元(token)。例如：<code>var a = 2;</code> , 这段程序会被分解为 <code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>、<code>;</code>。</li><li>语法分析(Parsing)：这个过程是将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个数被称为“抽线语法树”(Abstract Syntax Tree, AST)。</li><li>代码生成()：将 <code>AST</code> 转换为可执行代码，简单来说就是有某种方法可以将 <code>var a = 2;</code> 的 <code>AST</code> 转换为一组机器指令，用来创建一个叫作 <code>a</code> 的变量(包括分配内存等)，并将一个值存储在 <code>a</code> 中。</li></ol></li><li><code>JavaScript</code>作用域：负责收集并维护由所有声明的标识符(变量)组成的一系列查询</li></ul><p><strong>作用域查询规则</strong></p><ul><li>LHS查询(Left Handle Search)：查找的目的是对变量进行赋值会触发（赋值操作的目标是谁，我要赋值了）</li><li>RHS查询(Right Handle Search)：查找的目的是获取变量的值会触发（谁是赋值操作的源头，我要用它）<ul><li>其查询规则为嵌套查询，也就是在当前作用域中没有查找到，引擎就会在外层嵌套中继续查找，直到最外层(全局作用域)为止</li><li>如果没有查找到，严格模式下，会抛出 <code>ReferenceError</code> 错误，非严格模式下，会自动在全局作用域下创建此变量</li><li>如果找到了，但是其之前没有被赋值，那么就会返回 <code>undefined</code></li></ul></li></ul><div class="note warning"><p>对象的属性或方法调用也会触发RHS查询</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure><p>上面代码解析过程如下：</p><ol><li>编译器对上面字符串进行分词、语法分析，然后生成代码</li><li>JS引擎联合作用域开始执行代码<ol><li><code>c</code> 需要被赋值，会触发一次LHS查询，然后需要使用 <code>foo(2)</code> 这个变量的值，这里会触发一次RHS查询</li><li><code>foo(2)</code> 调用过程中，参数赋值会隐式地触发一次 <code>a = 2</code> 的赋值操作，触发一次LHS查询</li><li>进入函数体，<code>var b = a;</code> <code>b</code> 需要被赋值，会触发一次LHS查询，然后需要使用 <code>a</code> 这个变量，这里会触发一次RHS查询，获取值</li><li><code>return a + b;</code> ，这里需要分别获取 <code>a</code> 和 <code>b</code> 这两个变量的值，所以会各自触发一次RHS查询，自此这一步，引擎共计进行了3次LHS查询，4次RHS查询</li></ol></li></ol><p><strong>作用域异常</strong></p><ul><li><code>ReferenceError</code>：作用域判别失败触发，比如在使用变量的时候未找到此变量的创建</li><li><code>TypeError</code>：作用域判别成功了，但是对结果的操作是非法或不合理<ul><li>引用 <code>null</code> 或 <code>undefined</code> 类型值中的属性</li><li>对一个非函数类型的值进行函数调用</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>.a); <span class="comment">// Uncaught TypeError: Cannot read property 'a' of null</span></span><br><span class="line"><span class="built_in">console</span>.log(b()); <span class="comment">// Uncaught TypeError: b is not a function</span></span><br></pre></td></tr></table></figure><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p><strong>作用域共有两种工作模型</strong></p><ul><li>词法作用域（大多数语言采用）</li><li>动态作用域（<code>Bash</code> 脚本、<code>Perl</code> 中的一些模式）</li></ul><p><strong>词法作用域</strong></p><p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里决定的，因此当词法分析器处理代码时会保持作用域不变。</p><p><strong>遮比效应</strong></p><div class="note warning"><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><p>我们要牢牢记住，词法作用域只关注函数在何处被声明，而不是在何处被调用，<code>foo</code> 函数位于全局作用域被声明，所以它对 <code>a</code> 变量的RHS查找当然是在全局作用域中。</p><p><strong>欺骗词法</strong></p><ul><li><code>eval()</code> <code>eval()</code> 函数可以接受一个字符串作为参数，并将里面的内容作为生成代码并执行。在正常模式下，<code>eval()</code> 中的内容中的声明（变量或函数），就会对所处的词法作用域进行修改</li><li><code>with</code> <code>with</code> 通常被当作重复引用同一个对象中的多个属性的快捷键，可以不需要重复引用对象本身</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 单调乏味的重复 obj</span></span><br><span class="line">obj.a = <span class="number">3</span>;</span><br><span class="line">obj.b = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 简单的快捷方式</span></span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning no-icon"><p><code>eval()</code> 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 <code>with</code> 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(obj) &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">    b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">foo(o1);</span><br><span class="line"><span class="built_in">console</span>.log(o1.a); <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line">foo(o2);</span><br><span class="line"><span class="built_in">console</span>.log(o2.a); <span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><p>为什么最后输出2？可以这样理解，当我们传递<code>o1</code>给<code>with</code>时，<code>with</code>所声明的作用域是<code>o1</code>，而这个作用域中含有一个同<code>o1.a</code>属性相符的标识符。但当我们将<code>o2</code>作为作用域时，其中并没有<code>a</code>标识符，因此进行了正常的LHS标识符查找。<code>o2</code>的作用域、<code>foo(..)</code>的作用域和全局作用域中都没有找到标识符<code>a</code>，因此当<code>a = 2</code>执行时，自动创建了一个全局变量（因为是非严格模式）。</p></div><div class="note warning"><p><code>eval()</code> 和 <code>with</code> 这两个可以欺骗词法作用域的机制，会导致 <code>JavaScript</code> 引擎在编译阶段的数项性能优化（基于词法静态分析的优化）失效，最终会导致性能下降。所以，在“严格模式”下，或是日常使用中，禁止使用它们。</p></div><h3 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h3><ul><li>函数内部的全部变量都可以在整个函数范围内使用和复用，函数外部无法访问到这些变量。</li><li>如果想要隐藏内部实现，可以再用一个函数包裹</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    foo(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line">foo(<span class="number">3</span>); <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure><p><strong>函数声明和函数表达式</strong></p><p>区分函数声明和函数表达式最简单的方法是看 <code>function</code> 关键字出现在声明中的位置，如果 <code>function</code> 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>)</span>&#123;&#125;)()</span><br></pre></td></tr></table></figure><div class="note warning"><p>立即执行函数（IIFE [Immedidately Invoked Function Expression]），比如：<code>(function foo(){..})()</code> 第一个 <code>()</code> 将函数变成表达式，第二个 <code>()</code> 执行了这个函数</p></div><p><strong>块作用域</strong></p><p>块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 <code>{..}</code> 内部）</p><ul><li>从ES3开始，<code>try/catch</code> 结构在 <code>catch</code> 分句中具有块作用域</li><li>ES6中， <code>let/const</code> 可以将变量绑定到所在的任意作用域中</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// =&gt; 0, 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码等同</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// =&gt; 0, 1, 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// =&gt; 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，<code>i</code> 会被绑定在 <code>for</code> 循环的外部作用域中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// =&gt; 0, 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码等同</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">let</span> i = j;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// =&gt; 0, 1, 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，<code>for</code> 循环头部的 <code>let</code> 不仅将 <code>i</code> 绑定到了 <code>for</code> 循环中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</p><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><ul><li>函数声明和变量(<code>var</code>)声明都会被提升，但函数会优先被提升，然后才是变量</li><li>提升出现在编译阶段，赋值则是执行阶段的任务</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上面代码第一个示例： <code>var a = 1</code>，<code>JavaScript</code> 实际上会将其看成两个声明 <code>var a;</code>, <code>a = 1;</code></p><ul><li><code>var a;</code> 是在编译阶段进行的</li><li><code>a = 1;</code> 赋值声明会在原地等待执行阶段，才进行处理</li></ul><p>上面代码第二个示例，虽然 <code>var a;</code> 被提升了，但查询 <code>a</code> 比赋值 <code>a</code> 早了一步， 所以输出是 <code>undefined</code></p><p><strong>函数优先</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">// =&gt; "Function"</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Var"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Fucntion"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数声明覆盖</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo(); &#x2F;&#x2F; 2</span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多的详情可见 <code>let</code>、<code>const</code>、<code>function</code>、<code>var</code> 详解，<a href="/archives/71a05d55.html">链接</a></p></blockquote><h3 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h3><h2 id="This和对象原型"><a href="#This和对象原型" class="headerlink" title="This和对象原型"></a>This和对象原型</h2><!-- rebuild by neat -->]]></content>
      <categories>
        <category>书籍</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>读《启示录-打造用户喜爱的产品》</title>
    <url>/archives/f9d474c3.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录阅读《启示录-打造用户喜爱的产品》一书的重点笔记。</p><a id="more"></a><p>打造一款成功产品的十条规律：</p><ol><li><p>产品经理的任务是探索产品的价值、可用性、可行性。</p></li><li><p>探索（定义）产品需要产品经理、交互设计师、软件架构师的通力合作。</p></li><li><p>开发人眼不擅长用户体验设计，因为开发人员脑子里想的是实现模型，而用户看重的是产品的概念模型。</p></li><li><p>用户体验设计就是交互设计、视觉设计。</p></li><li><p>功能（产品需求）和用户体验设计密不可分。</p></li><li><p>产品创意必须尽早的、反复的接受目标用户的试用，以便获取有效的用户体验。</p></li><li><p>为了验证产品的价值和可用性，必须尽早的、反复的请目标用户测试产品创意。</p></li><li><p>采用高保真的产品原型是全体团队成员了解用户需求和用户体验最有效的途径。</p></li><li><p>产品经理的目标是在最短的时间内把握复杂的市场、用户需求，确定产品的基本要求-价值、可用性、可行性。</p></li><li><p>一旦认定产品符合以上基本要求，它就是一个完整的概念，去掉任何因素，都不可能达到预期结果。</p></li></ol><h2 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h2><p>人员是指负责定义和开发产品的团队成员的角色和职责。</p><h3 id="界定产品经理和产品营销人员的职责"><a href="#界定产品经理和产品营销人员的职责" class="headerlink" title="界定产品经理和产品营销人员的职责"></a>界定产品经理和产品营销人员的职责</h3><ul><li>产品经理负责详细定义待开发的产品，让真实的用户测试产品</li><li>产品营销负责向外宣传和推广产品，负责产品发布，为扩展市场销售渠道、组织营销活动、醋精产品销售提供服务</li><li>营销人员是产品经理获取产品需求的重要来源，产品经理是营销人眼获取市场营销信息的重要来源</li></ul><h3 id="界定产品管理和项目管理"><a href="#界定产品管理和项目管理" class="headerlink" title="界定产品管理和项目管理"></a>界定产品管理和项目管理</h3><ul><li>产品管理的职责是探索（定义）有价值的、可用的、可行的产品</li><li>项目管理则关注如何执行计划以按期交付产品</li></ul><h3 id="优秀项目经理的七个特点"><a href="#优秀项目经理的七个特点" class="headerlink" title="优秀项目经理的七个特点"></a>优秀项目经理的七个特点</h3><ul><li>工作紧迫感。可以传递给大家工作的积极性和高效性。</li><li>善于捕捉问题。迅速的、准确的指出问题要害，改善会议效果。</li><li>思路清晰。需要排除排期冲突，日程中断等因素，专注执行时间和效率。</li><li>用数据说话。懂得利用数据识别项目方向，确认项目进度，改善开发流程。</li><li>果断。及时向团队收集数据和建议，适时向上级汇报，帮助大家有问题利用数据做出决策。</li><li>判断力。何时催促进度，何时向上级汇报，何时收集更多信息。</li><li>态度。不能为可行性、资源不足，时间不够，资金匮乏等找借口，必须自己克服。</li></ul><h3 id="产品经理与软件开发"><a href="#产品经理与软件开发" class="headerlink" title="产品经理与软件开发"></a>产品经理与软件开发</h3><ul><li>只有与开发团结融洽合作，才有可能开发出合格的产品</li><li>形成合作关系的关键是双方承认平等-任何一方不从属于另一方</li><li>开发可以帮助产品经理完善产品定义，因为开发最清楚产品设计的可行性</li><li>开发帮助产品经理完善产品定义的3种方式<ul><li>让开发人员直接面对用户或顾客，比如要求开发人员参加产品原型测试</li><li>项开发人员了解最新的技术发展动向，讨论哪些新技术可以应用于产品</li><li>在产品的初期阶段，让开发参与产品评估，协助策划方案</li></ul></li><li>产品经理配合开发人员的3条建议<ul><li>只定义满足基本要求的产品，然后更多的与开发之间形成良好的互动</li><li>一旦进入开发阶段，尽可能避免修改产品的需求</li><li>开发阶段如果遇到诸多问题，比如，用例丢失，设计缺陷等，应迅速在维持产品基本功能，尽量避免修改的原则上，拿出解决方案</li></ul></li><li>与开发团结合作应该遵循的规则：预留余量（20%）的自主时间。在产品管理上为开发团队预留20%的自主时间，让他们自由支配。开发团结可以利用这些时间重写代码、完善架构、重构代码库中有缺陷的部分，提高系统性能，避免“需要停下来重写代码”的情形发生。</li></ul><h3 id="产品经理必须成长的技能"><a href="#产品经理必须成长的技能" class="headerlink" title="产品经理必须成长的技能"></a>产品经理必须成长的技能</h3><ul><li>时间管理。熟练，迅速的区分重要任务和紧急任务，合理的规划和安排时间</li><li>对产品的热情。如果是你，你打算怎样完善自己最喜欢的产品</li><li>运用技术的能力。多学习和理解技术，并适时运用于产品当中</li><li>沟通技能。头口表达和书面表达。条理清晰，言简意赅。演讲推荐：《演讲致胜：讲故事的一书》</li><li>商业知识面。技术讨论、成本结构、边际效应、市场份额、产品定位和品牌等</li><li>学习思路：研发产品之前，需要学习哪些知识，需要多长时间，如何利用这些知识</li></ul><h3 id="产品总监"><a href="#产品总监" class="headerlink" title="产品总监"></a>产品总监</h3><ul><li>建设产品团队。注意要雇佣比自己聪明的人，团队成员的出色表现就是自己的出色表现</li><li>规划公司的产品战略。产品总监要负责制定产品组合路线图，兼顾用户需求和商业目标，从全局出发制定产品发布计划</li></ul><h3 id="产品经理的目标管理"><a href="#产品经理的目标管理" class="headerlink" title="产品经理的目标管理"></a>产品经理的目标管理</h3><ul><li>永远不要告诉别人怎么做。告诉他们做什么，他们自然会发挥天赋，给你惊喜</li><li>留给用户体验设计师和开发人员的空间越大，他们就越有可能打造出用户喜爱的产品</li></ul><h3 id="管理上司的几条经验"><a href="#管理上司的几条经验" class="headerlink" title="管理上司的几条经验"></a>管理上司的几条经验</h3><ol><li>为项目波动做好准备。提高警惕，记录工作进度。指定项目计划时，预留出时间应对变化和调整，做好“做无用功”的心理准备</li><li>注意沟通的方式和频率。有写人喜欢用邮件、聊天软件或是口头汇报，弄清上司的喜好，对症下药</li><li>会前沟通。组织好会议的诀窍是在正式会议召开前充分沟通，也就是逐一向高管和上司确认你的观点和建议，确保会议取得大家的一致意见，确保会议的高效率性</li><li>多提建议，少谈问题。管理者希望听到解决问题的方法，而不是抱怨。所以在提出问题的同时，并附上你的依据和建议</li><li>向上司借力。把想法告诉上司，让上司向高管传达建议</li><li>充分准备。在思路和计划上的漏洞多做思考做到事无巨细</li><li>多用数据和事实说话。多做准备工作，收集事实和数据，才有说服力</li></ol><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>流程是指探索、开发富有创意的产品时，反复应用的步骤和成功的实践经验。</p><h3 id="评估产品机会"><a href="#评估产品机会" class="headerlink" title="评估产品机会"></a>评估产品机会</h3><ol><li>产品要解决什么问题？（产品价值）</li><li>为谁解决这个问题？（目标市场）</li><li>成功的机会有多大？（市场规模）</li><li>怎样判断产品成功与否？（度量指标或收益指标）</li><li>有哪些同类产品？（竞争格局）</li><li>为什么我们适合做这个产品？（竞争优势）</li><li>时机合适吗？（市场时机）</li><li>如何把产品推向市场？（营销组合策略）</li><li>成功的必要条件是什么？（解决方案要满足的条件）</li><li>根据以上问题，给出评估结论。（继续或放弃）</li></ol><h3 id="软件项目的两个阶段"><a href="#软件项目的两个阶段" class="headerlink" title="软件项目的两个阶段"></a>软件项目的两个阶段</h3><ol><li>探索产品。弄清楚要开发什么产品，定义正确的产品。重心在分析各种创意，收集用户需求，运用新技术等</li><li>执行产品。开发该产品，正确的开发产品。重心在于执行-开发、测试、发布</li></ol><p>采用流水线方式并行开发产品。也就是说，一旦1.0版本的产品进入项目执行阶段，就开始定义2.0版本的产品。一旦前一个版本进入开发阶段，就把创造的热情投入到下一个版本中，这个版本可以收集上一个版本的问题，遗漏或建议等</p><h3 id="产品说明文档"><a href="#产品说明文档" class="headerlink" title="产品说明文档"></a>产品说明文档</h3><p>产品经理的核心责任是确保向开发团队交付具有成功潜力的产品说明文档。</p><p>理想的产品说明文档：</p><ol><li>产品说明文档应该完整地描述用户体验。不只是用户需求，还包括交互设计和视觉设计。</li><li>产品说明文档必须准确地描述软件的行为。文字和图片尽可能表达。</li><li>产品说明文档的直观化。由于受众较广，需要直接表现。</li><li>产品说明文档应该可以修改。开发阶段，总有意想不到的情况出现，需要修改说明文档以适应新情况。</li><li>产品说明文档，应该逻辑清晰，条理清晰，以主线或模块划分。</li></ol><p>只有一种形式的产品说明文档可以满足上述要求，那就是 <strong>高保真原型</strong>。</p><h3 id="用户体验设计"><a href="#用户体验设计" class="headerlink" title="用户体验设计"></a>用户体验设计</h3><p>敏捷方法里有个概念叫 “第零次迭代”，产品经理和用户体验设计师利用这段时间先完成产品设计工作，然后交由开发人员开始迭代开发。</p><h3 id="产品设计方式"><a href="#产品设计方式" class="headerlink" title="产品设计方式"></a>产品设计方式</h3><ol><li>产品经理与设计师合作设计产品的高保真原型。这个原型只具备实现商业目标的最基本的功能要求，以及良好的用户体验和吸引力。只设计基本功能的产品可以把复杂度降到最低，把开发时间减到最少。</li><li>邀请以为开发人员（比如架构师或主程序员）参与设计原型。请他检查原型，帮助产品经理和设计师估算各种功能的直接成本和间接成本，指出设计上的误区，并分析、评估尚不确定是否可行的功能。</li><li>请真实用户验证（测试）产品原型，这一点至关重要。在产品团队全力开发产品前，产品经理和设计师必须确信产品是用户需要的。</li></ol><h3 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h3><ul><li>创新不是发现新的问题，而是用新方法解决已有的问题。观察人们对现有产品的不满，是创新的最佳途径。</li><li>20%法则。用20%的工作时间来从事创新研究。</li></ul><h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><p>产品是指富有创意的产品具有的鲜明特征。</p><h3 id="苹果公司的产品启示"><a href="#苹果公司的产品启示" class="headerlink" title="苹果公司的产品启示"></a>苹果公司的产品启示</h3><ul><li>硬件为软件服务。与其他硬件公司不同，苹果公司明白硬件必须为软件服务，这种关系不能颠倒。软件直接服务用户，满足用户需求。</li><li>软件为用户体验服务。苹果公司的所有工作都围绕着产品的可用性、交互设计、视觉设计、工业设计展开。</li><li>用户体验为情感服务。他们比谁都清楚是什么让消费者为产品疯狂，他们知道怎样抓住用户的情感需求。</li><li>产品为真正的需求服务。手机并非苹果公司首创，但他们挖掘出尚未被满足的用户需求。</li></ul><h3 id="客户需求和产品需求"><a href="#客户需求和产品需求" class="headerlink" title="客户需求和产品需求"></a>客户需求和产品需求</h3><p>产品需求不能用户说了算，原因如下：</p><ol><li>在看到具体的产品之前，用户很难知道自己需要什么</li><li>用户不知道什么样的产品是可行的（在目前的技术条件下可以实现）</li><li>用户之前缺少沟通，需求很难统一</li></ol><h3 id="新瓶装老酒"><a href="#新瓶装老酒" class="headerlink" title="新瓶装老酒"></a>新瓶装老酒</h3><p>想要在成熟的市场抢占一席之地，精明的公司至少要手握两件“法宝”：</p><ol><li>对目标市场了如指掌，对现有产品的缺陷洞若观火。</li><li>跟踪最新的技术趋势，让之前无法实现的方案变得可能。</li></ol><h3 id="产品情感挖掘"><a href="#产品情感挖掘" class="headerlink" title="产品情感挖掘"></a>产品情感挖掘</h3><p>消费者分类：</p><ol><li>非理性消费者（即尝鲜者）的情感需求与大众的相同，但更为强烈。愤怒、恐惧、孤独这类消极情绪被放大后，会导致非理性消费行为。在生活中，非理性消费者为了满足情感需求，会付出大大超出解决问题本身所需要的精力和成本。</li><li>技术爱好者（即技术创新者）购买产品，仅仅是因为产品采用了新的技术。这类消费者容易误导产品经理。</li><li>普通大众具有和非理性消费者同样的情感需求，只是在程度上没有那么强烈。随着产品的完善，他们也会逐步加入消费者队伍。</li><li>理性消费者只会购买他们认为实用、成熟的产品。他们更务实，只会购买性价比合适的产品。</li><li>观望者（即跟随者）约占总数的15%,他们同样有需求，但只会购买公认好用的产品。</li></ol><p>这几类消费者中，非理性消费者最值得产品经理注意。发现产品的内在价值，比如产品经理可以深入了解他们的想法和感受，就能抓住这种情感需求。</p><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><ul><li>交互设计和视觉设计缺一不可。但大部分团队缺固执地认为只要招聘一位设计师，就能完成这两项工作。</li><li>视觉设计可以满足用户的情感需求。比如：协调的配色、优美的字体、漂亮的布局等</li></ul><h3 id="大众网络服务产品的要点"><a href="#大众网络服务产品的要点" class="headerlink" title="大众网络服务产品的要点"></a>大众网络服务产品的要点</h3><ol><li>可用性。大众网络服务产品必须具有良好的用户体验。比如，页面加载缓慢让用户无法忍受，也是糟糕的用户体验。</li><li>人物角色。用户一旦过多，就应该按典型特征将用户分类。比如，到时测试就可以邀请典型用户参与。</li><li>扩展性。建议开发资源和运维资源预留20% 专门为扩展做好准备。</li><li>持续可用性。比如网络中断，系统故障，在系统设计上最好有相关方案。</li><li>保护用户隐私。</li><li>口碑营销。向推荐产品的用户给予奖励。</li><li>全球化。产品设计之初需要考虑，避免之后开发增加开发成本。</li><li>平滑部署。 逐步过渡，尽量让用户适应缓慢，比如，用户版本可切换，模块逐步重构，等。</li><li>用户社区管理。多用类似“回馈用户”的活动表达对他们的重视。</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>书籍</category>
        <category>产品</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript精华-常用工具方法集合</title>
    <url>/archives/7f02b3bf.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录工作总常用的一些工具方法集合，也适用于vue项目中的utlils目录下的方法整理。为方便使用，这里已模块化方式书写。</p><a id="more"></a><h3 id="判断相关方法"><a href="#判断相关方法" class="headerlink" title="判断相关方法"></a>判断相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// judge-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断对象是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>obj &#123;Object&#125; 判断对象参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isEmptyObj = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(obj) === <span class="string">'&#123;&#125;'</span> || obj === <span class="literal">null</span> || obj === <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>arr &#123;Array&#125; 判断数组参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isEmptyArray = <span class="function"><span class="params">arr</span> =&gt;</span> !arr.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测空格、回车、换行、空白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isBlank = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/^\s*$/</span>;</span><br><span class="line">  <span class="keyword">return</span> reg.test(str)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是超链接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isHttps = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&amp;=]*)?/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.test(str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是合法的省份证号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isIdCardNo = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^([0-9])&#123;7,18&#125;(x|X)?$/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.test(str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是合法的手机号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isMobile = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^1\d&#123;10&#125;$/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.test(str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是合法的邮箱</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isEmail = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^(\w-*\.*)+@(\w-?)+(\.\w&#123;2,&#125;)+$/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.test(str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是合法的微信号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isWeChatNo = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.test(str);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="设备相关方法"><a href="#设备相关方法" class="headerlink" title="设备相关方法"></a>设备相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// device-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取设备机型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;stirng&#125;</span> </span>浏览器类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> browserType = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> userAgent = navigator.userAgent;</span><br><span class="line">    <span class="keyword">let</span> isOpera = userAgent.indexOf(<span class="string">"Opera"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> isIE = userAgent.indexOf(<span class="string">"compatible"</span>) &gt; <span class="number">-1</span></span><br><span class="line">        &amp;&amp; userAgent.indexOf(<span class="string">"MSIE"</span>) &gt; <span class="number">-1</span> &amp;&amp; !isOpera;</span><br><span class="line">    <span class="keyword">let</span> isEdge = userAgent.indexOf(<span class="string">"Edge"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> isFF = userAgent.indexOf(<span class="string">"Firefox"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> isSafari = userAgent.indexOf(<span class="string">"Safari"</span>) &gt; <span class="number">-1</span></span><br><span class="line">        &amp;&amp; userAgent.indexOf(<span class="string">"Chrome"</span>) == <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> isChrome = userAgent.indexOf(<span class="string">"Chrome"</span>) &gt; <span class="number">-1</span></span><br><span class="line">        &amp;&amp; userAgent.indexOf(<span class="string">"Safari"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isIE) &#123;</span><br><span class="line">        <span class="keyword">var</span> reIE = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"MSIE (\\d+\\.\\d+);"</span>);</span><br><span class="line">        reIE.test(userAgent);</span><br><span class="line">        <span class="keyword">var</span> fIEVersion = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>[<span class="string">"$1"</span>]);</span><br><span class="line">        <span class="keyword">if</span> (fIEVersion === <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IE7"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fIEVersion === <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IE8"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fIEVersion === <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IE9"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fIEVersion === <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IE10"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fIEVersion === <span class="number">11</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IE11"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"IE"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isOpera &amp;&amp; <span class="keyword">return</span> <span class="string">"Opera"</span>;</span><br><span class="line">    isEdge &amp;&amp; <span class="keyword">return</span> <span class="string">"Edge"</span>;</span><br><span class="line">    isFF &amp;&amp; <span class="keyword">return</span> <span class="string">"FF"</span>;</span><br><span class="line">    isSafari &amp;&amp; <span class="keyword">return</span> <span class="string">"Safari"</span>;</span><br><span class="line">    isChrome &amp;&amp; <span class="keyword">return</span> <span class="string">"Chrome"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否在IOS中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isIOS = <span class="regexp">/(iphone|ipad|ipod|ios)/i</span>.test(navigator.userAgent.toLowerCase());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否在Android中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isAndroid = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> u = navigator.userAgent;</span><br><span class="line">    <span class="keyword">return</span> (u.indexOf(<span class="string">"Android"</span>) &gt; <span class="number">-1</span>) || (u.indexOf(<span class="string">"Linux"</span>) &gt; <span class="number">-1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否在微信中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isWx = <span class="regexp">/micromessenger/</span>.test(<span class="built_in">window</span>.navigator.userAgent.toLowerCase());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否在微信小程序中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isWxMiniProgram = <span class="regexp">/miniprogram/</span>.test((<span class="built_in">window</span>.__wxjs_environment || navigator.userAgent).toLowerCase());</span><br></pre></td></tr></table></figure><h3 id="字符串相关方法"><a href="#字符串相关方法" class="headerlink" title="字符串相关方法"></a>字符串相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串去除所有html标签</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;string&#125; 需要处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeHtmlTag = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> reg = <span class="regexp">/&lt;\/?.+?\/?&gt;/g</span>;</span><br><span class="line">  <span class="keyword">return</span> str.replace(reg, <span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除字符前后空格</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 需要处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> clearSpace = <span class="function"><span class="params">str</span> =&gt;</span> str.replace(<span class="regexp">/(^\s*)|(\s*)$/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除所有空格</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>v &#123;String&#125; 需要处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>返回正确的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeAllSpace = <span class="function"><span class="params">v</span> =&gt;</span> v.replace(<span class="regexp">/\s+/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除所有超链接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>html &#123;String&#125; html字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>返回移除超链接之后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeAllHyperLink = <span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/&lt;a[^&gt;]*href=['"]([^"]*)['"].*?[^&gt;]*&gt;(.*?)&lt;\/a&gt;/gi</span>);</span><br><span class="line">  <span class="keyword">return</span> reg.test(html) ? html.replace(reg, <span class="string">''</span>) : html;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换文本中所有换行(\n)为&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 需要处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>替换之后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> replaceAllLineBreakWithBr = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/\\+n/g</span>);</span><br><span class="line">  <span class="keyword">return</span> reg.test(str) ? str.replace(reg, <span class="string">'&lt;br/&gt;'</span>) : str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除内容中 \n | \\n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 需要处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>清除之后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeAllLineBreak = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/\\+n/g</span>);</span><br><span class="line">  <span class="keyword">return</span> reg.test(str) ? str.replace(reg, <span class="string">''</span>) : str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去除字符串中&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 需要处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>去除之后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeBr = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/&lt;br\s*\\?\/?&gt;/gi</span>);</span><br><span class="line">  <span class="keyword">return</span> reg.test(str) ? str.replace(reg, <span class="string">''</span>) : str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析url参数，转换为参数对象模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>url &#123;String&#125; url地址 default: window.location.href</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example </span>?id=12345&amp;a=b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span> </span>转换之后的对象 &#123;id:12345, a:b&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> parseQueryString = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  url = !url ? <span class="built_in">window</span>.location.href : url;</span><br><span class="line">  <span class="keyword">if</span> (url.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> search = url[<span class="number">0</span>] === <span class="string">'?'</span> ? url.substr(<span class="number">1</span>) : url.substring(url.lastIndexOf(<span class="string">'?'</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (search === <span class="string">''</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  search = search.split(<span class="string">'&amp;'</span>);</span><br><span class="line">  <span class="keyword">let</span> query = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; search.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = search[i].split(<span class="string">'='</span>);</span><br><span class="line">    query[<span class="built_in">decodeURIComponent</span>(pair[<span class="number">0</span>])] = <span class="built_in">decodeURIComponent</span>(pair[<span class="number">1</span>] || <span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> query;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数值相关方法"><a href="#数值相关方法" class="headerlink" title="数值相关方法"></a>数值相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// number-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四舍五入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>number &#123;Number&#125; 处理的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>digit &#123;Number&#125; 需要保留的小数位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>12.34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getMathRound = <span class="function">(<span class="params">number = <span class="number">0</span>, digit = <span class="number">2</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> exponent = <span class="built_in">Math</span>.pow(<span class="number">10</span>, digit);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round(number * exponent) / exponent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取两个数之间的随机数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>min &#123;Number&#125; 范围最小值(包此值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>max &#123;Number&#125; 范围最大值(含此值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>随机数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example </span>(1,7) =&gt; 1/2/3/4/5/6/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> randomInt = <span class="function">(<span class="params">min, max</span>) =&gt;</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min) + min);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式化手机号为 3-4-4结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">v</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string|*&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> formatPhoneNum = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> _v = removeAllSpace(v);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isNaN</span>(_v)) &#123;</span><br><span class="line">    <span class="keyword">return</span> _v</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_v.length &gt;= <span class="number">3</span> &amp;&amp; _v.length &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> FIRST_PART = _v.substr(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">      <span class="keyword">const</span> SECOND_PART = _v.substr(<span class="number">3</span>);</span><br><span class="line">      v = FIRST_PART + <span class="string">' '</span> + SECOND_PART</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_v.length &gt; <span class="number">7</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> FIRST_PART = _v.substr(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">      <span class="keyword">const</span> SECOND_PART = _v.substr(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">const</span> THIRD_PART = _v.substr(<span class="number">7</span>);</span><br><span class="line">      v = FIRST_PART + <span class="string">' '</span> + SECOND_PART + <span class="string">' '</span> + THIRD_PART</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强制保留n位小数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>value &#123;String | Number&#125; 需要处理的数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>n &#123;Number&#125; 需要保留的小数位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> returnFloat = <span class="function">(<span class="params">value, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> v = <span class="built_in">Math</span>.round(<span class="built_in">parseFloat</span>(value) * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">let</span> xsd = v.toString().split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">if</span> (xsd.length === <span class="number">1</span>) &#123;</span><br><span class="line">    v = v.toString() + <span class="string">'.'</span> + <span class="string">'0'</span>.repeat(n);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (xsd.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xsd[<span class="number">1</span>].length &lt; n) &#123;</span><br><span class="line">      v = v.toString() + <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 金钱“，”格式处理，保留n位小数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>value &#123;String | Number&#125; 需要处理的数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>n &#123;Number&#125; 需要保留的小数位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>5,000.00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> formatMoney = <span class="function">(<span class="params">s, n</span>) =&gt;</span> &#123;</span><br><span class="line">  n = n &gt; <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">20</span> ? n : <span class="number">2</span>;</span><br><span class="line">  s = <span class="built_in">parseFloat</span>((s + <span class="string">''</span>).replace(<span class="regexp">/[^\d.-]/g</span>, <span class="string">''</span>)).toFixed(n) + <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> l = s.split(<span class="string">'.'</span>)[<span class="number">0</span>].split(<span class="string">''</span>).reverse()</span><br><span class="line">  <span class="keyword">let</span> r = s.split(<span class="string">'.'</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> t = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l.length; i++) &#123;</span><br><span class="line">    t += l[i] + ((i + <span class="number">1</span>) % <span class="number">3</span> === <span class="number">0</span> &amp;&amp; (i + <span class="number">1</span>) !== l.length ? <span class="string">','</span> : <span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) + <span class="string">'.'</span> + r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 百分比格式处理，保留n位小数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>value &#123;String | Number&#125; 需要处理的数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>n &#123;Number&#125; 需要保留的小数位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>20.00%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fPercent = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> number = (<span class="built_in">Number</span>(n) * <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;number&#125;</span>%`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组、对象相关方法"><a href="#数组、对象相关方法" class="headerlink" title="数组、对象相关方法"></a>数组、对象相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个数组合并一个对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>arr1 &#123;Array&#125; 被合并数组，在对象中以 键 存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>arr2 &#123;Array&#125; 被合并数组，在对象中以 值 存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span> </span>返回键值对的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrContactObject = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">    obj[arr1[i]] = arr2[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝，支持常见类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>values 复制之前的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;&#123;&#125;</span></span>|Array|Date|*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> deepClone = <span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> copy;</span><br><span class="line">  <span class="keyword">if</span> (values === <span class="literal">null</span> || <span class="keyword">typeof</span> values !== <span class="string">'object'</span>) <span class="keyword">return</span> values;</span><br><span class="line">  <span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    copy = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    copy.setTime(values.getTime());</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    copy = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = values.length; i &lt; len; i++) &#123;</span><br><span class="line">      copy[i] = deepClone(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">    copy = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> values) &#123;</span><br><span class="line">      <span class="keyword">if</span> (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Unable to copy values! Its type isn't supported."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="图片相关方法"><a href="#图片相关方法" class="headerlink" title="图片相关方法"></a>图片相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将html转化为图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>element &#123;Object&#125; 需要转化的dom</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>scale &#123;Number&#125; 放大倍数，默认2倍，原因为保持转化后图片的清晰度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>isSaveImg &#123;Boolean&#125; 是否保存图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>callback &#123;Function&#125; 转化后的成功回调，参数为图片的DOM,用于图片操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> generateCanvasImage = <span class="function">(<span class="params">element, scale = <span class="number">2</span>, isSaveImg = <span class="literal">false</span>, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> width = element.offsetwidth;</span><br><span class="line">  <span class="keyword">let</span> height = element.offsetheight;</span><br><span class="line">  <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">  <span class="keyword">const</span> SCALE = scale;</span><br><span class="line">  canvas.width = width * SCALE;</span><br><span class="line">  canvas.height = height * SCALE;</span><br><span class="line">  canvas.getContext(<span class="string">'2d'</span>).scale(scale, scale);</span><br><span class="line">  <span class="keyword">const</span> opts = &#123;</span><br><span class="line">    scale,</span><br><span class="line">    canvas,</span><br><span class="line">    width,</span><br><span class="line">    height,</span><br><span class="line">    useCORS: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">  html2canvas(element, opts).then(<span class="function"><span class="params">canvasObj</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = canvasObj.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    context.webkitImageSmoothingEnabled = <span class="literal">false</span>;</span><br><span class="line">    context.imageSmoothingEnabled = <span class="literal">false</span>;</span><br><span class="line">    isSaveImg &amp;&amp; Canvas2Image.saveAsPNG(canvasObj, canvasObj.width, canvasObj.height);</span><br><span class="line">    <span class="keyword">const</span> IMGDOM = Canvas2Image.convertToPNG(canvasObj, canvasObj.width, canvasObj.height);</span><br><span class="line">    callback &amp;&amp; callback(IMGDOM);</span><br><span class="line">    <span class="keyword">return</span> IMGDOM;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时间相关方法"><a href="#时间相关方法" class="headerlink" title="时间相关方法"></a>时间相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// date-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倒计时计算年，天，时，分，秒</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>targetTime &#123;Number/String&#125; 目标时间（将来的设定时间）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>startTime &#123;Number/String&#125; 开始时间（一般为现在时间）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;&#123;years: *, days: *, hours: *, minutes: *, seconds: *&#125;</span></span>&#125; 返回对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> returnLeftTime = <span class="function">(<span class="params">targetTime, startTime</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkTime</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      i = <span class="string">'0'</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> currTime = startTime || <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">let</span> leftTime = <span class="built_in">Number</span>(targetTime) - <span class="built_in">Number</span>(currTime);</span><br><span class="line">  <span class="keyword">if</span> (leftTime &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> years = <span class="built_in">parseInt</span>(leftTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span> / <span class="number">365</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> days = <span class="built_in">parseInt</span>(leftTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> hours = <span class="built_in">parseInt</span>(leftTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> % <span class="number">24</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> minutes = <span class="built_in">parseInt</span>(leftTime / <span class="number">1000</span> / <span class="number">60</span> % <span class="number">60</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> seconds = <span class="built_in">parseInt</span>(leftTime / <span class="number">1000</span> % <span class="number">60</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      years: checkTime(years),</span><br><span class="line">      days: checkTime(days),</span><br><span class="line">      hours: checkTime(hours),</span><br><span class="line">      minutes: checkTime(minutes),</span><br><span class="line">      seconds: checkTime(seconds)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前日期的N个月/天前后的日期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>months &#123;number&#125; N月，+N 表示N月之后; -N 表示N月之前</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>days &#123;number&#125; N日， +N 表示N天之后; -N 表示N天之前</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>isZero &#123;boolean&#125; 是否需要补零 true(默认) 需要;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>joinSign &#123;string&#125; 日期连接符号 ‘-’(默认)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>输出需求格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getFewMonthAgoOrAfterDate = <span class="function">(<span class="params">months = <span class="number">0</span>, days = <span class="number">0</span>, isZero = <span class="literal">true</span>, joinSign = <span class="string">'-'</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  dt.setMonth(dt.getMonth() + months, dt.getDate() + days);</span><br><span class="line">  <span class="keyword">let</span> Year = dt.getFullYear();</span><br><span class="line">  <span class="keyword">let</span> Month = dt.getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> Day = dt.getDate();</span><br><span class="line">  <span class="keyword">if</span> (isZero) &#123;</span><br><span class="line">    Month = Month &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + Month) : Month;</span><br><span class="line">    Day = Day &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + Day) : Day;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;Year&#125;</span><span class="subst">$&#123;joinSign&#125;</span><span class="subst">$&#123;Month&#125;</span><span class="subst">$&#123;joinSign&#125;</span><span class="subst">$&#123;Day&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否为闰年</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>输出需求格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isLeapYear = <span class="function">(<span class="params">year</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化相关方法"><a href="#优化相关方法" class="headerlink" title="优化相关方法"></a>优化相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// optimize-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay &#123;number&#125; 等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn &#123;Function&#125; 需执行函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">delay, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn(...args);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay &#123;number&#125; 计划好的执行间隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn &#123;Function&#125; 需执行函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params">delay, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastCall = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> NOW = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</span><br><span class="line">        <span class="keyword">if</span>(NOW - lastCall &lt; delay) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastCall = NOW;</span><br><span class="line">        <span class="keyword">return</span> fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>精华</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>工具</tag>
        <tag>精华</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-模块化</title>
    <url>/archives/b92372a3.html</url>
    <content><![CDATA[<!-- build time:Mon May 25 2020 10:27:44 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript模块化的几个重要发展阶段，无模块化，CommonJS，AMD规范，CMD规范，ES6模块化。</p><a id="more"></a><p>随着前端 <code>JavaScript</code> 代码复杂度的提高，<code>JavaScript</code> 模块化这个概念被提出来，前端社区也不断地实现前端模块化。下面介绍 <code>JavaScript</code> 模块化及其是如何一步一步地发展起来的。</p><h3 id="无模块化"><a href="#无模块化" class="headerlink" title="无模块化"></a>无模块化</h3><p><code>JavaScript</code> 最初的作用仅仅是验证表单，后来会添加一些动画，但是这些 <code>JavaScript</code> 代码很多在一个文件中就可以完成了，所以，我们只需在 <code>html</code> 文件中添加一个 <code>script</code> 标签。</p><p>后来，随着前端复杂度的提高，为了能够提高项目的可读性、可扩展性等，我们的 <code>JavaScript</code> 文件逐渐多了起来，不再是一个 <code>js</code> 文件就可以解决的了，而是把每一个 <code>js</code> 文件当做一个模块。那么，这是的 <code>js</code> 引入方式是怎么样的呢？大概是下面这样：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"other1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"other2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>即简单地将所有的 <code>js</code> 文件统统放在一起。但是这些文件的顺序不能出错，比如，<code>jquery</code> 需要先引入，才能引入 <code>jquery</code> 插件，才能在其他的文件中使用 <code>jquery</code>。</p><p><strong>优点：</strong></p><ul><li>相比于使用一个 <code>js</code> 文件，这种多个 <code>js</code> 文件实现最简单的模块化的思想是进步的</li></ul><p><strong>缺点：</strong></p><ul><li><strong>污染全局作用域。</strong>因为每一个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突。当然，我们也可以使用命名空间的方式来解决。</li><li><strong>依赖关系不明显，不利于维护。</strong>比如，<code>jquery</code> 的某个插件就依赖于 <code>jquery</code>，如果忘记引用 <code>jquery</code> 了，那么就会报错。</li></ul><h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><p>IIFE就是自执行函数，这种方式是其实是对 <code>js</code> 单独文件的优化方式。</p><p><strong>优点：</strong>在一个单独的函数作用域中执行代码，<strong>避免变量冲突</strong>。</p><p><strong>缺点：</strong> <strong>依赖关系不明显，不利于维护。</strong>比如，<code>jquery</code> 的某个插件就依赖于 <code>jquery</code>，如果忘记引用 <code>jquery</code> 了，那么就会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		data: []</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><p><code>CommonJS</code> 就是一个 <code>JavaScript</code> 模块化的规范，该规范最初是用在服务端的 <code>node</code> 中，前端的 <code>webpack</code> 也是对 <code>CommonJS</code>原生支持的。根据这个规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。</p><p><code>CommonJS</code> 的核心思想就是通过 <code>require</code> 方法来同步加载所需要依赖的其他模块，然后通过 <code>exports</code> 或者 <code>module.exports</code> 来导出需要暴露的接口。如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> addX = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><p>这里的 <code>a.js</code> 就是一个 <code>CommonJS</code> 规范的模块了。这里的 <code>module</code> 就代表了这个模块，<code>module</code> 的 <code>exports</code> 属性就是对外暴露的接口，可以对外导出外部可以访问的变量，比如这里的 <code>x</code> 和 <code>addX</code>。</p><p><code>exports</code> 是对 <code>module.exports</code> 的引用。比如，我们可以认为在一个模块的顶部有这句代码：<code>exports = module.exports</code>，所以，我们不能直接给 <code>exports</code> 赋值，比如 <code>number</code>、<code>function</code> 等。</p><p>然后我们就可以在其他模块中引入这个模块使用了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">"./a.js"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// =&gt; 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a.addX(<span class="number">2</span>)); <span class="comment">// =&gt; 7</span></span><br></pre></td></tr></table></figure><p>这里的 <code>require</code> 就会获取到 <code>a.js</code> 所暴露的 <code>module.exports</code> 变量，然后就可以使用暴露的 <code>x</code> 和 <code>addX</code> 了。</p><div class="note warning no-icon"><p><code>module.exports</code> 才是真正的接口，<code>exports</code> 只不过是它的一个辅助工具。最终返回给调用的是 <code>module.exports</code> 而不是 <code>exports</code>。所有的 <code>exports</code> 收集到的属性和方法，都赋值给了 <code>module.exports</code>。当然，这有个前提，就是 <code>module.exports</code> 本身不具备任何属性和方法。<code>module.exports</code> 已经具备一些属性和方法，那么 <code>exprots</code> 收集来的信息将被忽略。使用最好遵循这两点：</p><ol><li>最好别分别定义 <code>module.exports</code> 和 <code>exports</code></li><li>NodeJS开发者建议导出对象用 <code>module.exports</code>，导出多个方法和变量用 <code>exports</code></li></ol></div><p><strong>优点：</strong></p><ul><li><code>CommonJs</code> 规范在服务端率先完成了 <code>JavaScript</code> 的模块化，解决了依赖、全局变量污染的问题，这也是 <code>js</code> 运行在服务端的必要条件</li></ul><p><strong>缺点：</strong></p><ul><li>由于 <code>CommonJS</code> 是同步加载模块的，在服务端文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务端请求过来，那么同步加载就不适用了，所以， <code>CommonJS</code> 是不合适用于浏览器端的。</li></ul><h3 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h3><p><code>CommonJs</code> 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 <code>AMD</code> 规范是非同步加载模块，允许指定回调函数。由于 <code>Node.js</code> 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 <code>CommonJS</code> 规范比较适用。但是，浏览器环境，要从服务端加载模块，这时就必须采用非同步模式，因此浏览器一般采用 <code>AMD</code> 规范。而 <code>AMD</code> 规范的实现，就是大名鼎鼎的 <code>require.js</code>了。</p><p><code>AMD</code> 标准中，定义了下面两个API:</p><ol><li><code>require([module], callback)</code></li><li><code>define(id, [module], callback)</code></li></ol><p>即通过 <code>define</code> 来定义一个模块，然后使用 <code>require</code> 来加载一个模块。并且，<code>require</code> 还支持 <code>CommonJS</code> 的模块导出方式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义模块</span></span><br><span class="line">define(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> alertName = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">        alert(<span class="string">`I am <span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123; alertName &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'alert'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">alert</span>) </span>&#123;</span><br><span class="line">    alert.alertName(<span class="string">"zi jun"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>适合在浏览器环境中异步加载模块，可以并行加载多个模块</li></ul><p><strong>缺点：</strong></p><ul><li>提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖</li></ul><h3 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h3><p><code>CMD</code> 规范是阿里的玉伯提出来的，实现 <code>js</code> 库为 <code>sea.js</code>。它和 <code>require.js</code> 非常类似，即一个 <code>js</code> 文件就是一个模块，但是 <code>CMD</code> 的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">    exports.doSomething = <span class="string">"//"</span>;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="string">"//"</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>同样实现了浏览器端的模块化加载</li><li>可以按需加载，依赖就近</li></ul><p><strong>缺点：</strong></p><ul><li>依赖 <code>SPM</code> 打包，模块的加载逻辑偏重</li></ul><div class="note warning no-icon"><p><code>AMD</code> 和 <code>CMD</code> 的区别：前者对于依赖的模块提前执行，而后者是延迟执行。前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块时再 <code>require</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AMD</span></span><br><span class="line"><span class="comment">// 依赖必须一开始就前置</span></span><br><span class="line">define([<span class="string">"./a"</span>, <span class="string">"./b"</span>], (a, b) =&gt; &#123;</span><br><span class="line">    a.doSomething();</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CMD</span></span><br><span class="line"><span class="comment">// 依赖按需加载，就近原则</span></span><br><span class="line">define(<span class="function">(<span class="params"><span class="built_in">require</span>, exports, <span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>);</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">require</span>(<span class="string">"./b"</span>);</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><h3 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h3><p>之前的几种模块方案都是前端社区自己实现的，只是得到了大家的认可和广泛使用，而ES6的模块化方案才是真正的规范。在ES6中，我们可以使用 <code>import</code> 关键字引入模块，通过 <code>export</code> 关键字导出模块，功能较之前几种方案更为强大，也是我们所推崇的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; square, diag &#125; <span class="keyword">from</span> <span class="string">"./utils"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">2</span>)); <span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="built_in">console</span>.log(diag(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure><h4 id="基本规则或特点"><a href="#基本规则或特点" class="headerlink" title="基本规则或特点"></a>基本规则或特点</h4><ul><li>每个模块只加载一次，每一个 <code>js</code> 只执行一次，如果下次再去加载同目录下的同文件，直接从内存中读取。一个模块就是一个单例，或者说就是一个对象。</li><li>每一个模块内声明的变量都是局部变量，不会污染全局作用域。</li><li>模块内部的变量或者函数可以通过 <code>export</code> 导出。</li><li>一个模块可以导入别的模块。</li></ul><h4 id="import和export导出方式"><a href="#import和export导出方式" class="headerlink" title="import和export导出方式"></a>import和export导出方式</h4><h5 id="综合导出变量"><a href="#综合导出变量" class="headerlink" title="综合导出变量"></a>综合导出变量</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"zi jun"</span>;</span><br><span class="line"><span class="keyword">let</span> sayName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello, zi jun"</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;name, sayName&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, sayName &#125; <span class="keyword">from</span> <span class="string">"./lib"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// =&gt; "zi jun";</span></span><br><span class="line"><span class="built_in">console</span>.log(sayName); <span class="comment">// =&gt; "hello, zi jun"</span></span><br></pre></td></tr></table></figure><h5 id="导出时修改名称"><a href="#导出时修改名称" class="headerlink" title="导出时修改名称"></a>导出时修改名称</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"zi jun"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;name <span class="keyword">as</span> myName&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName &#125; <span class="keyword">from</span> <span class="string">"./lib"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myName); <span class="comment">// =&gt; "zi jun"</span></span><br></pre></td></tr></table></figure><h5 id="直接导出"><a href="#直接导出" class="headerlink" title="直接导出"></a>直接导出</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">"zi jun"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">"./lib"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// =&gt; "zi jun"</span></span><br></pre></td></tr></table></figure><h5 id="匿名导出"><a href="#匿名导出" class="headerlink" title="匿名导出"></a>匿名导出</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">"zi jun"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> info <span class="keyword">from</span> <span class="string">"./lib"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(info.name); <span class="comment">// =&gt; "zi jun"</span></span><br></pre></td></tr></table></figure><h5 id="通配符导出"><a href="#通配符导出" class="headerlink" title="通配符导出"></a>通配符导出</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// other.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">"zi jun"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> myName <span class="keyword">from</span> <span class="string">"./other"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> myName <span class="keyword">from</span> <span class="string">"./lib"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myName.name); <span class="comment">// =&gt; "zi jun"</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
</search>
