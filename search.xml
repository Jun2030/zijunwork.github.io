<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docsify</title>
    <url>/archives/2eeac462.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录Docsify的基本使用。</p><a id="more"></a><h2 id="官方及文档"><a href="#官方及文档" class="headerlink" title="官方及文档"></a>官方及文档</h2><ul><li>官方地址：<a href="https://docsify.js.org/#/" target="_blank" rel="noopener external nofollow noreferrer">https://docsify.js.org/#/</a></li><li>推荐教程：<a href="https://segmentfault.com/a/1190000017576714" target="_blank" rel="noopener external nofollow noreferrer">https://segmentfault.com/a/1190000017576714</a></li></ul><h2 id="Dosify特性"><a href="#Dosify特性" class="headerlink" title="Dosify特性"></a>Dosify特性</h2><ul><li>无需构建，写完文档直接发布</li><li>容易使用并且轻量（~19kb gzipped）</li><li>智能的全文搜索</li><li>提供多套主题</li><li>丰富的 API</li><li>支持 Emoji</li><li>兼容 IE10+</li><li>支持 PWA</li><li>支持 SSR</li></ul><h2 id="Docsify-本地运行"><a href="#Docsify-本地运行" class="headerlink" title="Docsify 本地运行"></a>Docsify 本地运行</h2><p>使用 <code>docsify-cli</code> 来进行本地开发。具体步骤如下：</p><ol><li><code>npm i docsify-cli -g</code> , 全局安装 doscify 脚手架工具</li><li><code>mkdir weblog</code> , 寻找本地磁盘，新建项目目录</li><li><code>cd weblog</code> , 进入项目目录文件中</li><li><code>docsify init ./docs</code> , 初始化一个项目，会生成一些文件</li><li><code>docsify serve ./</code> ， 本地启动服务，即可及时刷新预览</li></ol><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><ol><li>编辑 <code>index.html</code> 中 <code>window.$docsify</code> 的 <code>coverpage</code> 参数，和创建 <code>_coverpage.md</code> 文件即可展示封面。</li><li>替换 <code>index.html</code> 中 的 <code>css</code> 样式，即可改变主题。</li><li>编辑 <code>index.html</code> 中 <code>window.$docsify</code> 的 <code>loadSidebar</code> 参数，和创建 <code>_sizebar.md</code> 文件即可自定义菜单栏。</li><li>github设置中，开启 <code>GitHub Pages</code> 功能并选择 <code>master branch / docs folder</code> 选项。</li></ol><h2 id="特殊的渲染语法"><a href="#特殊的渲染语法" class="headerlink" title="特殊的渲染语法"></a>特殊的渲染语法</h2><ol><li><p><code>!&gt; Time is money!</code>: 重要内容</p></li><li><p><code>?&gt; You are my friend</code>: 普通提示</p></li><li><p><code>[link](/demo &#39;:target=_blank&#39;)</code>: 设置超链接的打开方式（<code>_black/_self</code>）</p></li><li><p><code>[link](/demo &#39;:disaled&#39;)</code>: 超链接禁止点击</p></li><li><p><code>![image](url &#39;:size=50%&#39;)</code>: 图片显示大小（<code>&#39;:size=50x100&#39;/&#39;:size=100&#39;/&#39;:size=20%&#39;</code>）</p></li><li><p>隐藏/展开详情</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">summary</span>&gt;</span></span>展示文章<span class="xml"><span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span></span><br><span class="line">这是隐藏的内容    </span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>文档</category>
        <category>Docsify</category>
      </categories>
      <tags>
        <tag>Docsify</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo特色语法</title>
    <url>/archives/5d6bbf47.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>这是一篇关于hexo一些进阶写法的样式文章。</p><a id="more"></a><h3 id="文本居中引用"><a href="#文本居中引用" class="headerlink" title="文本居中引用"></a>文本居中引用</h3><blockquote class="blockquote-center"><p>预测未来的最好方式是创造未来</p></blockquote><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="普通-markdown-写法"><a href="#普通-markdown-写法" class="headerlink" title="普通 markdown 写法"></a>普通 markdown 写法</h4><blockquote><p>I’am Devin.</p><p>I like coding.</p></blockquote><h4 id="hexo-写法"><a href="#hexo-写法" class="headerlink" title="hexo 写法"></a>hexo 写法</h4><blockquote><p>I’am Devin. I like coding.</p></blockquote><h4 id="hexo-作者引用"><a href="#hexo-作者引用" class="headerlink" title="hexo 作者引用"></a>hexo 作者引用</h4><blockquote><p>I’am Devin. I like coding.</p><footer><strong>—Devin</strong></footer></blockquote><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><div class="note default"><p>default 提示块标签</p></div><div class="note primary"><p>primary 提示块标签</p></div><div class="note success"><p>success 提示块标签</p></div><div class="note info"><p>info 提示块标签</p></div><div class="note warning"><p>warning 提示块标签</p></div><div class="note danger"><p>danger 提示块标签</p></div><h4 id="不携带icon"><a href="#不携带icon" class="headerlink" title="不携带icon"></a>不携带icon</h4><div class="note warning no-icon"><p>warning 提示块标签</p></div><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><span class="label default">默认</span> <span class="label primary">主要</span> <span class="label success">成功</span> <span class="label info">信息</span> <span class="label warning">警告</span> <span class="label danger">危险</span> <span class="label success">这是成功的信息</span><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><a class="btn" href="https://20202030.cc/"><i class="fa fa-link fa-fw"></i>链接 </a><a class="btn" href="https://20202030.cc/" title="这是子俊的私人领域"><i class="fa fa-home fa-fw"></i>首页 </a><a class="btn" href="https://20202030.cc/" title="豆瓣电影"><i class="fa fa-film fa-fw"></i>观影 </a><a class="btn" href="https://20202030.cc/" title="豆瓣读书"><i class="fa fa-book fa-fw"></i>阅读</a><h3 id="选项卡"><a href="#选项卡" class="headerlink" title="选项卡"></a>选项卡</h3><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">A</a></li><li class="tab"><a href="#tab-2">B</a></li><li class="tab"><a href="#tab-3">C</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><p><strong>选项卡 A</strong></p></div><div class="tab-pane" id="tab-2"><p><strong>选项卡 B</strong></p></div><div class="tab-pane" id="tab-3"><p><strong>选项卡 C</strong> 名字为C</p></div></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>文档</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo踩坑</title>
    <url>/archives/7c55949b.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>主要记录hexo使用过程中的一些Bug，Hexo的踩坑之路。</p><a id="more"></a><h3 id="本地预览ok，部署有问题"><a href="#本地预览ok，部署有问题" class="headerlink" title="本地预览ok，部署有问题"></a>本地预览ok，部署有问题</h3><ul><li><p>Bug描述：</p><p>部署生产，标签文章打开出现 404，但是，本地预览 无此问题。</p></li></ul><ul><li><p>Bug解决：</p><p>出现的问题的原因是：git中设置了大小写不敏感。所以，可以修改 git 设置不忽略大小写。进入项目文件夹，进入 <code>git</code> 目录：<code>.deploy_git</code> , 修改 <code>.git</code> 文件中的配置文件 <code>config</code> , 修改 <code>ignorecase</code> 属性：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignorecase = <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="404页面错误"><a href="#404页面错误" class="headerlink" title="404页面错误"></a>404页面错误</h3><ul><li><p>Bug描述：</p><p>生产环境，404显示不正确，渲染成了post页面，而不是需要的页面。</p></li><li><p>Bug解决：</p><p>在 <code>source</code> 目录下新建 <code>404.html</code> 文件，写入以下代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>404<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">homePageUrl</span>=<span class="string">"/"</span> <span class="attr">homePageName</span>=<span class="string">"返回"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在主题配置文件中修改 <code>menu</code> 属性：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">commonweal:</span> <span class="string">/404</span> <span class="string">||</span> <span class="string">heartbeat</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h3><p>没必要修改 站点的 <code>_config.yml</code> 配置文件的 <code>post_asset_folder</code> 属性，因为一旦设为 <code>true</code>，那么在 <code>hexo new post</code> 新文章时同时会创建标题目录</p><p>Bug描述：</p><ul><li>Typora 显示图片，但是开发中不显示</li></ul><p>Bug解决：</p><ol><li><p>点击 <code>win</code> 键搜索 <code>cmd</code>，右键以管理员身份运行 <code>cmd.exe</code>（避免后的的 <code>mklink</code> 操作无权限）</p></li><li><p><code>cd e:\ban-jing\source\_posts</code> 打开文章目录</p></li><li><p><code>mklink /d assets e:\ban-jing\source\assets</code> 建立符号链接，成功后会有提示</p></li><li><p>修改Typora图片设置</p><p><img data-src="../../assets/20200528193119.png" alt=""></p></li><li><p>拖动图片即可自动复制 <code>assets</code> 目录</p></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>文档</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题整理(一)</title>
    <url>/archives/d7ca445d.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本次主要记录整理-<code>JavaScript</code>：意外全局变量、数组的length属性、鹰眼测试、自动分号插入、闭包、浮点数计算、变量提升这几个问题。</p><p>原链接名：《JS-7个简单但棘手的JavaScript面试问题》</p><a id="more"></a><h3 id="意外全局变量"><a href="#意外全局变量" class="headerlink" title="意外全局变量"></a>意外全局变量</h3><p><strong>问题</strong></p><p>以下代码段中用于运算 <code>typeof a</code> 和 <code>typeof b</code> 的内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = b = <span class="number">0</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="keyword">typeof</span> a;</span><br><span class="line"><span class="keyword">typeof</span> b;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>undefined number<br>这里需要注意的是: <code>let a = b = 0;</code> 和 <code>let a = 0, b = 0;</code> 的区别。<br><ul><li><code>let a = b = 0;</code> 相当于 <code>b = 0;</code> <code>let a = b;</code>。注意, <code>b = 0</code> 的前面是没有 <code>let</code> 声明的,所以这句代码就相当于 <code>window.b = 0;</code>,所以, <code>b</code> 就是一个全局变量。以上代码在浏览器中执行的详情如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="built_in">window</span>.b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">window</span>.b;</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>let a = 0, b = 0;</code> 相当于 <code>let a = 0; let b = 0;</code>。</li></ul></details><h3 id="数组的length属性"><a href="#数组的length属性" class="headerlink" title="数组的length属性"></a>数组的length属性</h3><p><strong>问题</strong></p><p>以下代码中<code>clothes[0]</code> 的值是什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clothes = [<span class="string">'jacket'</span>, <span class="string">'t-shirt'</span>];</span><br><span class="line">clothes.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(clothes[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><details><summary>答案</summary>undefined<br>数组对象的 `length` 属性具有特殊的行为：减少length属性的值就是删除自己的数组元素。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">clothes.length = <span class="number">0</span>; <span class="comment">// &lt;=&gt; clothes = [];</span></span><br></pre></td></tr></table></figure></details><h3 id="鹰眼测试"><a href="#鹰眼测试" class="headerlink" title="鹰眼测试"></a>鹰眼测试</h3><p><strong>问题</strong></p><p><code>numbers</code> 数组的内容是什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> length = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> numbers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++); &#123;</span><br><span class="line">    numbers.push(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(numbers);</span><br></pre></td></tr></table></figure><details><summary>答案</summary>5<br>注意分号的位置！以上代码等效于：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> length = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> numbers = [];</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  <span class="comment">// do nothing                    </span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  numbers.push(i + <span class="number">1</span>);                      </span><br><span class="line">&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(numbers);</span><br></pre></td></tr></table></figure></details><h3 id="自动分号插入"><a href="#自动分号插入" class="headerlink" title="自动分号插入"></a>自动分号插入</h3><p><strong>问题</strong></p><p><code>arrayfromValue()</code> 返回什么值？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayFromValue</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  [item];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arrayFromValue[<span class="number">10</span>]);</span><br></pre></td></tr></table></figure><details><summary>答案</summary>undefined<br>注意 <code>return</code> 和 <code>[item]</code> 表达式之间的换行符。此换行符会使JavaScript自动在 <code>return</code> 和 <code>[item]</code> 表达式之间插入分号。以下是等效代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayFromValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  [item];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="经典为题：棘手的闭包"><a href="#经典为题：棘手的闭包" class="headerlink" title="经典为题：棘手的闭包"></a>经典为题：棘手的闭包</h3><p><strong>问题</strong></p><p>以下代码将输出什么到控制台？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">  setTimeout(log, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>3 3 3<br><code>log()</code>是一个捕获变量 <code>i</code>的闭包，此变量在 <code>for()</code> 循环的外部范围中定义。执行此代码有两个阶段。<br>Phase 1:<br>1. <code>for()</code> 重复3次，在每次迭代过程中，都会创建一个新的函数 <code>log()</code> 来捕获变量 <code>i</code>。然后， <code>setTimeout()</code> 计划执行 <code>log()</code>。<br>2. 当 <code>for()</code> 循环完成时，<code>i</code> 变量的值为3。<br>Phase 2:<br>1. 第二阶段发生在100ms之后， <code>setTimeout()</code> 调用了3次计划的 <code>log()</code>。<code>log()</code> 读取变量 <code>i</code>的当前值为3，并记录到控制台。</details><h3 id="浮点数计算"><a href="#浮点数计算" class="headerlink" title="浮点数计算"></a>浮点数计算</h3><p><strong>问题</strong></p><p>这个等式的结果是什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>);</span><br></pre></td></tr></table></figure><details><summary>答案</summary>false<br>由于以二进制方式对浮点数进行编码，因此像浮点数相加之类的操作会产生舍入误差。简而言之，直接比较浮点数并不精确。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span>; <span class="comment">// -&gt; 0.30000000000000004</span></span><br></pre></td></tr></table></figure></details><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><strong>问题</strong></p><p>如果在声明前访问 <code>myVar</code> 和 <code>myConst</code>，会发生什么情况？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(myVar);</span><br><span class="line"><span class="built_in">console</span>.log(myConst);</span><br><span class="line"><span class="keyword">var</span> myVar = <span class="string">"value"</span>;</span><br><span class="line"><span class="keyword">const</span> myConst = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>undefined error<br><code>var</code>具有变量提升的属性，所以，在<code>var</code> 声明变量，变量开始初始化为 <code>undefined</code>。</details><!-- rebuild by neat -->]]></content>
      <categories>
        <category>面试</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题整理(三)</title>
    <url>/archives/fb83a9e4.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录一些进阶型的面试问题：<code>Promise/Async/Await</code>执行顺序、定时器的执行顺序或机制、<code>[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)</code>、<code>Doctype</code> 作用、<code>fetch</code> 发送 2 次请求的原因这几个问题。</p><p>原链接名：《30道经典面试题》</p><a id="more"></a><h3 id="setTimeout、Promise、Async-Await-的区别"><a href="#setTimeout、Promise、Async-Await-的区别" class="headerlink" title="setTimeout、Promise、Async/Await 的区别"></a>setTimeout、Promise、Async/Await 的区别</h3><ul><li><code>setTimeout</code>：定时器，可以延迟执行，属于宏任务，在 <code>JavaScript</code> 事件循环中，执行优先度最低。</li><li><code>Promise</code>：微任务，本身是同步的立即执行函数，当在执行 <code>resolve</code> 或者 <code>reject</code> 的时候，此时是异步操作，会先执行 <code>then/catch</code> 等，当主栈完成后，才回去调用 <code>resolve/reject</code> 中存放的方法执行。</li><li><code>async/await</code>：微任务，<code>async</code> 函数返回一个 <code>Promise</code> 对象，当函数执行的时候，一旦遇到 <code>await</code> 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。</li><li>执行任务优先级： <code>Promise</code> &gt; <code>await</code> &gt; <code>setTimeout</code></li></ul><div class="note warning"><p>更多的执行顺序，事件循环等详细，可查看 <a href="/archives/6f36c6d1.html">链接</a></p></div><h3 id="定时器的执行顺序或机制"><a href="#定时器的执行顺序或机制" class="headerlink" title="定时器的执行顺序或机制"></a>定时器的执行顺序或机制</h3><p>因为 <code>JS</code> 是单线程的，浏览器遇到 <code>setTimeout</code> 或者 <code>setInterval</code> 会先执行完当前的代码块（主(宏)任务），在此之前会把定时器（宏任务）推入浏览器的待执行事件队列里，等到浏览器执行完当前代码（主任务和微任务）之后，会看下事件队列里有没有宏任务，有的话才执行定时器代码。</p><div class="note warning"><p>即使把定时器的时间设置为0，还是会先执行主任务，把宏任务推入事件队列中。</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> testSet = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"setInterval"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            clearInterval(testSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">var</span> testSet1 = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// setInterval</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure><h3 id="‘1’-’2’-’3’-map-parseInt-输出"><a href="#‘1’-’2’-’3’-map-parseInt-输出" class="headerlink" title="[‘1’,’2’,’3’].map(parseInt) 输出"></a>[‘1’,’2’,’3’].map(parseInt) 输出</h3><p>本题主要考察 <code>map()</code> 函数的参数，和 <code>parseInt()</code> 方法的参数。</p><p><strong>答案</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [1, NaN, NaN]</span></span><br></pre></td></tr></table></figure><p>数组的 <code>map()</code> 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><p><strong><code>map()</code>特性</strong></p><ul><li><code>map()</code> 方法按照原始数组元素顺序依次处理元素</li><li><code>map()</code> 方法不会对数组进行检测</li><li><code>map()</code> 方法不会改变原始数组</li></ul><p><strong><code>map()</code>语法</strong></p><p><code>array.map(function(currentValue, index, arr), thisValue)</code></p><ul><li><code>function(currentValue, index, arr)</code> 必须，函数。数组中的每个元素都会执行这个函数<ul><li><code>currentValue</code> 必须，当前元素的值</li><li><code>index</code> 可选，当前元素的索引值</li><li><code>arr</code> 可选，当前元素属于的数组对象</li></ul></li><li><code>thisValue</code> 可选。对象作为改执行回调时使用，传递给函数，用作 <code>this</code> 的值，如果省略，或者传入 <code>null</code>, <code>undefined</code>，那么回调函数的 <code>this</code> 为全局对象</li></ul><p>字符串方法 <code>parseInt()</code> 可解析一个字符串，返回一个整数。</p><p><strong><code>parseInt()</code>特性</strong></p><ul><li><code>parseInt()</code> 方法返回字符串中以第一个数字开始的连续数值字符</li><li><code>parseInt()</code> 方法开头和结尾的空格是允许的</li><li><code>parseInt()</code> 方法如果第一个非空字符不能转换为数字，那么返回 <code>NaN</code></li></ul><p><strong><code>pareseInt()</code>语法</strong></p><p><code>parseInt(string, radix)</code></p><ul><li><code>string</code> 必须，要被解析的字符串</li><li><code>radix</code> 可选，表示要解析的数字的基数（进制数），该值介于 <code>2~36</code> 之间<ul><li>如果省略该参数，或其值为0，则数字将以 10 为基数来解析</li><li>如果以 <code>0x</code>或 <code>0X</code> 开头，则数字将以 16 为基数来解析</li><li>如果该参数 小于 2 或者 大于 36，则 <code>parseInt()</code> 将返回 <code>NaN</code></li></ul></li></ul><p><strong>具体执行步骤：</strong></p><ol><li><code>parseInt(1, 0)</code>，基数参数的值为0，那么数字将以10进制解析，返回1</li><li><code>parseInt(2, 1)</code>，基数参数的值小于2，无法解析，返回 <code>NaN</code></li><li><code>parseInt(3, 2)</code>，基于参数表示2进制解析，但是3不在二进制（<code>0/1</code>）中，无法解析，返回 <code>NaN</code></li></ol><h3 id="Doctype-作用"><a href="#Doctype-作用" class="headerlink" title="Doctype 作用"></a>Doctype 作用</h3><p><code>Doctype</code> 声明文档的解析类型，避免浏览器的怪异模式，让浏览器渲染结果保持一致性。</p><ul><li>怪异模式： 浏览器使用自己的怪异模式来解析渲染页面（默认）</li><li>标准模式：浏览器使用W3C标准来解析渲染页面</li></ul><p><strong>特性</strong></p><ul><li>页面如果doctype声明，那么默认的渲染方式为浏览器自己的怪异模式</li><li><code>html5</code> 中使用 <code>&lt;!doctype html&gt;</code> 来声明文档解析类型</li><li>doctype声明不区分大小写</li></ul><h3 id="fetch-发送-2-次请求的原因"><a href="#fetch-发送-2-次请求的原因" class="headerlink" title="fetch 发送 2 次请求的原因"></a>fetch 发送 2 次请求的原因</h3><p>fetch 发送 post 请求的时候，总是发送2次，第一次状态码是 <code>204</code>，第二次才是真正的请求。原因为：</p><p>fetch的实现机制导致的结果。当发生跨域请求时，第一次发送一个 Options 请求，询问服务器是否允许接受请求，如果服务器支持，则在第二次中发送真正的请求（第二次自动发送）。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>面试</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP-各版本区别</title>
    <url>/archives/63110c3b.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录HTTP1.0、HTTP1.1、HTTP2.0的区别。</p><a id="more"></a><h3 id="HTTP的基本优化"><a href="#HTTP的基本优化" class="headerlink" title="HTTP的基本优化"></a>HTTP的基本优化</h3><p>影响一个HTTP网络请求的因素主要有两个：带宽和延迟</p><ul><li><strong>带宽</strong>：现在网络基础建设已经使得带宽得到极大的提升，不再担心带宽影响网速</li><li><strong>延迟</strong>：<ul><li><strong>浏览器阻塞</strong>。浏览器因为一些原因阻塞请求。浏览器对于同一域名，同时只能有4个连接（不同浏览器内核可能有差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li><strong>DNS查询</strong>。浏览器需要指定目标服务器的IP才能建立连接。将域名解析为IP的这个系统就是DNS。这个通常可以利用DNS缓存结果来达到减少时间。</li><li><strong>建立连接</strong>。HTTP是基于TCP协议的，浏览器最快也要在第三次握手时才能捎带HTTP请求报文，达到真正的建立连接，但是这个连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响比较明显，慢启动则对文件类大请求影响较大。</li></ul></li></ul><h3 id="HTTP1-1和HTTP1-0区别"><a href="#HTTP1-1和HTTP1-0区别" class="headerlink" title="HTTP1.1和HTTP1.0区别"></a>HTTP1.1和HTTP1.0区别</h3><ol><li><strong>缓存处理</strong>。在HTTP1.0中主要使用header里的 <code>If-Modified-Since</code>，<code>Expires</code> 来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如 <code>Entity tag</code>，<code>If-Unmodified-Since</code>，<code>If-Match</code>，<code>If-None-Match</code> 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>。HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>。在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>。在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接</strong>。HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启 <code>Connection： keep-alive</code>，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ol><h3 id="HTTPS和HTTP区别"><a href="#HTTPS和HTTP区别" class="headerlink" title="HTTPS和HTTP区别"></a>HTTPS和HTTP区别</h3><ul><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li></ul><blockquote><p>HTTP: HTTP -&gt; TCP</p><p>HTTPS: HTTP -&gt; SSL/TLS(加密，解密) -&gt; TCP</p></blockquote><h3 id="HTTP2-0和HTTP1-x区别"><a href="#HTTP2-0和HTTP1-x区别" class="headerlink" title="HTTP2.0和HTTP1.x区别"></a>HTTP2.0和HTTP1.x区别</h3><ol><li><strong>新的二进制格式</strong>。HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li><strong>多路复用</strong>。即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li><li><strong>header压缩</strong>。HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li><strong>服务器推送</strong>。还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</li></ol><h3 id="HTTP2-0的多路复用"><a href="#HTTP2-0的多路复用" class="headerlink" title="HTTP2.0的多路复用"></a>HTTP2.0的多路复用</h3><ul><li>HTTP/1.0：一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接</li><li>HTTP/1.1：同步执行，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能执行，一旦有某个请求超时，后续的请求只能被阻塞</li><li>HTTP/2.0：异步执行，多个请求可同时在一个连接上并行执行。某个请求任务超时，不会影响到其他连接的正常执行</li></ul><p><img data-src="../../assets/20200603153700.png" alt=""></p><h3 id="服务器推送是什么"><a href="#服务器推送是什么" class="headerlink" title="服务器推送是什么"></a>服务器推送是什么</h3><p>服务器推送能把客户端所需要的资源伴随着 <code>index.html</code> 一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。</p><ul><li><p>普通客户端请求过程</p><p><img data-src="../../assets/20200603155236.png" alt=""></p></li><li><p>服务器推送的过程</p><p><img data-src="../../assets/20200603155342.png" alt=""></p></li></ul><h3 id="为什么要头部压缩"><a href="#为什么要头部压缩" class="headerlink" title="为什么要头部压缩"></a>为什么要头部压缩</h3><p>假定一个页面有100个资源需要加载，而每一次请求都有1kb的消息头，则至少需要消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。</p><h3 id="HTTP2-0多路复用有多好"><a href="#HTTP2-0多路复用有多好" class="headerlink" title="HTTP2.0多路复用有多好"></a>HTTP2.0多路复用有多好</h3><p>HTTP性能优化的关键不在于高带宽，而是低延迟。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用TCP连接，让高带宽也能真正地服务于HTTP的性能提升。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题整理(四)</title>
    <url>/archives/1c046eb.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录一些进阶型的面试问题：TCP三次握手、<code>Cookie/SessionStorage/LocalStroage</code>区别、XSS攻击、浏览器和Node事件循环区别、HTTPS中间人攻击这几个问题。</p><p>原链接名：《30道经典面试题》</p><a id="more"></a><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>三次握手之所以是3次，原因是3次是保证 服务器（server）和 客户端（client）均让对方知道自己的接受和发送能力没问题而保证的最小次数。</p><ol><li>第一次：client =&gt; server。server 知道 client 具备发送能力</li><li>第二次：server =&gt; client。client 知道 server 具备发送和接收能力。（此时 client 还需要让 server 知道自己接收能力没有问题，于是需要第三次）</li><li>第三次：client =&gt; server。server 知道 client 具备接收能力。</li></ol><p>以上服务端和客户端完成了三次握手，建立连接。需要注意的是在三次握手中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 <code>seq</code>（连接数据包），后续的 <code>ACk</code>（应答数据包） 都会对这个 <code>seq</code> 进行加1来进行确认。</p><div class="note warning no-icon"><p>更多的关于HTTP三次握手和四次挥手详情，可见 <a href="/archives/19577025.html">链接</a></p></div><h3 id="Cookie、sessionStorage、localStorage-的区别"><a href="#Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="Cookie、sessionStorage、localStorage 的区别"></a>Cookie、sessionStorage、localStorage 的区别</h3><p>共同点：都是保存在浏览器端，并且遵循同源策略。</p><p>不同点：</p><ol><li>数据与服务器之间的交互方式<ul><li>Cookie的数据始终在浏览器和服务端来回传递。</li><li>SessionStorage和LocalStorage不会自动把数据发给服务端，仅保存在本地。</li></ul></li><li>存储大小<ul><li>Cookie数据大小不能超过4K。</li><li>SessionStorage和LocalStorage虽然也有存储大小的限制，但比Cookie大得多，可以达到5M左右。</li></ul></li><li>有效时间<ul><li>Cookie的数据有效时间需要设置，与窗口或浏览器关闭无关。</li><li>SessionStorage的数据只保存在当前浏览器窗口，窗口关闭后自动删除。</li><li>LocalStorage的数据会持久存储，即使浏览器关闭后数据也不会丢失，除非主动删除。</li></ul></li></ol><div class="note warning no-icon"><p>更多的关于Cookie、sessionStorage、localStorage详情，可见 <a href="/archives/4fd295e0.html">链接</a></p></div><h3 id="Cookie-如何防范-XSS-攻击"><a href="#Cookie-如何防范-XSS-攻击" class="headerlink" title="Cookie 如何防范 XSS 攻击"></a>Cookie 如何防范 XSS 攻击</h3><p>XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入JavaScript脚本，为了减轻这些攻击，需要在HTTP头部配上，Set-Cookie属性。</p><ul><li><code>secure</code>：这个属性告诉浏览器仅在请求为https的时候发送Cookie</li><li><code>httpOnly</code>：这个属性可以防止XSS，它会禁止JavaScript脚本来访问Cookie</li></ul><h3 id="浏览器和-Node-事件循环的区别"><a href="#浏览器和-Node-事件循环的区别" class="headerlink" title="浏览器和 Node 事件循环的区别"></a>浏览器和 Node 事件循环的区别</h3><ul><li>浏览器环境下，微任务的任务队列是每个宏任务执行完之后执行。</li><li>Node.js环境下，微任务会在事件循环的各个阶段执行，也就是说，每一个阶段执行完，就会去执行微任务队列中的任务。</li></ul><p>其中Promise属于为任务，浏览器和Node中对Promise的异步事件处理顺序就不一样。Node版本V11.0以上，这两者之间的顺序就相同了。</p><div class="note warning no-icon"><p>更多的关于浏览器、Node循环机制详情，可见 <a href="/archives/1e61d9e.html">链接</a></p></div><h3 id="HTTPS中间人攻击"><a href="#HTTPS中间人攻击" class="headerlink" title="HTTPS中间人攻击"></a>HTTPS中间人攻击</h3><p>HTTPS中间人攻击的原理就是劫持公钥，然后伪造公钥去获取传输的数据包。</p><p><strong>中间人攻击过程如下：</strong></p><ol><li>服务器向客户端发送公钥</li><li>攻击者自己生成一个伪造的公钥，发送给客户端</li><li>客户端收到伪造的公钥后，生成加密hash值发给服务器</li><li>攻击者获得加密hash值，用自己的私钥解密获取真密钥，同时生成假的加密hash值，发给服务器</li><li>服务器用私钥解密获得假的密钥，服务器用加密密钥加密传输信息</li></ol><p><strong>防范方法：</strong>服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性</p><p><strong>HTTPS服务端和客户端交互流程：</strong></p><p><img data-src="../../assets/1453209832.png" alt=""></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>面试</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题整理(二)</title>
    <url>/archives/3f44ae09.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录一些进阶型的面试问题：防抖/节流、get/post、模块化、npm安装机制、ES6继承等问题。</p><p>原链接名：《30道经典面试题》</p><a id="more"></a><h3 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？"></a>什么是防抖和节流？有什么区别？如何实现？</h3><p><strong>防抖：</strong>高频事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。主要是限制高频事件被触发的频率。</p><p><strong>节流：</strong>在指定时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。</p><p><strong>区别：</strong></p><ul><li>函数防抖和函数节流都是防止某一时间内频繁触发函数，但是实现原理不一样</li><li>函数防抖是某一段时间内只执行一次（触发频率影响最终时间）；而函数节流是间隔时间执行（触发频率不影响最终时间）</li></ul><p><strong>运用场景：</strong></p><ul><li><p>防抖(<code>debounce</code>)</p><ul><li>Search搜索联想，用户在不断输入值时，用防抖来节约请求资源</li><li>Window触发Resize的时候，不断调整浏览器窗口大小会不断触发这个事件，用防抖让其只触发一次</li></ul></li><li><p>节流(<code>throttle</code>)</p><ul><li>验证码在指定时间内只发送一次</li><li>监听滚动事件，比如是否滑到底部自动加载更多</li></ul></li></ul><p><strong>如何实现：</strong></p><ul><li>防抖：每次触发事件时都取消之前的延时调用方法</li><li>节流：每次触发事件时都判断当前是否有等待执行的延时函数</li></ul><div class="note primary"><p>详细的防抖和节流，可查看 <a href="/archives/a635d2be.html">链接</a></p></div><h3 id="get和post请求的误区"><a href="#get和post请求的误区" class="headerlink" title="get和post请求的误区"></a>get和post请求的误区</h3><p><strong>误区：</strong>get请求参数的大小存在限制，而post请求的参数大小是无限制的。</p><p>实际上HTTP协议从未规定GET/POST的请求长度限制是多少，对get请求参数的限制是来源于浏览器或web服务器，浏览器或web服务器限制了url的长度。</p><ul><li>HTTP协议未规定GET和POST的长度限制</li><li>GET的最大长度显示是因为浏览器和web服务器限制了URI的长度</li><li>不同的浏览器和web服务器，限制的最大长度不一样</li><li>要支持IE,则最大长度为2083byte，若只支持Chrome，则最大长度8182byte</li></ul><p>get和post在缓存方面的区别：</p><ul><li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存</li><li>post不同，post做的一般是修改和删除工作，所以必须与数据库交互，所以不能使用缓存</li></ul><h3 id="模块化发展历程"><a href="#模块化发展历程" class="headerlink" title="模块化发展历程"></a>模块化发展历程</h3><p>可以从IIFE -&gt; CommonJS -&gt; AMD -&gt; CMD -&gt; UMD -&gt; Webpack -&gt; ES Module几个过程考虑。模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p><p><strong>IIFE：</strong>使用自执行函数来编写模块化。</p><ul><li>特点：在一个单独的函数作用域中执行代码，避免变量冲突。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		data: []</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p><strong>CommonJS：</strong>node.js中自带的模块化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br></pre></td></tr></table></figure><p><strong>AMD：</strong>使用requireJS来编写模块化。</p><ul><li>特点：依赖必须提前声明好。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="string">"./index.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>)) </span>&#123;</span><br><span class="line">	<span class="comment">// code 就是 index.js 返回的内容       </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CMD：</strong>使用seaJS来编写模块化。</p><ul><li>特点：支持动态导入依赖文件。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">"./index.js"</span>);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UMD：</strong>兼容AMD，CommonJS模块化语法。</p><p><strong>Webpack：</strong>Webpack版本中的代码分割。</p><p><strong>ES Modules：</strong>ES6引入的模块化，支持import来导入另一个js。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><div class="note primary"><p>更多的模块化详解，可查看 <a href="/archives/b92372a3.html">链接</a></p></div><h3 id="npm模块安装机制"><a href="#npm模块安装机制" class="headerlink" title="npm模块安装机制"></a>npm模块安装机制</h3><ol><li>发出 <code>npm install</code> 命令</li><li>查询 node_modules 目录中是否已经存在指定模块</li><li>如存在，不再重新安装</li><li>如不存在，npm 向 registry 查询模块压缩包的网址</li><li>下载压缩包，存放在根目录的 <code>.npm</code> 目录里</li><li>解压压缩包到当前项目的 node_modules 目录</li></ol><h3 id="ES5与ES6的继承区别"><a href="#ES5与ES6的继承区别" class="headerlink" title="ES5与ES6的继承区别"></a>ES5与ES6的继承区别</h3><ul><li>ES5的继承是通过 <code>prototype</code> 或构造函数机制来实现。ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 <code>this</code> 上（<code>Parent.apply(this)</code>）</li><li>ES6的继承机制完全不同，实质上是先创建父类的实例对象 <code>this</code> (所以必须先调用父类的 <code>super()</code> 方法)，然后再用子类的构造函数修改 <code>this</code></li></ul><p><strong>ES5实现继承 - 原型链实现</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型链继承 子类的原型指向父类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance1); <span class="comment">// &gt; SubType</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &gt; ["red", "blue", "green"]</span></span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &gt; ["red", "blue", "green", "black"]</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &gt; ["red", "blue", "green", "black"]</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>原型链继承共享属性，属于引用类型，引用副本实例属性的修改必然会引起其他副本实例属性的修改</li><li>不能像父类构造函数随时传递参数，很不灵活</li></ul><p><strong>ES5实现继承 - 构造函数</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 借用构造函数继承 在执行Child构造函数时，将</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance3 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(instance3); <span class="comment">// &gt; Child: &#123;colors: ["red", "blue", "green"]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance3.colors); <span class="comment">// &gt; ["red", "blue", "green"]</span></span><br><span class="line">instance3.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance3.colors); <span class="comment">// &gt; ["red", "blue", "green", "black"]</span></span><br><span class="line"><span class="keyword">let</span> instance4 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(instance4.colors); <span class="comment">// &gt; ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>单独使用无法达到函数复用，因为每一个函数和属性都需要在构造函数中定义</li><li><code>instance of</code> 操作无法确定子类实例和父类之间的关系，因为子类的 <code>prototype</code> 和父类无关</li></ul><p><strong>ES6实现继承 - Class</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class实现继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance5 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(instance5); <span class="comment">// &gt; Child: &#123;colors: ["red", "blue", "green"]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance5.colors); <span class="comment">// &gt; ["red", "blue", "green"]</span></span><br><span class="line">instance5.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance5); <span class="comment">// &gt; Child: &#123;colors: ["red", "blue", "green", "black"]&#125;</span></span><br><span class="line"><span class="keyword">let</span> instance6 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(instance6.colors); <span class="comment">// &gt; ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>面试</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS阴影Box-Shadow</title>
    <url>/archives/d371c450.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要详细记录 CSS3 的 box-shadow 大全。</p><a id="more"></a><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>box-shadow: inset offset-x offset-y blur-radius spread-radius color;</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* offset-x | offset-y | color */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: 10<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> <span class="selector-tag">red</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset-x | offset-y | blur-radius | color */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: 10<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> <span class="selector-tag">red</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset-x | offset-y | blur-radius | spread-radius | color */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: 10<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> <span class="selector-tag">red</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* inset | offset-x | offet-y | color */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">inset</span> 10<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> <span class="selector-tag">red</span>;</span><br></pre></td></tr></table></figure><ul><li><code>inset</code>：默认阴影在外边框。使用 <code>inset</code> 后，阴影在边框内。</li><li><code>offset-x/offset-y</code>：<code>offset-x</code> 设置水平偏移量，如果是负值则阴影位于元素左边。<code>offset-y</code> 设置垂直偏移量，如果是负值则阴影位于元素上面。如果两者都是0，那么阴影位于元素后面，这是如果设置了 <code>blur-redius</code> 或 <code>spread-radius</code> 则有模糊效果。</li><li><code>blur-radius</code>：模糊距离。值越大，阴影就越大越淡。不能为负值。默认为0，此时阴影边缘锐利。</li><li><code>spread-radius</code>：阴影尺寸。取正值，阴影扩大，取负值，阴影收缩。默认为0，此时阴影与元素同样大。</li><li><code>color</code>：阴影颜色。</li></ul><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">120px</span> <span class="number">80px</span> <span class="number">40px</span> <span class="number">20px</span> <span class="number">#0ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="../../assets/20200528175403.png" alt=""></p><h3 id="常规效果"><a href="#常规效果" class="headerlink" title="常规效果"></a>常规效果</h3><h4 id="顶部阴影"><a href="#顶部阴影" class="headerlink" title="顶部阴影"></a>顶部阴影</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> -<span class="number">5px</span> <span class="number">5px</span> <span class="number">0</span> <span class="number">#0ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="../../assets/20200529100521-1590718067131.png" alt=""></p><h4 id="底部阴影"><a href="#底部阴影" class="headerlink" title="底部阴影"></a>底部阴影</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">0</span> <span class="number">#0ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="../../assets/20200529100914.png" alt=""></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Box-Shadow</tag>
      </tags>
  </entry>
  <entry>
    <title>Sourcetree使用</title>
    <url>/archives/f0db4be8.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录Sourcetree的基本使用及常见踩坑问题。</p><a id="more"></a><h2 id="安装跳过注册安装"><a href="#安装跳过注册安装" class="headerlink" title="安装跳过注册安装"></a>安装跳过注册安装</h2><ol><li><p>安装SrouceTree，下载地址: <a href="https://www.sourcetreeapp.com/，执行到选择bitbucket的界面退出" target="_blank" rel="noopener external nofollow noreferrer">https://www.sourcetreeapp.com/，执行到选择bitbucket的界面退出</a></p></li><li><p>到 <code>C:\Users\{用户名}\AppData\Local\Atlassian\SourceTree\</code> 这个路径下创建 <code>accounts.json</code>,并写入以下代码</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"$id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"$type"</span>: <span class="string">"SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity"</span>,</span><br><span class="line">    <span class="attr">"Authenticate"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"HostInstance"</span>: &#123;</span><br><span class="line">      <span class="attr">"$id"</span>: <span class="string">"2"</span>,</span><br><span class="line">      <span class="attr">"$type"</span>: <span class="string">"SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount"</span>,</span><br><span class="line">      <span class="attr">"Host"</span>: &#123;</span><br><span class="line">        <span class="attr">"$id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"$type"</span>: <span class="string">"SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount"</span>,</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"atlassian account"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"BaseUrl"</span>: <span class="string">"https://id.atlassian.com/"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Credentials"</span>: &#123;</span><br><span class="line">      <span class="attr">"$id"</span>: <span class="string">"4"</span>,</span><br><span class="line">      <span class="attr">"$type"</span>: <span class="string">"SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account"</span>,</span><br><span class="line">      <span class="attr">"Username"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"Email"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"IsDefault"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">]Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li><li><p>打开 <code>SourceTree.exe_Url_iayhtc13zv3obzuz5vchezjs1az2q5ef</code> (该目录与版本有关，可能不一致)，进入 <code>user.config</code> 文件，增加以下代码</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;setting name="AgreedToEULA" serializeAs="String"&gt;</span><br><span class="line">    &lt;value&gt;True&lt;/value&gt;</span><br><span class="line">&lt;/setting&gt;</span><br><span class="line">&lt;setting name="AgreedToEULAVersion" serializeAs="String"&gt;</span><br><span class="line">    &lt;value&gt;20160201&lt;/value&gt;</span><br><span class="line">&lt;/setting&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li><li><p>重新点击 SourceTree.exe 安装，弹框选择最后一项 [我不想使用Mercuial] 即可</p></li></ol><h2 id="设置-SSH"><a href="#设置-SSH" class="headerlink" title="设置 SSH"></a>设置 SSH</h2><ol><li>[工具] -&gt; [选项] -&gt; [SSH客户端配置]<ol><li>[SSH客户端] 选择 [OpenSSH]</li><li>[SSH密钥] 选择本地的 <code>id_rsa</code> 私钥文件（Git章节有详细教程）</li></ol></li><li>添加公钥到服务器，以GitHub为例：<ol><li>[github] -&gt; [Settings] -&gt; [SSH and GPG keys] -&gt; [New SSH key] 添加 <code>~/.ssh/id_rsa.pub</code> 文件内容到里面</li></ol></li></ol><h2 id="账户验证"><a href="#账户验证" class="headerlink" title="账户验证"></a>账户验证</h2><ol><li><p>Basic 验证</p><p>填写对应的用户名和密码即可验证</p></li><li><p>OAuth 验证</p><p>[github] -&gt; [Settings] -&gt; [Developer settings] -&gt; [OAuth Apps] 应用的名称随便填，主页 URL 填写<code>http://localhost:8080</code>，跳转网址填写 <code>http://localhost:8080/oauth/redirect</code></p></li></ol><h2 id="解决gitflow无法正常使用"><a href="#解决gitflow无法正常使用" class="headerlink" title="解决gitflow无法正常使用"></a>解决gitflow无法正常使用</h2><ol><li><p>点击 设置 -&gt; 编辑配置文件</p></li><li><p>修改配置选项：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[gitflow <span class="string">"prefix"</span>]</span><br><span class="line">    feature = feature/</span><br><span class="line">    bugfix = bugfix/</span><br><span class="line">    release = release/</span><br><span class="line">    hotfix = hotfix/</span><br><span class="line">    support = support/</span><br><span class="line">    versiontag =</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Git</category>
        <category>Sourcetree</category>
      </categories>
      <tags>
        <tag>Sourcetree</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题整理(五)</title>
    <url>/archives/76b1196.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录一些进阶型的面试问题：前端优化策略、重绘和回流、Vue列表渲染Key、为什么虚拟Dom会提高性能、清除浮动方式。</p><p>原链接名：《30道经典面试题》</p><a id="more"></a><h3 id="前端优化策略"><a href="#前端优化策略" class="headerlink" title="前端优化策略"></a>前端优化策略</h3><ol><li>减少HTTP请求数</li><li>从设计实现层面简化页面</li><li>合理设置HTTP缓存</li><li>资源合并与压缩</li><li>CSS Sprites</li><li>懒加载图片</li></ol><div class="note warning no-icon"><p>更多的关于前端优化，可见 <a href="/archives/1e61d9e.html">链接</a></p></div><h3 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h3><h3 id="Vue列表渲染Key"><a href="#Vue列表渲染Key" class="headerlink" title="Vue列表渲染Key"></a>Vue列表渲染Key</h3><h3 id="为什么虚拟Dom会提高性能"><a href="#为什么虚拟Dom会提高性能" class="headerlink" title="为什么虚拟Dom会提高性能"></a>为什么虚拟Dom会提高性能</h3><h3 id="清除浮动方式"><a href="#清除浮动方式" class="headerlink" title="清除浮动方式"></a>清除浮动方式</h3><!-- rebuild by neat -->]]></content>
      <categories>
        <category>面试</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Github使用Netlify加速</title>
    <url>/archives/ec0de0bc.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录github访问加速和账户验证。</p><a id="more"></a><h2 id="github访问加速"><a href="#github访问加速" class="headerlink" title="github访问加速"></a>github访问加速</h2><ol><li>打开 <a href="https://zijunwork.github.io/weblog/#/" target="_blank" rel="noopener external nofollow noreferrer">Netlify</a> 官网 -&gt; [注册] -&gt; 关联 GitHub 登录 -&gt; [New site from Git] -&gt; 选择GitHub</li><li>进入Github的认证授权页面，点击 <code>Authorize Netlify by Netlify</code></li><li>点击 <code>All repositories</code> 直接选择授权所有仓库，这个授权在设置中可以改</li><li>选择一个项目 如果是 docsify 项目，选择 <code>Base directory</code> 为 <code>/docs</code> 点击 [Deploy site] 发布即可</li><li>部署完成后，Netlify会自动生成一个随机的二级域名 <code>xxx.netlify.com</code>，点击[Site Settings]可以修改为自定义的二级域名</li><li>Site details下点击[Change site name]，可以为这个站点设置一个自定义的名字</li></ol><h2 id="账户验证"><a href="#账户验证" class="headerlink" title="账户验证"></a>账户验证</h2><ol><li><p>Basic 验证</p><p>填写对应的用户名和密码即可验证。</p></li><li><p>OAuth 验证，e.g. SourceTee验证用户方式之一</p><p>[github] -&gt; [Settings] -&gt; [Developer settings] -&gt; [OAuth Apps] 应用的名称随便填，主页 URL 填写<code>http://localhost:8080</code>，跳转网址填写 <code>http://localhost:8080/oauth/redirect</code>。</p></li><li><p>Token 验证，e.g. Webstorm 登录github方式之一</p><p>[github] -&gt; [Settings] -&gt; [Developer settings] -&gt; [Personal access tokens] 生成新的token，用token登录即可。</p></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Git</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript算法-最长重复子数组</title>
    <url>/archives/1ddc8c9a.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p><a id="more"></a><p><strong>题目：</strong></p><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p><p>说明：</p><ol><li><code>1 &lt;= len(A), len(B) &lt;= 1000</code></li><li><code>0 &lt;= A[i], B[i] &lt; 1000</code></li></ol><p>测试用例：</p><blockquote><p>e.g. 1<br>输入：<br>A: [1, 2, 3, 2, 1]<br>B: [3, 2, 1, 4, 7]<br>输出：3</p><p>e.g. 2<br>输入：<br>A: [0, 0, 0, 0, 0]<br>B: [0, 0, 0, 0, 0]<br>输出：5</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础-会话通信</title>
    <url>/archives/c9577b.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录会话通信的方式，Session，Cookie，Token这三种的方式的详情。</p><a id="more"></a><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>HTTP是一个无状态的协议。什么是无状态呢？就是说这一次的请求和上一次的请求时没有任何关联的，互不认识的，没有关系的。这种无状态的好处就是快速。坏处就是我们想要把 <code>www.20202030.cc/login.html</code> 和 <code>www.20202030.cc/index.html</code> 关联起来，必须使用某些手段和工具。Cookie/Session/Token就是这个手段和工具的产物。</p><h3 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h3><p>其客户端访问服务器的流程如下：</p><ol><li><p>首先，客户端会发送一个HTTP请求到服务器端</p></li><li><p>服务器端接收到客户端的请求后，建议一个Session，并发送一个HTTP响应到客户端，这个响应头，其中头部就包含 <code>Set-Cookie</code> 属性。这个头部就包含了SessionId。<code>Set-Cookie</code> 格式如下：<code>Set-Cookie: value[; expires=date][; domain=domain][;path=path][; secure][; httpOnly]</code>，e.g.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// Response Headers</span><br><span class="line">Set-Cookie: laravel_session=OVpQTJJq1L53FDhHgCooiHUqD1EpM8l1ZhtWgDl5; expires=Wed, 10-Jun-2020 08:45:25 GMT; Max-Age=604800; path=/; httponly</span><br></pre></td></tr></table></figure></li><li><p>在客户端发起的第二次请求，假如服务器给了 <code>Set-Cookie</code>，浏览器会自动在请求头中添加Cookie。e.g.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// Request Headers</span><br><span class="line">Cookie: laravel_session=OVpQTJJq1L53FDhHgCooiHUqD1EpM8l1ZhtWgDl5</span><br></pre></td></tr></table></figure></li><li><p>服务器接收请求，分解Cookie，验证信息，核对成功后返回response给客户端</p></li></ol><p><img data-src="../../assets/20200605112814.png" alt=""></p><div class="note warning no-icon"><ul><li>Cookie只是实现Session的其中一种方案。虽然是最常用的 ，但并不是唯一的方法。禁用Cookie后还有其他方法存储，比如放在url中</li><li>现在大多都是Session+Cookie，但是只是Session不用Cookie，或是只是Cookie，不用Session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用</li><li>用Session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用Cookie，数据量大的时候客户端是没有那么多空间的</li><li>如果只用Cookie不用Session，那么账户信息全部保留在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</li></ul><p><strong>简而言之，Session有用户信息档案表，里面包含了用户的认证信息和登录状态等信息，而Cookie就是用户的通行证。</strong></p></div><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>Token 也称作令牌，由 <code>uid + time + sign [+ 固定参数]</code>组成。Token的认证方式类似于临时的证书签名，并且是一种服务器端无状态的认证方式，非常适合于REST API的场景。所谓的无状态就是服务端并不会保存身份认证相关的数据。用Token解决负载均衡多服务器的问题的跨域认证方案也称为：JWT（Json web Token）。</p><p>其组成为：</p><ul><li><code>uid：</code>用户唯一身份标识</li><li><code>time：</code>当前时间的时间戳</li><li><code>sign：</code>签名，使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数（可选）： 将一些常用的固定参数加入到token中是为了避免重复查库</li></ul><p>Token在客户端一般存放于LocalStorage，Cookie，或SessionStorage中。在服务器一般存在于数据库中。</p><p>Token的认证流程如下：</p><ol><li>用户登录，成功后服务器返回Token给客户端</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将Token放入Headers中</li><li>服务器端采用Filter过滤器校验。校验成功则返回请求数据，校验失败则放回错误码</li></ol><p><img data-src="../../assets/20200605135955.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号：SessionId，通常存放于Cookie中。服务器收到Cookie后解析出SessionId，再去Session列表中查找，才能找到相应的Session。Session对Cookie的依赖不是必然的，替代方案有url等。</li><li>Cookie类似一个令牌，装有SessionId，存储在客户端，浏览器通常会自动添加。</li><li>Token也类似一个令牌，无状态，用户信息都被加密到Token中，服务器收到Token后解密就可知道是哪个用户。需要开发者手动添加。</li><li>JWT只是一个跨域认证的方案。</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>Cookie</tag>
        <tag>Session</tag>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript秘密花园-对象</title>
    <url>/archives/3aa91138.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript秘密花园-对象。</p><a id="more"></a><h3 id="对象使用和属性"><a href="#对象使用和属性" class="headerlink" title="对象使用和属性"></a>对象使用和属性</h3><p>JavaScript中所有变量都可以当作对象使用，除了两个例外 <code>null</code> 和 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span>.toString(); <span class="comment">// =&gt; "false"</span></span><br><span class="line"><span class="number">2.</span>toString(); <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="literal">null</span>.toString(); <span class="comment">// Uncaught TypeError: Cannot read property 'toString' of null</span></span><br><span class="line"><span class="literal">undefined</span>.toString(); <span class="comment">// Uncaught TypeError: Cannot read property 'toString' of undefined</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].toString(); <span class="comment">// =&gt; "1, 2"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.bar = <span class="number">1</span>;</span><br><span class="line">Foo.bar; <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><p>一个常见的误解是数字的字面量不能当作对象使用。这是因为 <code>JavaScript</code> 解析器的一个错误，它试图将点（<code>.</code>）操作符解析为浮点数字面值的一部分。如上面代码。有很多变通方法可以让数字的字面量看起来像对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span>.toString(); <span class="comment">// =&gt; "2" 第二个点号可以正常解析</span></span><br><span class="line"><span class="number">2</span> .toString(); <span class="comment">// =&gt; "2" 注意点号前面的空格</span></span><br><span class="line">(<span class="number">2</span>).toString(); <span class="comment">// =&gt; "2" 2先被计算</span></span><br></pre></td></tr></table></figure><p><strong>对象作为数据类型</strong></p><p><code>JavaScript</code> 的对象可以作为哈希表使用，主要用来保存命名的键与值的对应关系。使用对象的字面语法 <code>{}</code> 可以创建一个简单对象。这个新创建的对象从 <code>Object.prototype</code> 继承，没有任何自定义属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;&#125;; <span class="comment">// 一个空对象</span></span><br><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">test</span>: <span class="number">12</span> &#125;; <span class="comment">// 一个新对象，拥有一个值为12的自定义属性 “test”</span></span><br></pre></td></tr></table></figure><p><strong>访问属性</strong></p><p>有两种方式来访问对象的属性：</p><ul><li>点操作符</li><li>中括号操作符</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">name</span>: <span class="string">"zi jun"</span> &#125;;</span><br><span class="line">foo.name; <span class="comment">// =&gt; zi jun</span></span><br><span class="line">foo[<span class="string">'name'</span>]; <span class="comment">// =&gt; zi jun</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">get</span> = "name";</span><br><span class="line">foo[<span class="keyword">get</span>]; // =&gt; zi jun</span><br><span class="line"></span><br><span class="line">foo.1234; // Uncaught SyntaxError: Unexpected number</span><br></pre></td></tr></table></figure><p>两种语法是等价的，但是中括号操作符在下面两种情况下依然有效：</p><ul><li>动态设置属性</li><li>属性名不是一个有效的变量名</li></ul><p><strong>删除属性</strong></p><p>删除属性的唯一方法是使用 <code>delete</code> 操作符。设置属性为 <code>undefined</code> 或者 <code>null</code> 并不能真正地删除属性，而仅仅是移除了属性和值的关联。</p><p><strong>属性名的语法</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">  <span class="string">'case'</span>: <span class="string">'I am a keyword so I must be notated as a string'</span>,</span><br><span class="line">  <span class="keyword">delete</span>: <span class="string">'I am a keyword too so me'</span> <span class="comment">// 出错：SyntaxError</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对象的属性名可以使用字符串或者普通字符声明。但是由于 <code>JavaScript</code> 解析器的另一个错误设计， 上面的第二种声明方式在 <code>ECMAScript 5</code> 之前会抛出 <code>SyntaxError</code> 的错误。因此为了在更低版本的 <code>JavaScript</code> 引擎下也能正常运行， 必须使用<em>字符串字面值</em>声明方式。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p><code>JavaScript</code> 不包含传统的类继承模型，而是使用 <code>prototype</code> 原型模型。</p><p>由于 <code>JavaScript</code> 是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。</p><p>更多的详情，可以查看 <a href="/archives/d76fa986.html">链接</a></p><p><strong>属性查找</strong></p><p>当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止。</p><p>到查找到达原型链的顶部 - 也就是 <code>Object.prototype</code> - 但是仍然没有找到指定的属性，就会返回 <code>undefined</code>。</p><h3 id="hasOwnProperty函数"><a href="#hasOwnProperty函数" class="headerlink" title="hasOwnProperty函数"></a>hasOwnProperty函数</h3><h3 id="for…in…循环"><a href="#for…in…循环" class="headerlink" title="for…in…循环"></a>for…in…循环</h3><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>秘密花园</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式-单例模式</title>
    <url>/archives/1fbfc57.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript的设计模式-单例模式。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>单例模式(Singleton)：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>单例模式的实现在于保证一个特定类只有一个实例，第二次使用同一个类创建新对象的时候，应该得到与第一次创建对象完全相同的对象。</p><p><code>JavaScript</code> 的单例应该视作初始化后不被修改的变量。如此看来，其实单例模式是 <code>Javascript</code> 里应用最广泛的设计模式，使用CDN引入的所有库文件的入口都是单例，比如大名鼎鼎的 <code>jQuery</code>。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如：线程池、全局缓存、浏览器中的window 对象等。</p><p>在 <code>JavaScript</code> 开发中，单例模式的用途同样广泛，比如 登录浮窗、购物车、ES6模块化、库文件（<code>jQuery</code>）、<code>webSocket</code>、vuex中的store 等。</p><h2 id="单例的实现"><a href="#单例的实现" class="headerlink" title="单例的实现"></a>单例的实现</h2><h3 id="最简单的对象字面量"><a href="#最简单的对象字面量" class="headerlink" title="最简单的对象字面量"></a>最简单的对象字面量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = &#123;</span><br><span class="line">  a: <span class="string">"aaa"</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> ton1 = singleton;</span><br><span class="line"><span class="keyword">let</span> ton2 = singleton;</span><br><span class="line"><span class="built_in">console</span>.log(ton1 === ton2); <span class="comment">// &gt; true</span></span><br></pre></td></tr></table></figure><p>十分简单，并且非常使用，不足之处在于没有什么封装性，所有的属性方法都是暴露的。对于一些需要使用私有变量的情况就显得心有余而力不足了。当然在对于 this 的问题上也是有一定弊端的。</p><h3 id="静态属性中的实例"><a href="#静态属性中的实例" class="headerlink" title="静态属性中的实例"></a>静态属性中的实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Universe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> Universe.instance === <span class="string">"object"</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> Universe.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    Universe.instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> uni1 = <span class="keyword">new</span> Universe();</span><br><span class="line"><span class="keyword">let</span> uni2 = <span class="keyword">new</span> Universe();</span><br><span class="line"><span class="built_in">console</span>.log(uni1 === uni2); <span class="comment">// &gt; true</span></span><br></pre></td></tr></table></figure><p>在构造函数的静态属性中缓存该实例，缺点在于 instance 属性是公开可访问的属性，在外部代码中可能会修改该属性。</p><h3 id="闭包中的实例"><a href="#闭包中的实例" class="headerlink" title="闭包中的实例"></a>闭包中的实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Universe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="keyword">this</span>;</span><br><span class="line">    Universe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> uni1 = <span class="keyword">new</span> Universe();</span><br><span class="line"><span class="keyword">let</span> uni2 = <span class="keyword">new</span> Universe();</span><br><span class="line"><span class="built_in">console</span>.log(uni1 === uni2); <span class="comment">// &gt; true</span></span><br></pre></td></tr></table></figure><p>当第一次调用构造函数时，它正常返回 this ，然后在以后调用时，它将会执行重写构造函数，这个构造函数通过闭包访问了私有 <code>instance</code> 变量，并且简单的返回了该 <code>instance</code>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-ApplyCall</title>
    <url>/archives/495da9ad.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript中的 <code>call()</code> 、<code>apply()</code>、<code>bind()</code> 方法。</p><a id="more"></a><p>每个函数都包含两个非继承而来的方法： <code>call()</code> 和 <code>apply()</code> 方法。他们的作用都是在特定的作用域中调用函数，等于设置函数体内 <code>this</code> 对象的值，以扩充函数赖以运行的作用域。</p><p><strong>换句话说，<code>call()</code> 和 <code>apply()</code> 还有 <code>bind()</code> 都是用来重新定义 <code>this</code> 这个对象的。</strong></p><p>在解析他们之前，先看两个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e.g.1</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"zi jun"</span>, age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> myInfo = &#123;</span><br><span class="line">    name: <span class="string">"Devin"</span>,</span><br><span class="line">    realAge: <span class="keyword">this</span>.age,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我的名字："</span> + <span class="keyword">this</span>.name + <span class="string">", 年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(myInfo.realAge); <span class="comment">// &gt; 20</span></span><br><span class="line"><span class="built_in">console</span>.log(myInfo.sayHello()); <span class="comment">// &gt; 我的名字：Devin, 年龄：undefined</span></span><br></pre></td></tr></table></figure><p>当调用 <code>console.log(myInfo.realAge)</code>,即执行 <code>console.log(this.age)</code>, <code>this</code> 指向顶级 <code>Window</code> 对象。<code>window.age</code> 为 <code>20</code>；函数作为对象的一个方法时，并且作为对象的一个方法被调用时，函数中的 <code>this</code> 指向这个上一级对象。即 <code>sayHello()</code> 中的的 <code>this</code> 指向 <code>myInfo</code> 这个对象。<code>this.age</code> 即为 <code>myInfo.age</code>,值为 <code>undefined</code>。</p><div class="note warning no-icon"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e.g.1-1</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"zi jun"</span>, age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> myInfo = &#123;</span><br><span class="line">    name: <span class="string">"Devin"</span>,</span><br><span class="line">    realAge: <span class="keyword">this</span>.age,</span><br><span class="line">    sayHello: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> age = <span class="number">28</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我的名字："</span> + <span class="keyword">this</span>.name + <span class="string">", 年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(myInfo.realAge); <span class="comment">// &gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(myInfo.sayHello()); <span class="comment">// &gt; 我的名字：Devin, 年龄：20</span></span><br></pre></td></tr></table></figure><p>注意如果是用 <code>let</code> 声明的，那么即不是定义在 <code>window</code> 上的属性，那么 <code>window.age</code> 为 <code>undefined</code>。箭头函数中的 <code>this</code> 不是调用的时候决定的，而是在定义的时候处在的对象就是它的 <code>this</code>。换句话说，箭头函数的 <code>this</code> 看外层是否有函数，如果有，外层函数的 <code>this</code> 就是内部箭头函数的 <code>this</code>,如果没有，则 <code>this</code> 指向 <code>window</code>。</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e.g.2</span></span><br><span class="line"><span class="keyword">var</span> fav = <span class="string">"子俊"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shows</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fav;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(shows()); <span class="comment">// &gt; "子俊"</span></span><br></pre></td></tr></table></figure><p>两者 <code>this</code> 的差别：e.g.1 中 <code>this</code> 指向 <code>myInfo</code>,e.g.2 中的 <code>this</code> 指向 <code>window</code>。</p><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e.g.3</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"zi jun"</span>, age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> myInfo = &#123;</span><br><span class="line">    name: <span class="string">"Devin"</span>,</span><br><span class="line">    realAge: <span class="keyword">this</span>.age,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我的名字："</span> + <span class="keyword">this</span>.name + <span class="string">", 年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">  	name: <span class="string">"子俊"</span>,</span><br><span class="line">    age: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(myInfo.realAge.call(you)); <span class="comment">// Uncaught TypeError: myInfo.realAge.call is not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(myInfo.sayHello.call(you)); <span class="comment">// &gt; 我的名字：子俊， 年龄：100</span></span><br><span class="line"><span class="built_in">console</span>.log(myInfo.sayHello.apply(you)); <span class="comment">// &gt; 我的名字：子俊， 年龄：100</span></span><br><span class="line"><span class="built_in">console</span>.log(myInfo.sayHello.bind(you)()); <span class="comment">// &gt; 我的名字：子俊， 年龄：100</span></span><br></pre></td></tr></table></figure><p>从上面代码可以看出共性：</p><ul><li><code>call()/apply()/bind()</code> 只能作用域函数</li><li><code>call()/apply()/bind()</code> 这三个函数的第一个参数都是 <code>this</code> 的指向对象</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e.g.4</span></span><br><span class="line"><span class="keyword">var</span> myInfo = &#123;</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params">from, destination</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我的名字："</span> + <span class="keyword">this</span>.name + <span class="string">", 年龄："</span> + <span class="keyword">this</span>.age + <span class="string">", 来自："</span> + <span class="keyword">from</span> + <span class="string">", 去往："</span> + destination;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">    name: <span class="string">"子俊"</span>,</span><br><span class="line">    age: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(myInfo.sayHello.call(you, <span class="string">"北京"</span>, <span class="string">"上海"</span>)); <span class="comment">// &gt; 我的名字：子俊, 年龄：100, 来自：北京, 去往：上海</span></span><br><span class="line"><span class="built_in">console</span>.log(myInfo.sayHello.apply(you, [<span class="string">"北京"</span>, <span class="string">"上海"</span>])); <span class="comment">// &gt; 我的名字：子俊, 年龄：100, 来自：北京, 去往：上海</span></span><br><span class="line"><span class="built_in">console</span>.log(myInfo.sayHello.bind(you, <span class="string">"北京"</span>, <span class="string">"上海"</span>)()); <span class="comment">// &gt; 我的名字：子俊, 年龄：100, 来自：北京, 去往：上海</span></span><br></pre></td></tr></table></figure><p>从上面代码可以看出差别：</p><ul><li><code>call()</code> 的参数从第二个开始：参数是直接方进入的，用 <code>,</code> 隔开</li><li><code>apply()</code> 的参数从第二个开始：参数是以数组的形式传入</li><li><code>bind()</code> 的参数从第二个开始：参数是直接方进入的，用 <code>,</code> 隔开，不同 <code>call()</code> 的是，它返回的是函数</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Apply</tag>
        <tag>Call</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-PromiseAsync区别</title>
    <url>/archives/6f36c6d1.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录从一到面试题引出的 <code>setTimeout</code>, <code>Promise</code>, <code>async/await</code> 的区别。</p><a id="more"></a><h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async2 start"</span>);</span><br><span class="line">    <span class="keyword">await</span> async3();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async2 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async3"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"setTiemout"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script end"</span>);</span><br></pre></td></tr></table></figure><p>题目的本质就是考察 <code>setTimeout</code>、<code>promise</code>、<code>async/await</code> 的实现及执行顺序，以及 <code>javaScript</code> 的事件循环的相关问题。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2 start</span></span><br><span class="line"><span class="comment">// async3</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async2 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p><code>JavaScrit</code>主线程不断地循环往复的从任务列队中读取任务，执行任务，其中运行机制称为事件循环（event loop）。</p><h3 id="微任务-宏任务"><a href="#微任务-宏任务" class="headerlink" title="微任务/宏任务"></a>微任务/宏任务</h3><p>任务类型：</p><ul><li>微任务：为 <code>async/await</code> 和 <code>Promise</code> 实现延迟执行，在每一个事件循环之前，微任务队列总是被清空（执行）<ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>async/await</code></li></ul></li><li>宏任务：用于处理 <code>I/O</code> 和 计时器等事件<ul><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>I/O</code></li><li><code>UI渲染</code></li></ul></li></ul><h3 id="异步运行机制"><a href="#异步运行机制" class="headerlink" title="异步运行机制"></a>异步运行机制</h3><p><code>JavaScript</code> 主线程拥有一个 <strong>执行栈（同步任务）</strong> 和一个 <strong>任务队列</strong>，主线程会依次执行代码，</p><ul><li>当遇到函数（同步）时，会先将函数入栈，函数运行结束后再将函数出栈</li><li>当遇到任务（异步）时，这些任务会返回一个值，让主线程不在此阻塞，使主线程继续执行下去，而真正的任务交给 <strong>浏览器内核</strong> 执行，浏览器内核执行结束后，会将该任务事先定义好的 <strong>回调函数</strong> 加入相应的任务队列中</li><li>当 <code>JS</code> 主线程清空执行栈之后，会按先入先出的顺序读取微任务队列中的回调函数，并将函数入栈，继续运行执行栈，直到清空执行栈，再去读取任务队列</li></ul><h3 id="面试题执行解析"><a href="#面试题执行解析" class="headerlink" title="面试题执行解析"></a>面试题执行解析</h3><p><strong>关键点：</strong></p><ul><li><code>setTimeout</code> 为宏任务，会放置到任务队列最后执行</li><li>同级任务队列执行的模式时先进先出的原则</li><li><code>async/await</code> 中 <code>await</code> 后面的函数执行是从右到左的，即先执行 <code>await</code> 函数，在暂停(跳出) <code>async</code> 函数，执行 <code>async</code> 外面的代码</li><li>执行任务等级：<code>promise</code> &gt; <code>await</code> &gt; <code>setTimeout</code></li></ul><p><strong>具体执行步骤：</strong></p><ol><li>代码执行（主任务），<code>async1</code>,<code>async2</code>,<code>async3</code> 都是声明的异步函数，所以会跳过，直接到 <code>console.log(&quot;script start&quot;)</code>,所以会打印 <code>script start</code></li><li>执行到 <code>setTimeout</code>,<code>setTimeout</code> 为宏任务，虽然是延迟0秒执行，但是是放置到任务队列（暂命名：<strong>宏任务1</strong>）去的。往后，线程执行 <code>async1()</code>,执行 <code>async1</code> 里面的代码，打印 <code>async1 start</code></li><li>继续执行 <code>async1</code> 中的代码，便会执行 <code>async2()</code>。线程执行 <code>async2</code> 里面的代码，打印 <code>async2 start</code></li><li>线程往下执行 <code>async2</code>，遇到 <code>await async3()</code>，参照第3步，代码打印 <code>async3</code></li><li>重点来了，当第4步执行完了之后，线程回到 <code>async2()</code> 中的 <code>await async2()</code>，将回调函数（任务）放置到微任务队列（暂命名：<strong>微任务1</strong>）中。然后继续执行主任务。即执行 <code>new Promise</code>，由于 <code>promise</code> 会立即执行，所以打印 <code>promise1</code></li><li>重点又来了，由于 <code>then</code> 和 <code>await</code> 类似，所以，在执行第5步之后，其实后面的代码（<code>then</code>中的函数（任务））会放置到微任务队列（暂命名：<strong>微任务2</strong>）中。然后继续执行主任务，即执行 <code>console.log(&quot;script end&quot;)</code>，所以打印 <code>script end</code></li><li>此时，主任务已经执行完了，然后清空（执行）微任务队列。通过上述分析，可以知道，微任务队列中，有两个微任务：一个是<strong>微任务1</strong>，还有一个<strong>微任务2</strong>。根据先进先出的原则，开始执行<strong>微任务1</strong>，打印 <code>async2 end</code>。注意此时，执行完之后，线程会回到 <code>async1()</code> 中的 <code>await async2()</code>里，将回调函数（任务）放置到微任务队列（暂命名：<strong>微任务3</strong>）中</li><li>继续清空微任务队列，还是有两个：一个是<strong>微任务2</strong>，还要一个<strong>微任务3</strong>。根据先进先出的原则，开始执行<strong>微任务2</strong>，打印 <code>promise2</code></li><li>继续清空微任务队列，只有一个了，那就是<strong>微任务3</strong>，即打印 <code>async1 end</code></li><li>最后清空宏任务，打印 <code>setTimeout</code></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
        <tag>Async</tag>
        <tag>Await</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础-Storage存储</title>
    <url>/archives/4fd295e0.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录前端的存储方式：Cookie、SessionStorage、LocalStorage的使用、区别、使用场景等。</p><a id="more"></a><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><strong>为什么会有Cookie</strong></p><p>Web应用程序是使用HTTP协议进行数据传输的。HTTP协议是无状态的协议。一旦数据交互完毕，客户端与服务端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。要跟踪该会话，必须引入一种机制。Cookie就是这样的一种机制，它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网址都采用Cookie来跟踪会话。不同的是：Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</p><p><strong>什么是Cookie</strong></p><p>Cookie是由服务端生成，发送给User-Agent（一般是浏览器），服务器告诉浏览器设置一下Cookie，浏览器自动会将Cookie以键值对的形式保存到某个目录下的文本文件中 ，下次请求同一网站也会自动发送该Cookie给服务器，即添加在请求头部（前提是浏览器设置为启动Cookie）。这就是Cookie的工作原理。简单说就是服务端给客户端颁发一个通行证，每人一个，无论谁访问都必须携带自己的通行证，这样服务器就能从通行证上确认客户身份。</p><p><strong>Cookie组成</strong></p><ol><li><code>Name/Value</code>：设置Cookie的名称及对应的值。一旦创建，名称便不能更改。</li><li><code>Expires/Max-age</code>：设置Cookie的生存期。如果 <code>Expires</code> 属性缺省，为会话性Cookie，仅保存在客户端内存中，浏览器关闭时失效，否则为持久性Cookie，直至有效期到期或者手动到期。</li><li><code>Domain</code>：设置访问该Cookie的域名。如果设置为 “.a.com”，那么以 “a.com”结尾的所有域名都可以访问该Cookie。</li><li><code>Path</code>：设置Cookie的使用路径。如果设置为 “/a” ，那么路由为 <code>/a</code> 及下级路由可以访问该Cookie，如果设置为 “/”，则本域名下的所有路由都可以访问该Cookie。</li><li><code>Secure</code>：设置Cookie是否只在HTTPS或者其他安全协议时，才会发送。默认为空（都会携带）。</li><li><code>HttpOnly</code>：设置Cookie能否通过JS去访问。默认为空（可以通过JS去访问）。</li></ol><p><strong>Cookie的特点</strong></p><ol><li>Cookie具有有效期<ul><li>可通过设置 <code>expires</code> 来设定Cookie的有效期，持久性Cookie，保存在硬盘中</li><li>如果不设置，默认是临时存储，即关闭浏览器就消失，临时性Cookie，保存在内存中</li></ul></li><li>Cookie满足同源策略<ul><li>必须满足条件之一：同域名（协议和端口可以不同）</li><li>必须满足跳转之二：均可访问到当前路径或父级路径的Cookie</li></ul></li><li>Cookie内存大小有限制<ul><li>不同浏览器的限制不同，一般是一个域名下最多20个Cookie，每个Cookie最大限制4K</li></ul></li><li>Cookie的安全性不高<ul><li>Cookie可以在本地被更改和获取，敏感数据不要放在Cookie里</li></ul></li></ol><p><strong>Cookie的使用</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"myname=zi jun; expires=Thu, 18 Dec 2030 12:00:00 GMT; path=/"</span>; <span class="comment">// 创建cookie,修改cookie</span></span><br><span class="line"><span class="keyword">let</span> cookie = <span class="built_in">document</span>.cookie; <span class="comment">// 读取cookie</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"username=; expires=Thu, 01 Jan 1970 00:00:00 GMT"</span>;</span><br></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><strong>什么是Session</strong></p><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p><p>SessionId是第一个请求之后响应，服务器写在响应头，Set-Cookie的头部的，这个头部包含了 SessionId。Cookie只是实现Session的其中一种方案。虽然是最常用的，但不是唯一的办法。比如禁用Cookie后还有其他方法存储，比如放在url中。</p><div class="note warning no-icon"><p>更多的关于Cookie、session、token详情，可见 <a href="/archives/c9577b.html">链接</a></p></div><h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p>SessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">"key"</span>,<span class="string">"value"</span>); <span class="comment">// 以“key”为名称存储一个值“value”</span></span><br><span class="line">sessionStorage.getItem(<span class="string">"key"</span>); <span class="comment">// 获取名称为“key”的值</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">"key"</span>); <span class="comment">// 删除名称为“key”的信息。</span></span><br><span class="line">sessionStorage.clear(); <span class="comment">// 清空sessionStorage中所有信息</span></span><br></pre></td></tr></table></figure><h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><p>LocalStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除LocalStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">"key"</span>,<span class="string">"value"</span>); <span class="comment">// 以“key”为名称存储一个值“value”</span></span><br><span class="line">localStorage.getItem(<span class="string">"key"</span>); <span class="comment">// 获取名称为“key”的值</span></span><br><span class="line">localStorage.removeItem(<span class="string">"key"</span>); <span class="comment">// 删除名称为“key”的信息。</span></span><br><span class="line">localStorage.clear(); <span class="comment">// 清空localStorage中所有信息</span></span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>共同点：</strong></p><p>都是保存在浏览器端、且同源的</p><p><strong>区别：</strong></p><ol><li>Cookie数据始终在同源的http请求中携带（即使不需要），即Cookie在浏览器和服务器间来回传递，而SessionStorage和LocalStorage不会自动把数据发送给服务器，仅在本地保存。Cookie数据还有路径（path）的概念，可以限制Cookie只属于某个路径下</li><li>存储大小限制也不同，Cookie数据不能超过4K，同时因为每次http请求都会携带Cookie、所以Cookie只适合保存很小的数据，如会话标识。SessionStorage和LocalStorage虽然也有存储大小的限制，但比Cookie大得多，可以达到5M或更大</li><li>数据有效期不同，SessionStorage：仅在当前浏览器窗口关闭之前有效；LocalStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；Cookie：只在设置的Cookie过期时间之前有效，即使窗口关闭或浏览器关闭</li><li>作用域不同，SessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；Localstorage在所有同源窗口中都是共享的；Cookie也是在所有同源窗口中都是共享的</li><li>Web Storage支持事件通知机制，可以将数据更新的通知发送给监听者</li><li>Web Storage的api接口使用更方便</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>Cookie</tag>
        <tag>SessionStorage</tag>
        <tag>LocalStorage</tag>
      </tags>
  </entry>
  <entry>
    <title>Git生成SSH</title>
    <url>/archives/64992bff.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录Git的安装，常用命令，生成SSH密钥等。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载地址：<a href="http://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener external nofollow noreferrer">git-for-windows镜像</a></p><h2 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h2><p>查看用户名：<code>git config user.name</code></p><p>查看用户邮箱：<code>git config user.email</code></p><h2 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h2><p>修改用户名：<code>git config --global user.name “Zi Jun”</code></p><p>修改邮箱：<code>git config --global user.email “zijun2030@163.com”</code></p><h2 id="检查是否已经存在SSH密钥"><a href="#检查是否已经存在SSH密钥" class="headerlink" title="检查是否已经存在SSH密钥"></a>检查是否已经存在SSH密钥</h2><p><code>cd ~/.ssh</code> 如果能进入说明已经存在</p><h2 id="生成SSH密钥"><a href="#生成SSH密钥" class="headerlink" title="生成SSH密钥"></a>生成SSH密钥</h2><p><code>ssh-keygen -t rsa -C “zijun2030@163.com”</code> 按3个回车键，密码为空</p><p>文件存放位置 <code>~/.ssh</code>,如果是window的话，Administrator用户，位置：<code>C:\User\Administrator.ssh</code> 下面，如果是其他用户，需要换成对应的用户</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Git</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-严格模式</title>
    <url>/archives/fb69cc5d.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript严格模式的详解。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>除了正常运行模式，ECMAscript5 中添加了第二种运行模式：“严格模式”（strict mode）。顾名思义，<code>这种模式要求JavaScript</code> 在更严格的模式中运行。</p><p>设立“严格模式”的目的，主要有以下几个原因：</p><ul><li>消除 <code>JavaScript</code> 语法的一些不合理，不严谨之处，减少一些怪异行为</li><li>消除代码运行的一些不安全之处，保证代码运行的安全</li><li>提高编译效率，增加运行速度</li></ul><p>e.g. 浏览器中 <code>F12</code> 键进入调试模式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3.14</span>; <span class="comment">// 不会报错，正常</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"user strict"</span></span><br><span class="line">y = <span class="number">6.18</span>; <span class="comment">// Uncaught ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure><h2 id="进入标志"><a href="#进入标志" class="headerlink" title="进入标志"></a>进入标志</h2><p>进入“严格模式”的标志，是 <code>&quot;use strict&quot;;</code>。老版本的浏览器会把它当做一行普通的字符串，会忽略。</p><h2 id="如何调用"><a href="#如何调用" class="headerlink" title="如何调用"></a>如何调用</h2><p>“严格模式”有两种调用方式</p><ol><li><p>针对整个脚本文件</p><p>需要将 <code>&quot;use strict&quot;;</code> 放在脚本文件的第一行。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="meta">    "use strict"</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 以下代码为 严格模式</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 以下代码为 正常模式</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>针对单个函数</p><p>需要将 <code>&quot;use strict&quot;;</code> 放在函数体的第一行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="string">"user strict"</span>;</span><br><span class="line">    <span class="comment">// 以下代码为 严格模式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noStrict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 以下代码为 正常模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h2><ul><li><p>不允许使用未声明的变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">a = <span class="number">1</span>; <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;&#125; <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>不允许删除变量或对象，只有 <code>configurable</code> 设置为 <code>true</code> 的对象属性，才能被删除</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">// Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">delete</span> b.x; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><div class="note warning no-icon"><p>为什么 <code>var</code> / <code>let</code> / <code>const</code> 声明的变量无法删除？<br></p><p>在正常模式，变量或对象执行 <code>delete</code> 不会报错，但是删除操作不会成功。比如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> d = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">delete</span> c;</span><br><span class="line"><span class="keyword">delete</span> d;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// &gt; 2</span></span><br></pre></td></tr></table></figure><p><strong>究其原因，是因为用不管是在正常模式还是“严格模式”下，<code>var</code> 声明的变量，其属性是 <code>configuarable = false</code>，所以不能删除</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">'a'</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    configurable: false,</span></span><br><span class="line"><span class="comment">    enumerable: true,</span></span><br><span class="line"><span class="comment">    value: 1,</span></span><br><span class="line"><span class="comment">    writable: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>更多的 对象属性，可查看<a href="/archives/27b30017.html">《JavaScript进阶-对象属性》</a></p></div></li><li><p>不允许删除函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">delete</span> foo; <span class="comment">// Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br></pre></td></tr></table></figure></li><li><p>不允许变量重名</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, x</span>)</span>&#123;&#125; <span class="comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure></li><li><p>不允许使用八进制</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">010</span>; <span class="comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span></span><br></pre></td></tr></table></figure></li><li><p>不允许使用转义字符</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">let</span> x = \<span class="number">010</span>; <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure></li><li><p>不允许对只读属性赋值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"x"</span>, &#123;<span class="attr">value</span>:<span class="number">0</span>, <span class="attr">writable</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">obj.x = <span class="number">3.14</span>; <span class="comment">// Uncaught TypeError: Cannot assign to read only property 'x' of object '#&lt;Object&gt;'</span></span><br></pre></td></tr></table></figure></li><li><p>不允许对一个使用getter方法读取的属性进行赋值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="keyword">get</span> x() &#123;<span class="keyword">return</span> <span class="number">0</span>&#125; &#125;;</span><br><span class="line">obj.x = <span class="number">3.14</span>; <span class="comment">// Uncaught TypeError: Cannot set property x of #&lt;Object&gt; which has only a getter</span></span><br></pre></td></tr></table></figure></li><li><p>不允许删除一个不允许删除的属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">// Uncaught TypeError: Cannot delete property 'prototype' of function Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>变量名不能使用 <code>eval</code> 字符串</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span> = <span class="number">3.14</span>; <span class="comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span></span><br></pre></td></tr></table></figure></li><li><p>变量名不能使用 <code>arguments</code> 字符串</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="number">3.14</span>; <span class="comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span></span><br></pre></td></tr></table></figure></li><li><p>在作用域 <code>eval()</code> 创建的变量不能被调用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">eval</span> (<span class="string">"var x = 2"</span>);</span><br><span class="line">alert (x); <span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>禁止 <code>this</code> 关键字指向全局对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">f(); <span class="comment">// Uncaught TypeError: Cannot set property 'a' of undefined</span></span><br></pre></td></tr></table></figure></li><li><p>保留关键字（<code>implements</code>、<code>interface</code>、<code>let</code>、<code>package</code>、<code>private</code>、<code>protected</code>、<code>public</code>、<code>static</code>、<code>yield</code>）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> public = <span class="number">2</span>; <span class="comment">// Uncaught SyntaxError: Unexpected strict mode reserved word</span></span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-变量声明</title>
    <url>/archives/71a05d55.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript中变量和函数的声明，<code>let</code>, <code>const</code>, <code>function</code>, <code>var</code>。</p><a id="more"></a><p>要想搞清楚提升的本质，这里主要需要理解 <code>JavaScript</code> 变量的 <strong>创建</strong>(create)、<strong>初始化</strong>(initialize)、<strong>赋值</strong>(assign)。</p><h2 id="var声明"><a href="#var声明" class="headerlink" title="var声明"></a>var声明</h2><p>假设有如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// &gt; undefined</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>以上代码解析：</p><ol><li><code>JavaScript</code>引擎编译阶段：创建变量 - 作用域创建函数变量 <code>fn</code> (<code>function fn(){...}</code>)</li><li><code>JavaScript</code>引擎执行阶段：进入 <code>fn</code>,为 <code>fn</code> 创建一个环境</li><li><code>JavaScript</code>引擎编译阶段：创建变量 - 作用域创建变量 <code>x</code>, <code>y</code></li><li><code>JavaScript</code>引擎编译阶段：初始化变量 - <code>x</code>, <code>y</code> 分别为 <code>undefined</code></li><li><code>JavaScript</code>引擎执行阶段：赋值 - <code>x</code> 赋值为1， <code>y</code> 赋值为2</li></ol><p>结论：<code>var</code> 声明会在代码执行之前（编译阶段）就完成了变量的 <strong>创建</strong>、<strong>初始化</strong>。这就解释了为什么在 <code>var x = 1;</code>之前，<code>console.log(x)</code> 会得到 <code>undefined</code>。</p><h2 id="function声明"><a href="#function声明" class="headerlink" title="function声明"></a>function声明</h2><p>假设有如下代码，也可以看上面的一段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn2();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>); <span class="comment">// &gt; 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码解析：</p><ol><li><code>JavaScript</code>引擎编译阶段：创建变量 - 作用域创建函数变量 <code>fn2</code> (<code>function fn2(){...}</code>)</li><li><code>JavaScript</code>引擎执行阶段：进入 <code>fn2</code>,为 <code>fn2</code> 创建一个环境</li><li><code>JavaScript</code>引擎执行阶段：执行代码</li></ol><div class="note warning no-icon"><p><code>var a = 1;</code> 的提升，相当于在顶部执行了 <code>var a;</code> 和 <code>a = 1;</code> <strong>创建</strong> 和 <strong>初始化</strong></p><p><code>function fn(){}</code> 的创建相当于把这个函数整体提升到了顶部，<strong>创建</strong> 和 <strong>初始化</strong>，并不存在 <strong>赋值</strong> 一说，因为按照《你不知道的JavaScript(上卷)》的解释：</p><blockquote><p>如果将函数声明 <code>function fn(a) {..}</code> 概念化为普通的变量声明和赋值，比如 <code>var fn;</code> <code>fn = function(a){..}</code> 。如果这样理解的话，这个函数声明将需要进行LHS查询。实际上引擎在执行代码时，不会有专门用来将一个函数值 “分配给” <code>fn</code>。因此，将函数声明理解成LHS查询和赋值的形式并不合适。</p></blockquote></div><h2 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h2><p>假设有如下代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// Uncaught ReferenceError: Cannot access 'x' before initialization</span></span><br><span class="line">    <span class="keyword">let</span> x;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码解析：</p><ol><li><code>JavaScript</code>引擎编译阶段(块作用域)：创建变量 - 创建变量 <code>x</code></li><li><code>JavaScript</code>引擎执行阶段(块作用域)：执行代码 <code>console.log(x)</code>，RHS查询变量 <code>x</code></li><li><code>JavaScript</code>引擎执行阶段(块作用域)：初始化 - <code>x</code> 初始化 <code>x = undefined</code></li><li><code>JavaScript</code>引擎执行阶段(块作用域)：赋值 - 变量 <code>x</code> 赋值为2</li></ol><div class="note warning no-icon"><p>为何不是报错为 <code>undefined</code>？个人总结如下：</p><ul><li><code>defined/undefined</code> 界定的标准是：变量是否创建和初始化</li></ul></div><p>上面代码，可以直观感受到 <code>let</code> 中没有变量提升，因为在变量声明之前使用变量都报错了。如果按照 <code>var</code> 申明变量的逻辑分析，如果有变量提升，那么在对 <code>x</code> 进行RHS查询的时候，不应该报错。真的是 <code>let</code> 中没有变量提升吗？看以下例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// Uncaught ReferenceError: Cannot access 'x' before initialization</span></span><br><span class="line">    <span class="keyword">let</span> x;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码解析：</p><ol><li><code>JavaScript</code>引擎编译阶段(外层)：创建变量 - 创建变量 <code>x</code> 并初始化 <code>x = 1</code></li><li><code>JavaScript</code>引擎编译阶段(内层)：创建变量 - 创建变量 <code>x</code></li><li><code>JavaScript</code>引擎执行阶段(内层)：执行代码 <code>console.log(x)</code>，<code>RHL</code>查询变量 <code>x</code></li><li><code>JavaScript</code>引擎执行阶段(内层)：初始化 - <code>x = undefined</code></li><li><code>JavaScript</code>引擎执行阶段(内层)：赋值 - <code>x = 2</code></li></ol><p>从这段代码可以看出，内层环境中 <code>x</code> 变量肯定是有提升的，不然，按照作用域的查询规格，就会查找外层的 <code>x</code>。</p><div class="note warning no-icon"><p>以上2段的代码可以总结出：</p><ul><li><code>var</code> 声明变量，其创建和初始化都是在编译过程中完成的，赋值在执行阶段</li><li><code>let</code> 声明变量，其创建是在编译过程中完成的，初始化和赋值则是在执行过程中完成的</li><li><code>defined/undefined</code> 界定的标准是：变量是否创建和初始化</li><li><code>initialization</code> 界定的标准是：变量是否初始化</li></ul></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>var</code> 声明变量，在引擎编译阶段完成变量的创建和初始化，也就是创建和初始化被提升了，变量赋值在引擎执行阶段</li><li><code>let</code> 声明变量，在引擎编译阶段完成变量的创建，也就是创建被提升了，变量初始化和赋值在引擎执行阶段</li><li><code>function</code> 声明函数，在引擎编译阶段完成函数的创建和初始化，也就是创建和初始化被提升了，不存在赋值一说</li><li><code>const</code> 声明常量，在引擎编译阶段完成变量的创建，也就是创建被提升了，变量初始化在引擎执行阶段，不允许赋值</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-字面量</title>
    <url>/archives/3d4f90ed.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript中字面量的详解。</p><a id="more"></a><h3 id="什么是字面量"><a href="#什么是字面量" class="headerlink" title="什么是字面量"></a>什么是字面量</h3><p>字面量(literal)表示如何表达这个值，一般除去表达式，给变量赋值时，等号右边都可以认为是字面量</p><p>字面量</p><ul><li>字符串字面量</li><li>数组字面量</li><li>对象字面量</li><li>函数字面量</li></ul><p>示例：<code>let str = “hello world”;</code> <code>&quot;hello world&quot;</code> 就是字符串字面量，<code>str</code> 是变量名。</p><p><strong>字面量，简单理解，就是不用 <code>JavaScript</code> 的 <code>new</code> 操作符创建实例。</strong></p><h3 id="什么是对象字面量"><a href="#什么是对象字面量" class="headerlink" title="什么是对象字面量"></a>什么是对象字面量</h3><p><code>js</code> 创建对象的两种方式</p><ul><li>标准创建对象方式(<code>new</code>)</li><li>对象字面量创建方式</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准创建对象方式(new)</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.a = <span class="string">"aaa"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// &gt; "aaa"</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象字面量创建方式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">"aaa"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// &gt; "aaa"</span></span><br></pre></td></tr></table></figure><h3 id="对象字面量的特性"><a href="#对象字面量的特性" class="headerlink" title="对象字面量的特性"></a>对象字面量的特性</h3><ol><li><p>这种对象不是一个构造函数，不能使用 <code>new</code> 进行实例化</p></li><li><p>它是引用类型，也就意味着对象名是一个指针，当你把对象名赋值给另一个变量时，你在新变量上所做的任何操作都会影响源对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">"aaa"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = obj;</span><br><span class="line">b.b = <span class="string">"bbb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">// &gt; "bbb"</span></span><br></pre></td></tr></table></figure></li><li><p>对象中的所有成员默认是公开的，如果想实现私有成员，只能采用ES6的 <code>Symbol</code> 来定义一个成员名，然后采用 <code>export</code> 模块化来达到隔离效果</p></li></ol><h3 id="测试字面量赋值效率"><a href="#测试字面量赋值效率" class="headerlink" title="测试字面量赋值效率"></a>测试字面量赋值效率</h3><p>在Chrome上做了对比：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"测试1"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"测试1"</span>); <span class="comment">// &gt; 测试1: 0.256103515625ms</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"测试2"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"测试2"</span>); <span class="comment">// &gt; 测试2: 0.6318359375ms</span></span><br></pre></td></tr></table></figure><p><strong>原因为：</strong> <code>{}</code> 是字面量，可以立即求值，而 <code>new Object()</code> 本质上是方法（只不过这个方法是内置的）调用，既然是方法调用，就涉及到在 <code>proto</code> 链中遍历该方法，当找到该方法后，又会生成方法调用调用必须的堆栈信息，方法调用结束后，还要释放该堆栈。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>字面量</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-数组遍历对比</title>
    <url>/archives/df1d3395.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript中数组的遍历方法，及性能对比。</p><a id="more"></a><h3 id="运行效率对比："><a href="#运行效率对比：" class="headerlink" title="运行效率对比："></a>运行效率对比：</h3><ul><li>测试浏览器为：MicroSoft Edge (Chrome Version: 83.0)</li><li>前置数组：<code>var arr = [1, 2, 3,..., 999999, 1000000];</code></li></ul><table><thead><tr><th align="center">遍历方法</th><th align="left">测试代码</th><th>测试耗时(十次取平均)</th></tr></thead><tbody><tr><td align="center">for</td><td align="left"><code>for(let i = 0, len = arr; i &lt; len; i++){}</code></td><td>1.9915ms</td></tr><tr><td align="center">forEach</td><td align="left"><code>arr.forEach((item, index, arr) =&gt; {})</code></td><td>10.9488ms</td></tr><tr><td align="center">map</td><td align="left"><code>arr.map((item, index, arr) =&gt; {})</code></td><td>15.6615ms</td></tr><tr><td align="center">for…in…</td><td align="left"><code>for(let key in arr){}</code></td><td>172.8816ms</td></tr><tr><td align="center">for…of…</td><td align="left"><code>for(let item of arr){}</code></td><td>12.7118ms</td></tr><tr><td align="center">filter</td><td align="left"><code>arr.filter(item =&gt; {})</code></td><td>15.5326ms</td></tr><tr><td align="center">every</td><td align="left"><code>arr.every(item =&gt; {})</code></td><td>0.021ms</td></tr><tr><td align="center">some</td><td align="left"><code>arr.some(item =&gt; {})</code></td><td>13.5862ms</td></tr><tr><td align="center">reduce</td><td align="left"><code>arr.reduce((total, currentValue, currentIndex, arr) =&gt; {})</code></td><td>10.9067ms</td></tr><tr><td align="center">find</td><td align="left"><code>arr.find(item =&gt; {});</code></td><td>13.7206ms</td></tr><tr><td align="center">findIndex</td><td align="left"><code>arr.findIndex(item =&gt; {})</code></td><td>13.5396ms</td></tr></tbody></table><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><ul><li><p>最简单的一种循环遍历方法，使用频率也是最高。一般使用优化策略：将变量的长度缓存起来，避免重复获取数组的长度。</p></li><li><p>可以使用关键字 <code>break</code>：终止循环，<code>continue</code>：跳过本次循环，<code>return</code>：返回所在函数。</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ARR = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = ARR.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ARR[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &gt; a b c</span></span><br></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><ul><li><p>对数组进行遍历循环，对数组中的每一个项运行给定函数。</p></li><li><p>参数是 <code>function</code> 类型。第一个参数是数组里的元素，第二个参数为数组里元素的索引，第三个参数为数组本身。</p></li><li><p>不能使用 <code>break</code>、<code>continue</code>、<code>return</code> 等关键字终止或跳出循环。</p></li><li><p>这个方法没有返回值。</p></li><li><p>改变的是原数组。</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ARR = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">ARR.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &gt; a b c</span></span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li>“映射”功能，对数组中的每一项运行给定函数，并返回每次函数调用的结果组成的数组。</li><li>参数是 <code>function</code> 类型。第一个参数是数组里的元素，第二个参数为数组里元素的索引，第三个参数为数组本身。(和 <code>forEach</code> 一致)。</li><li>不改变原数组，相当于对原数组拷贝一份，并修改。与原数组的长度一致。</li><li>高阶函数。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ARR = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = ARR.map(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`item-<span class="subst">$&#123;item&#125;</span>`</span>; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(ARR); <span class="comment">// &gt; ['a', 'b', 'c']</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// &gt; ['item-a', 'item-b', 'item-c']</span></span><br></pre></td></tr></table></figure><h3 id="for-in…"><a href="#for-in…" class="headerlink" title="for..in…"></a>for..in…</h3><ul><li>变量数组，返回每一项的数组索引。</li><li>一般不使用在数组遍历中，更多的使用在对象的遍历中。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ARR = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> key <span class="keyword">in</span> ARR) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &gt; 0 1 2</span></span><br></pre></td></tr></table></figure><h3 id="for…of…"><a href="#for…of…" class="headerlink" title="for…of…"></a>for…of…</h3><ul><li>ES6新增。对数组中的每一项进行处理。</li><li>可以使用关键字 <code>break</code>：终止循环，<code>continue</code>：跳过本次循环，<code>return</code>：返回所在函数。</li><li>可以遍历所有可迭代的数据结构，比如数组、类数组对象、字符串等。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ARR = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">of</span> ARR) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &gt; a b c</span></span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ul><li>遍历数组，过滤出符合条件的元素并返回一个新数组。</li><li>不改变原数组，相当于对原数组拷贝一份，并修改。但是只返回符合条件的项，所以与原数组的长度可能不一致。</li><li>高阶函数。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ARR = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = ARR.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="string">"b"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ARR); <span class="comment">// &gt; ['a', 'b', 'c']</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// &gt; ['c']</span></span><br></pre></td></tr></table></figure><h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><ul><li>对数组中的每一项运行给定函数，如果函数中每一项都符合函数条件，即为true，则返回 <code>true</code> ，否则返回 <code>false</code>。</li><li>不改变原数组。</li><li>高阶函数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ARR = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> bool = ARR.every(<span class="function"><span class="params">item</span> =&gt;</span> item &lt; <span class="string">"d"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ARR); <span class="comment">// &gt; ['a', 'b', 'c']</span></span><br><span class="line"><span class="built_in">console</span>.log(bool); <span class="comment">// &gt; true</span></span><br></pre></td></tr></table></figure><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><ul><li>对数组中的每一项运行给定函数，如果函数中只要至少有一项符合函数条件，即为true，则返回 <code>true</code> ，否则返回 <code>false</code>。</li><li>不改变原数组。</li><li>高阶函数。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ARR = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> bool = ARR.some(<span class="function"><span class="params">item</span> =&gt;</span> item &lt; <span class="string">"b"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ARR); <span class="comment">// &gt; ['a', 'b', 'c']</span></span><br><span class="line"><span class="built_in">console</span>.log(bool); <span class="comment">// &gt; true</span></span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><ul><li>接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</li><li>可以作为高阶函数，用于函数的compose。</li><li>对于空数组是不会执行回调函数的。</li><li>高阶函数。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ARR = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> result = ARR.reduce(<span class="function">(<span class="params">total, currentValue</span>) =&gt;</span> total + currentValue);</span><br><span class="line"><span class="built_in">console</span>.log(ARR); <span class="comment">// &gt; ['a', 'b', 'c']</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &gt; abc</span></span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul><li>返回数组中符合测试函数条件的第一个元素的值，否则返回 <code>undefined</code>。</li><li>对于空数组，函数是不会执行的。</li><li>不改变原数组。</li><li>高阶函数。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ARR = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> result = ARR.find(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="string">"b"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ARR); <span class="comment">// &gt; ['a', 'b', 'c']</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &gt; b</span></span><br></pre></td></tr></table></figure><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h3><ul><li>返回数组中符合测试函数条件的第一个元素的值索引值，否则返回 <code>-1</code></li><li>对于空数组，函数是不会执行的。</li><li>不改变原数组。</li><li>高阶函数。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ARR = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> result = ARR.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="string">"b"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ARR); <span class="comment">// &gt; ['a', 'b', 'c']</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &gt; 1</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-对象属性</title>
    <url>/archives/27b30017.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要详细记录JavaScript中的对象属性：命名属性、数据属性、访问器属性、内部属性。</p><a id="more"></a><h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><h3 id="对象属性类型"><a href="#对象属性类型" class="headerlink" title="对象属性类型"></a>对象属性类型</h3><ul><li>命名属性 - 可直接通过 <code>.</code> 访问到的属性</li><li>数据属性 - 专门保存一个值的属性</li><li>访问器属性 - 保护数据属性的特殊属性，不实际存储数据</li><li>内部属性 - 不能通过 <code>.</code> 直接访问的属性，比如 <code>class</code>、<code>__proto__</code></li></ul><h3 id="涉及的属性方法"><a href="#涉及的属性方法" class="headerlink" title="涉及的属性方法"></a>涉及的属性方法</h3><ul><li><code>Object.getOwnPropertyDescriptor(obj, &quot;属性名&quot;)</code>：获取指定属性的描述（必须是自有属性，不适用于原型链的属性）</li><li><code>Object.defineProperty(obj, &quot;属性名&quot;, {特性})</code>：在指定对象上添加新属性或修改属性，如果是新增且为指定特性，则会将数据属性的默认值全部设为 <code>false</code></li></ul><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性的4大特性</p><ul><li><code>configuable</code>：是否可配置，表示能否通过 <code>delete</code> 删除属性，默认为 <code>true</code></li><li><code>enumerable</code>： 是否可枚举，表示能够通过 <code>for-in</code> 循环返回属性，默认为 <code>true</code></li><li><code>value</code>：包含这个属性的数据值</li><li><code>writable</code>：是否可读写，表示能否修改属性的值，默认为 <code>true</code></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">'zi jun'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"name"</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	configurable: true,</span></span><br><span class="line"><span class="comment">	enumberable: true,</span></span><br><span class="line"><span class="comment">	value: "zi jun",</span></span><br><span class="line"><span class="comment">	writable: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"name"</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	configurable: true,</span></span><br><span class="line"><span class="comment">	enumberable: true,</span></span><br><span class="line"><span class="comment">	value: "zi jun",</span></span><br><span class="line"><span class="comment">	writable: false</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><div class="note warning"><p>在正常模式下，<code>delete</code> 一个 <code>configurable</code> 为 <code>false</code> 的变量或对象，不会报错，只是会删除不成功。而在“严格模式”下，则会报错。</p></div><div class="note warning no-icon"><p>针对变量对象，在“严格模式”下：</p><ul><li><p>如果是用 <code>var</code> 声明的，可以理解为在 <code>window</code> 对象上定义了这个属性，可以利用 <code>Object.getOwnPropertyDescriptor(obj, &quot;属性名&quot;)</code> 查看可配置特性，查看是否可删除。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">'a'</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    configurable: false,</span></span><br><span class="line"><span class="comment">    enumerable: true,</span></span><br><span class="line"><span class="comment">    value: 1,</span></span><br><span class="line"><span class="comment">    writable: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure></li><li><p>如果是用ES6+的 <code>let</code> / <code>const</code> 声明的，不能删除，如何理解？</p></li></ul></div><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性的4大特性</p><ul><li><code>get</code>：函数或 <code>undefined</code>，在取属性值时被调用 <code>getter</code> 访问器</li><li><code>set</code>：函数或 <code>undefined</code>，在设置属性值时被调用 <code>setter</code> 访问器</li><li><code>enumerable</code>：是否可枚举，表示能够通过 <code>for-in</code> 循环返回属性，默认为 <code>true``value</code>：包含这个属性的数据值</li><li><code>configuable</code>：是否可配置，表示能否通过 <code>delete</code> 删除属性，默认为 <code>true</code></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    _name: <span class="string">'zi jun'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    <span class="keyword">set</span>: function(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = <span class="string">"new name: "</span> + value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person._name); <span class="comment">// &gt; "zi jun"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &gt; "My name is zi jun"</span></span><br><span class="line">person.name = <span class="string">"Devin"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &gt; My name is new name: Devin</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-防抖节流</title>
    <url>/archives/a635d2be.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript的防抖和节流。</p><a id="more"></a><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>防抖确保了一个函数只有在一个固定的时间段内没有被调用过后，才会被调用。比如说只有在1毫秒过后，才允许执行这个函数。</p><p><strong>换句话说：防抖会等待事件不再高频触发，再触发。</strong></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay &#123;number&#125; 等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn &#123;Function&#125; 需执行函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">delay, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn(...args);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>节流限制了一个函数可以在短时间内被调用的次数。比如说在1毫秒内最多执行此函数1次。</p><p><strong>换句话说：节流会忽略在短时间内高频发生的事件，只按照计划好的频率触发。</strong></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay &#123;number&#125; 计划好的执行间隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn &#123;Function&#125; 需执行函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params">delay, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastCall = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> NOW = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</span><br><span class="line">        <span class="keyword">if</span>(NOW - lastCall &lt; delay) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastCall = NOW;</span><br><span class="line">        <span class="keyword">return</span> fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>防抖在我们关心高频事件发生过后，得到的那个结果的时候，比较有用，比如用户迅速输入完一串用户名，对其进行查重的结果</li><li>节流在我们不关心函数参数是什么的时候比较有用，比如鼠标移动，滚轮事件，我们在乎的是操作的频率</li></ul><h3 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h3><ul><li><p>防抖(<code>debounce</code>)</p><ul><li>Search搜索联想，用户在不断输入值时，用防抖来节约请求资源</li><li>Window触发Resize的时候，不断调整浏览器窗口大小会不断触发这个事件，用防抖让其只触发一次</li></ul></li><li><p>节流(<code>throttle</code>)</p><ul><li>验证码在指定时间内只发送一次</li><li>监听滚动事件，比如是否滑到底部自动加载更多</li></ul></li></ul><h3 id="为什么要用闭包"><a href="#为什么要用闭包" class="headerlink" title="为什么要用闭包"></a>为什么要用闭包</h3><p>如果页面只需要处理一个防抖/节流函数，不需要闭包也是可以实现的，可以将变量变成全局变量，比如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个防抖处理</span></span><br><span class="line"><span class="keyword">let</span> timer</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">delay, fn</span>) </span>&#123;</span><br><span class="line">        timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn(...args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样处理会出现如下问题：</p><ol><li>对于一个页面上需要多个防抖函数的时候，需要写很多重复代码</li><li>全局变量污染作用域</li></ol><p>这时候闭包的优势就体现出来了，保护全局作用域不被污染，又能做到函数复用。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-隐式转换</title>
    <url>/archives/db8c76a2.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript中 <code>valueOf</code> 和 <code>toString</code> 的隐式调用。</p><a id="more"></a><p>记录本篇主要是在高阶函数中的函数柯里化案例中，涉及到了函数返回结果重写了 <code>toString</code> 函数。具体的代码案例可见 <a href="/archives/af81bd5c.html">链接</a>。下面一步步解析。</p><h3 id="JavaScript的对象"><a href="#JavaScript的对象" class="headerlink" title="JavaScript的对象"></a>JavaScript的对象</h3><p><code>JavaScript</code> 中多有的变量都可以当作对象使用，除了2个例外：<code>null</code> 和 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'hello'</span>.toString(); <span class="comment">// =&gt; "hello"</span></span><br><span class="line"><span class="literal">false</span>.toString(); <span class="comment">// =&gt; "false"</span></span><br><span class="line"><span class="number">2.</span>toString(); <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="literal">null</span>.toString(); <span class="comment">// Uncaught TypeError: Cannot read property 'toString' of null</span></span><br><span class="line"><span class="literal">undefined</span>.toString(); <span class="comment">// Uncaught TypeError: Cannot read property 'toString' of undefined</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].toString(); <span class="comment">// =&gt; "1, 2"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">say.toString(); <span class="comment">// =&gt; "function say() &#123;&#125;"</span></span><br></pre></td></tr></table></figure><p>注意以上，<code>null</code> 和 <code>undefined</code> 不能作为对象使用，所以不能使用对象的公共方法，报错。但是 <code>number</code> 类型也报错了，其实这是一个误解！这是因为 <code>JavaScring</code>解析器的一个错误，它试图将点操作符解析为浮点数字面量的一部分。以下这样写就没问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>).toString(); <span class="comment">// =&gt; "2" 2先被计算</span></span><br><span class="line"><span class="number">2.</span>.toString(); <span class="comment">// =&gt; "2" 注意点好前面的空格</span></span><br><span class="line"><span class="number">2</span> .toString(); <span class="comment">// =&gt; "2" 第二个点号可以正常解析</span></span><br></pre></td></tr></table></figure><h3 id="隐式转换的调用"><a href="#隐式转换的调用" class="headerlink" title="隐式转换的调用"></a>隐式转换的调用</h3><p>每个对象都有 <code>toString</code> 和 <code>valueOf</code> 这两个函数，且都可以被改写，每个对象执行完毕，如果被用以操作 <code>JavaScript</code> 解析器就会自动调用对象的这两个方法。<br><code>toString</code> 和 <code>valueOf</code> 这两个函数，是解释器用来帮助我们自动完成类型之间的转换（一般是对象到基本类型的转换），进而输出令我们满意的结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  i: <span class="number">10</span>,</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"执行了valueOf"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.i + <span class="number">20</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"执行了toString"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueOf() + <span class="number">20</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">alert(obj); <span class="comment">// 50 执行了toString 执行了valueOf</span></span><br><span class="line">alert(+obj); <span class="comment">// 30 执行了valueOf</span></span><br><span class="line">alert(obj &gt; <span class="number">40</span>); <span class="comment">// false 执行了valueOf</span></span><br><span class="line">alert(obj == <span class="number">30</span>); <span class="comment">// true 执行了valueOf</span></span><br><span class="line">alert(obj === <span class="number">30</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>由上面可以看出，虽然我们没有调用 <code>obj</code> 的任何方法，但是要使用 <code>obj</code> 进行操作时，JS解析器自动帮我们调用了其 <code>toString</code> 或 <code>valueOf</code> 方法。</p><div class="note warning"><p>最后一个未输出任何字符串，是因为：JS解析器直接先判断类型是否一样，明显一个是Object，一个是Number，所以直接不相等，不需要再去求值了。</p></div><p>那么何时调用 <code>toString</code>，何时调用 <code>valueOf</code> 呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  i: <span class="number">10</span>,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"执行了toString"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.i;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">alert(a); <span class="comment">// 10 执行了toString</span></span><br><span class="line">alert(+a); <span class="comment">// 10 执行了toString</span></span><br><span class="line">alert(<span class="string">""</span> + a); <span class="comment">// 10 执行了toString</span></span><br><span class="line">alert(<span class="built_in">String</span>(a)); <span class="comment">// 10 执行了toString</span></span><br><span class="line">alert(<span class="built_in">Number</span>(a)); <span class="comment">// 10 执行了toString</span></span><br><span class="line">alert(a == <span class="string">"10"</span>); <span class="comment">// true 执行了toString</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">  i: <span class="number">10</span>,</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"执行了valueOf"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.i;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">alert(b); <span class="comment">// 10 [object Object]</span></span><br><span class="line">alert(+b); <span class="comment">// 10 执行了valueOf</span></span><br><span class="line">alert(<span class="string">""</span> + b); <span class="comment">// 10 执行了valueOf</span></span><br><span class="line">alert(<span class="built_in">String</span>(b)); <span class="comment">// 10 [object Object]</span></span><br><span class="line">alert(<span class="built_in">Number</span>(b)); <span class="comment">// 10 执行了valueOf</span></span><br><span class="line">alert(b == <span class="string">"10"</span>); <span class="comment">// true 执行了valueOf</span></span><br></pre></td></tr></table></figure><div class="note warning no-icon"><ul><li>需要转换为字符串时，会调用 <code>toString</code> 且 <code>toString &gt; valueOf</code> 需要转换为数字时，会调用 <code>valueOf</code> 且 <code>valueOf &gt; toString</code></li><li>如果只重写了 <code>toString</code>，对象转换时会无视 <code>valueOf</code> 的存在，来进行转换</li><li>在不能调用 <code>toString</code> 的情况下，只能让 <code>valueOf</code>上阵</li><li>对象在作为操作数（加减乘除、比较运算）时，解释器优先调用 <code>valueOf</code>，而其他情况，解释器总是认为我们想要的是字符串，所以会优先调用 <code>toString</code></li></ul></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ToString</tag>
        <tag>ValueOf</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-Node浏览器事件循环机制</title>
    <url>/archives/1e61d9e.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录Node和浏览器中事件循环机制的区别。</p><a id="more"></a><h3 id="Node-js运行机制"><a href="#Node-js运行机制" class="headerlink" title="Node.js运行机制"></a>Node.js运行机制</h3><p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎。而I/O处理方面使用了自己设计的Libuv，Libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。</p><ul><li>V8引擎解析JavaScript脚本</li><li>解析之后的代码调用Node API</li><li>Libuv库负责Node API的执行，它将不同的任务分配给不同的线程，形成一个Event Loop，以异步的方式将任务的执行结果返回给V8引擎</li><li>V8引擎再将结果返回给用户</li></ul><h3 id="Libuv中的6个阶段"><a href="#Libuv中的6个阶段" class="headerlink" title="Libuv中的6个阶段"></a>Libuv中的6个阶段</h3><p>Libuv引擎中的事件循环分为6个阶段，它们按顺序反复执行。每当进入某个阶段，都会从对应的回调队列中取出函数执行。当队列为空或者执行的回调函数数量达到系统设定的阈值，就会进入下一阶段。</p><p>Node中事件循环顺序：外部输入数据 -&gt; 轮询阶段（poll） -&gt; 检查阶段（check） -&gt; 关闭事件回调阶段（close callback） -&gt; 定时器检测阶段（timer） -&gt; I/O事件回调阶段（I/O callback） -&gt; 闲置阶段（idle，prepare） -&gt; 轮询阶段 …</p><p><img data-src="../../assets/20200605165008.png" alt=""></p><h3 id="Node与浏览器的事件循环差异"><a href="#Node与浏览器的事件循环差异" class="headerlink" title="Node与浏览器的事件循环差异"></a>Node与浏览器的事件循环差异</h3><ul><li><p>浏览器环境下，microtask的任务队列是每个macrotask执行完成之后执行。</p></li><li><p>而在node.js中，microtask会在事件循环的各个阶段之间执行，也就是说，每一个阶段执行完毕，就会去执行microtask队列中的任务。</p><p><img data-src="../../assets/20190911192413535.png" alt=""></p></li></ul><p>举例说明：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>对于浏览器：</strong></p><p>浏览器端的处理过程如下：执行第一个宏任务时，输出同步代码timer1之后，发现微任务then(),执行微任务输出promise1；接着执行第二个宏任务，输出同步任务timer2，发现微任务，执行微任务，输出promise2。即：timer1 -&gt;promise1-&gt;timer2-&gt;promise2。浏览器端的处理过程如下：</p><p><img data-src="../../assets/20190911193801966.gif" alt=""></p><p><strong>Node情况分两种：</strong></p><ul><li>如果是node11版本，与浏览器执行结果一样</li><li>如果是node10及以下：要看第一个定时器执行完，第二个定时器是否在完成队列中。<ul><li>如果是第二个定时器还未在完成队列中，最后的结果为 timer1=&gt;promise1=&gt;timer2=&gt;promise2</li><li>如果是第二个定时器已经在完成队列中，则最后的结果为timer1=&gt;timer2=&gt;promise1=&gt;promise2(下文过程解释基于这种情况下)。</li></ul></li></ul><p>1.全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行；<br>2.首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；<br>3.至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2<br>node端执行过程：</p><p><img data-src="../../assets/20200205200105105.gif" alt=""></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-回流重绘</title>
    <url>/archives/1ae5dc8a.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录页面的回流和重绘，以及相关优化。</p><a id="more"></a><h3 id="浏览器渲染大致流程"><a href="#浏览器渲染大致流程" class="headerlink" title="浏览器渲染大致流程"></a>浏览器渲染大致流程</h3><p>浏览器解析文档（JS、CSS、HTML）的流程图，可见 <a href="/archives/8bab0c48.html">链接</a></p><p>其大致过程为：</p><ol><li>浏览器请求到HTML文档后，将HTML解析并构建DOM树（DOM Tree）</li><li>处理CSS，解析成CSS样式规则（CSS Style Rules）</li><li>结合DOM树和CSS样式规则构建渲染树（Render Tree）</li><li>浏览器计算Render Tree中每个渲染对象的位置和大小，即布局（Layout）- 回流</li><li>最后进行绘制（Painting），根据回流得到的信息结合渲染树，渲染展示 - 重绘</li></ol><h3 id="回流（reflow）"><a href="#回流（reflow）" class="headerlink" title="回流（reflow）"></a>回流（reflow）</h3><p>当元素的规模尺寸、布局、隐藏等改变，而导致渲染树（Render Tree）的一部分或全部重新构建，浏览器重新渲染的过程称为回流。每个页面至少会进行一次回流，就在页面第一次加载的时候。</p><p>触发回流：</p><ul><li>页面首次渲染</li><li>添加或删除可见的DOM元素， 比如元素的 <code>display</code> 属性</li><li>元素的位置、尺寸发生改变（包括外边距、内边框、边框大小、高度、宽度等）</li><li>元素内容发生变化（文字数量或者图片大小）</li><li>元素字体大小改变</li><li>浏览器的窗口尺寸变化</li><li>激活CSS伪类（比如::hover）</li></ul><h3 id="重绘（repaint）"><a href="#重绘（repaint）" class="headerlink" title="重绘（repaint）"></a>重绘（repaint）</h3><p>当渲染树（Render Tree）中的一些元素需要更新属性，这些属性只影响元素的外观、风格（e.g. <code>color</code>，<code>background</code>），并不影响布局，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">document</span>.body.style;</span><br><span class="line">s.padding = <span class="string">"2px"</span>; <span class="comment">// 回流+重绘</span></span><br><span class="line">s.border = <span class="string">"1px solid red"</span>; <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line">s.color = <span class="string">"blue"</span>; <span class="comment">// 再一次重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">"#ccc"</span>; <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.fontSize = <span class="string">"14px"</span>; <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'abc!'</span>)); <span class="comment">// 添加node，再一次 回流+重绘</span></span><br></pre></td></tr></table></figure><div class="note warning no-icon"><p>回流必将引起重绘，而重绘并一定会引起回流。</p></div><h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3><p>回流和重绘非常影响Web性能，因为每一次HTML和CSS的重新解析然后再构建成渲染树（Render Tree），都需要经过大量的计算，这个过程是很耗时间耗性能的。以下是针对减少回流和重绘的优化方案：</p><ol><li>不要直接使用JS操作DOM元素的样式，选择用一个class代替</li><li>如果要操作DOM,尽量将需要改变DOM的操作一次完成</li><li>不要使用table 布局，因为table 的每一个行甚至每一个单元格的样式更新都会导致整个table 重新布局</li><li>减少DOM的深度，可以减少解析器耗时</li><li>尽量简化CSS</li><li>复杂的动画，可以使其元素脱离文档流，使用 <code>position:absolute</code> 或者 <code>position:fixed</code>，以减少对父元素的影响</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端优化-性能优化</title>
    <url>/archives/47836f53.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录前端的一些优化处理技巧的整理，比如如何快速渲染大量图片，如何提高页面加载速度等。</p><a id="more"></a><p>前端性能的一个重要指标就是页面加载时间，前端优化主要围绕提高加载速度进行。</p><p><img data-src="../../assets/20200610181332-1591784460323.png" alt=""></p><h3 id="页面级内容优化"><a href="#页面级内容优化" class="headerlink" title="页面级内容优化"></a>页面级内容优化</h3><ol><li><strong>减少HTTP请求数。</strong>Web前端80%的响应时间花在图片，样式，脚本等资源下载上。最直接的方式是减少页面所需资源，但不现实。所以，减少HTTP请求数是主要途径。以下从 减少一部分请求 -&gt; 不用请求，分别说明：<ul><li><strong>合并HTTP请求资源</strong><ul><li><strong>针对文件 - 合并JS/CSS文件。</strong>比如服务端PHP的压缩应用：Minify，它会合并多个CSS或者JavaScript文件，移除一些不必要的空格和注释，进行gzip压缩，并且会设置浏览器的缓存头。在前端框架Vue中，Webpack同样具有类似功能。</li><li><strong>针对图片 - 使用图片精灵。</strong>将小的图片合并在一张图片之中，通过 <code>background-image</code> 和 <code>background-position</code> 控制显示。</li><li><strong>针对图片 - 使用行内图片（Base64编码）处理。</strong>对于较小的图片，可以转换为base64格式，vue中可以配置此项，一般大小限制为10KB左右。因为较大图片会导致转化较慢，还就是base64没有缓存，每次都需要重新反复请求。</li><li><strong>针对图片 - 懒加载。</strong>对于图片量比较大的而言，浏览到哪图片加载到哪是最好的显示效果，可以大大提高首屏的加载时间。</li><li><strong>懒加载资源（减少当前屏/首屏的HTTP请求）。</strong>如果上面的图片懒加载，其他资源也是可以懒加载的，比如Vue中的懒加载路由处理。</li></ul></li><li><strong>不用HTTP请求</strong><ul><li><strong>针对图片 - 使用Iconfont替代。</strong>比如可以使用阿里的iconfont字体图标库，下载在本地，可以替代小的图片。</li></ul></li><li><strong>设置数据缓存</strong><ul><li><strong>设置HTTP缓存。</strong>通过设置HTTP头的缓存设置，可以减少HTTP请求。具体的可以看 <a href="/archives/bff68fd9.html">链接</a>。</li><li><strong>设置数据缓存。</strong>通过浏览器本地设置sessionStorage或localStorage来存储一些数据，减少不必要的请求。</li></ul></li></ul></li><li><strong>较少DNS查询。</strong>DNS(Domain Name System)。用户输入URL之后，浏览器首先要查询域名（hostname）对应服务器的IP地址，一般需要耗费20-120毫秒的时间。DNS查询查找完成之前，浏览器无法从服务器下载任何数据。浏览器DNS缓存有效期一般为1分钟左右。减少不同的主机名的数量会减少DNS查询，但是也会减少页面并行下载资源的数量，即会增加了响应时间。原则是把组件分散到2-4个主机名下，这是同时减少DNS查询和运行高并发下载的折中方案。</li><li><strong>减少DOM数量。</strong>DOM数量直接回影响浏览器引擎渲染的速度（虽然这个过程会比较快），JavaScript DOM操作也会更慢，但是减少DOM数量也会提高页面的渲染速度。</li><li><strong>减少Iframe的使用。</strong>Iframe的使用会使得页面的加载代价昂贵，通常Iframe加载的开销比普通DOM div高1-2个数量级。还有Iframe会阻塞onload事件（虽然可以动态赋值src解决）。</li><li><strong>预加载。</strong>预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。一般在HTML中 <code>&lt;head&gt;&lt;/head&gt;</code> 标签内设置。比如：<code>&lt;link rel=&#39;preload&#39; href=&quot;image.png&quot;&gt;</code>。具体的可以查看 <a href="/archives/10b3b1eb.html">链接</a></li><li><strong>适当使用异步请求。</strong>对于独立的数据请求，避免同步接口的阻塞性，可以使用异步请求同步并行请求。</li><li><strong>尽量减少回流和重绘。</strong>回流会导致布局改变从而需要页面重新构建，渲染，影响性能。而重绘只会渲染局部，不需要整个页面重新渲染。</li><li><strong>避免重定向。</strong>客户端收到服务器的重定向响应后，会根据响应头中Location的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。</li><li><strong>避免404错误。</strong>HTTP请求很昂贵，返回无效的响应（如404未找到）完全没必要，降低用户体验而且毫无益处。</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端优化-预加载</title>
    <url>/archives/10b3b1eb.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录前端预加载技术。</p><a id="more"></a><p>当我们谈到前端的性能时，总是会提到比如合并、压缩、缓存或者在服务器上开启gzip之类，目的都是为了让页面加载更快。更多的前端性能优化，可见 <a href="/archives/47836f53.html">链接</a>。</p><p>资源预加载（prefetch）则是另一种性能优化的技术。Pre-fetching会提示浏览器那些未来一定或可能使用到的资源，有时在当前页面见效，有些则在未来可能打开的页面生效。但是这并不是一种单一的技术，实际上可以拆分成很多小点：</p><ul><li><p><strong>DNS-prefetch</strong></p><p>通过指定具体的URL来告知客户端未来会用到相关的资源，这样浏览器可以尽早地解析DNS。比如我们需要一个在example.com的图片或者视频文件，可以这样设置：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//example.com"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Preconnect</strong></p><p>和DNS prefetch类似，Preconnect不仅会解析DNS，还会建立TCP握手连接和TLS协议（如果需要）。用法如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"//example.com"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Prefetch</strong></p><p>当能确定网页在未来一定会使用到某个资源时，可以让浏览器提前请求并且缓存好供后续使用。它的作用是告诉浏览器加载下一页面可能会用到的资源，注意，是下一页面，而不是当前页面。Prefetch支持预拉取图片、脚本或者任何可以被浏览器缓存的资源。用法如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"image.png"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Prerender</strong></p><p>它可以让浏览器提前加载指定页面的所有资源。Prerender就像是在后台打开了一个隐藏的Tab，会下载所有的资源、创建DOM、渲染页面、执行JS等。如果用户进入指定的链接，隐藏的这个页面就会立即进入用户的视线。</p></li><li><p><strong>Preload</strong></p><p>它提供了一种声明式的命令，让浏览器提前加载指定资源(加载后并不执行)，需要执行时再执行。它不会阻塞Lloaded事件的触发。通常应用场景为加载font字体。用户如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"fonts/cicle_fina-webfont.woff"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"bg-image-narrow.png"</span> <span class="attr">as</span>=<span class="string">"image"</span> <span class="attr">media</span>=<span class="string">"(max-width: 600px)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"bg-image-wide.png"</span> <span class="attr">as</span>=<span class="string">"image"</span> <span class="attr">media</span>=<span class="string">"(min-width: 601px)"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>rel=preload</code> 声明这是一个preload</li><li><code>href</code> 指明资源的位置</li><li><code>as</code> 指明资源类型，这是为了让浏览器精确设置优先级，设置正确的Accept头部</li><li><code>crossorigin</code> 指定使用的跨域设置</li><li><code>media</code> 指定媒体查询</li></ul></li></ul><div class="note warning no-icon"><p>Preload和Prefetch的区别：</p><table><thead><tr><th></th><th align="center">preload</th><th align="center">prefetch</th></tr></thead><tbody><tr><td>语法</td><td align="center"><code>&lt;link rel=&quot;preload&quot; href=&quot;img.png&quot;&gt;</code></td><td align="center"><code>&lt;link rel=&quot;prefetch&quot; href=&quot;img.png&quot;&gt;</code></td></tr><tr><td>使用场景</td><td align="center">本页面接下来大概率要使用的资源</td><td align="center">下个页面的资源，下个页面很可能会去访问</td></tr><tr><td>加载时间</td><td align="center">立即加载（一般而言，跟as有关）</td><td align="center">浏览器闲置的时候才会加载（一般而言）</td></tr></tbody></table></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>预加载</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-高阶函数</title>
    <url>/archives/af81bd5c.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript中的一个少说但是实际经常使用的名词 - 高阶函数。</p><a id="more"></a><h2 id="什么是高阶函数"><a href="#什么是高阶函数" class="headerlink" title="什么是高阶函数"></a>什么是高阶函数</h2><p>参数或是返回值为函数的函数，就称为<strong>高阶函数</strong>。</p><p>换言之，至少满足以下条件之一的函数，都可以成为高阶函数：</p><ol><li>函数可以作为参数被传递</li><li>函数可以作为返回值输出</li></ol><p>常见的高阶函数有：<code>reduce</code>、<code>map</code> 、<code>filter</code>、<code>sort</code> 等函数。</p><h3 id="Function参数"><a href="#Function参数" class="headerlink" title="Function参数"></a>Function参数</h3><p>先看一下函数参数的用法，最经典的案例就是 <code>Array#map</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// &gt; [2, 3, 4]</span></span><br></pre></td></tr></table></figure><h3 id="Function返回值"><a href="#Function返回值" class="headerlink" title="Function返回值"></a>Function返回值</h3><p>返回值是函数的函数，我们也经常使用，最著名的就是 <code>Function#bind</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> func = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.call(context, ...args, ...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> helloD = sayHello.myBind(&#123;<span class="attr">name</span>: <span class="string">'Devin'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(helloD()); <span class="comment">// &gt; Hello, Devin</span></span><br></pre></td></tr></table></figure><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>柯里化，就是先给原始函数传入几个参数，他会生成一个新的函数，然后让新的函数去处理接下来的参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的add函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryAdd</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// =&gt; 3</span></span><br><span class="line">curryAdd(<span class="number">1</span>)(<span class="number">2</span>); <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><p>实际上就是把 <code>add</code> 函数的 <code>x, y</code> 两个参数变成了先用一个函数接受 <code>x</code>，然后返回一个函数去处理 <code>y</code> 参数。</p><h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><p>实现一个 <code>add</code> 方法，使计算结果能够满足如下预期：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// =&gt; 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>); <span class="comment">// =&gt; 10</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>); <span class="comment">// =&gt; 15</span></span><br></pre></td></tr></table></figure><p><strong>普通函数</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// &gt; 6</span></span><br></pre></td></tr></table></figure><p><strong>柯里化函数（最简单的一种）</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// &gt; 6</span></span><br></pre></td></tr></table></figure><p><strong>进阶</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第一次执行，定义一个数组用来存储所有的参数，只执行第一次！</span></span><br><span class="line">  <span class="keyword">let</span> _args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 利用闭包的特性保存_args并收集所有的参数值，非第一次</span></span><br><span class="line">  <span class="keyword">let</span> _add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    _args.push(...arguments);</span><br><span class="line">    <span class="keyword">return</span> _add;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">  _add.toString = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> _add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// &gt; f 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>)); <span class="comment">// &gt; f 10</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)); <span class="comment">// &gt; f 15</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次执行，定义一个变量存储所有的参数之和，只执行第一次！</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = args.length; i &lt; len; i++) &#123;</span><br><span class="line">        res += args[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非第一次执行，定义一个闭包，处理剩余所有参数</span></span><br><span class="line">    <span class="keyword">let</span> ret = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = args.length; i &lt; len; i++) &#123;</span><br><span class="line">            res += args[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数的属性（隐式转换）,自定义输出内容</span></span><br><span class="line">    ret.toString = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// &gt; f 6</span></span><br></pre></td></tr></table></figure><p><strong>toString()函数的隐式转换</strong></p><p>为什么上面输出的是 <code>f 6</code> ，而不是 <code>6</code> ？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add + <span class="number">10</span>); <span class="comment">// &gt; function add() &#123;return 20;&#125;10</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">add.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add + <span class="number">10</span>); <span class="comment">// &gt; 20</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">add.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">add.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add + <span class="number">10</span>); <span class="comment">// &gt; 15</span></span><br></pre></td></tr></table></figure><div class="note warning no-icon"><ul><li>需要转换为字符串时，会调用 <code>toString</code>，需要转换为数字时，会调用 <code>valueOf</code>，更多的 <code>toString</code> 方法可见 <a href="/archives/db8c76a2.html">链接</a></li><li>当我们没有重新定义 <code>toString</code> 与 <code>valueOf</code> 方法时，函数的隐式转换会调用默认的 <code>toString</code> 方法，它会将函数的定义内容作为字符串返回</li><li>当我们主动定义了 <code>toString/valueOf</code> 方法时，那么隐式转换的返回结果则由我们自己控制了</li><li>在输出结果为数字的情况下，<code>valueOf</code> 会比 <code>toString</code> 后执行</li><li>柯里化函数涉及了3个技术点<ul><li>闭包</li><li>高阶函数</li><li>隐式转换</li></ul></li></ul></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>高阶函数</tag>
      </tags>
  </entry>
  <entry>
    <title>前端正则-正则基础</title>
    <url>/archives/bfcd137d.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录正则表达式的基础。</p><a id="more"></a><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><p>正则表达式就是处理字符串的，也可以用它来处理一些复杂的字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出这个字符串中的所有数字</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'abc123de45fgh6789ijk0'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+/g</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)); <span class="comment">// &gt; ["123", "45", "6789", "0"]</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式的创建方式"><a href="#正则表达式的创建方式" class="headerlink" title="正则表达式的创建方式"></a>正则表达式的创建方式</h2><p>创建正则表达式有两种方式：</p><ul><li>字面量创建方式（常用方式）： <code>const reg = /pattern/flags;</code></li><li>实例创建方式: <code>const reg = new RegExp(parttern, flags);</code></li></ul><p>其中 <code>pattern</code> 为正则表达式，<code>flags</code> 为标识（修饰符）。</p><p>其中修饰符有3中：</p><ul><li><code>i</code>: 忽略大小写匹配</li><li><code>g</code>: 全局匹配，应用于所有字符串，而非在找到第一个匹配项时停止</li><li><code>m</code>: 多行匹配，到达一行文本末尾时不停止，继续下一行匹配</li></ul><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p><strong>代表特殊含义的元字符</strong></p><ul><li><code>\d</code>: 0-9之间的任意数字，<code>\d</code>只占一个位置</li><li><code>\w</code>: 数字，字母，下划线 0-9，a-z，A-Z</li><li><code>\s</code>: 空格或者空白</li><li><code>\D</code>: 除了数字</li><li><code>\W</code>: 除了数字，除了字母，除了下划线</li><li><code>\S</code>: 除了空格，除了空白</li><li><code>\n</code>: 匹配换行符</li><li><code>.</code>: 处理换行符的任意一个字符</li><li><code>\</code>: 转义字符</li><li><code>|</code>: 或者</li><li><code>()</code>: 分组</li><li><code>^</code>: 限定开始位置，本身不占用位置</li><li><code>$</code>: 限定结束位置，本身不占位置</li><li><code>[a-z]</code>: 任意字母，<code>[]</code>表示任意一个</li><li><code>[^a-z]</code>: 非字母， <code>[]</code> 中 <code>^</code>表示除了</li><li><code>[abc]</code>: abc三个字母中的任何一个</li><li><code>[^abc]</code>: 除了abc这三个字母中的任何一个字符</li></ul><p><strong>代表次数的量词元字符</strong></p><ul><li><code>*</code>: 0到多个</li><li><code>+</code>: 1到多个</li><li><code>?</code>: 0次或者1次，可有可无</li><li><code>{n}</code>: 正好n次</li><li><code>{n,}</code>: n到多次</li><li><code>{n, m}</code>: n到m次</li></ul><div class="note warning no-icon"><ul><li>量词出现在元字符后面，如 <code>\d+</code>， 表示限定出现在前面的元字符的次数</li><li>一般 <code>[]</code> 中的字符没有特殊含义</li><li><code>()</code>具有提高优先级的功能，凡是有 <code>|</code> 出现的时候，我们一定需要 <code>()</code> 来提高优先级</li></ul></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'1223334444'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d&#123;2&#125;/g</span>; <span class="comment">// 限定元字符的量级</span></span><br><span class="line"><span class="keyword">const</span> res = str.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &gt; ["12", "23", "33", "44", "44"]</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'  我这里是空格  '</span>;</span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/^\s+|\s+$/g</span>;</span><br><span class="line"><span class="keyword">const</span> res2 = str2.replace(reg2, <span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// &gt; 我这里是空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般[]中的字符没有特殊含义</span></span><br><span class="line"><span class="keyword">const</span> str1 = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'dbc'</span>;</span><br><span class="line"><span class="keyword">const</span> str3 = <span class="string">'.bc'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/[ab.]bc/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str1)); <span class="comment">// &gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)); <span class="comment">// &gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str3)); <span class="comment">// &gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配18-65年龄段</span></span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/(18|19)|[2-5]\d|6[0-5]/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg2.test(<span class="number">66</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ()提高优先级</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'aaabbb'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/(a+)(?:b+)/</span>;</span><br><span class="line"><span class="keyword">const</span> res = str.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &gt; ["aaabbb", "aaa", index: 0, input: "aaabbb", groups: undefined]</span></span><br></pre></td></tr></table></figure><h2 id="正则的特性"><a href="#正则的特性" class="headerlink" title="正则的特性"></a>正则的特性</h2><ul><li>贪婪性：所谓的贪婪性就是正则在捕获时，每一次会尽可能多的去捕获符合条件的内容。如果我们想尽可能的少去捕获符合条件的字符串的话，可以在量词元字符后加 <code>?</code></li><li>懒惰性：懒惰性则是正则在成功捕获一次后不管后面的字符串有没有符合条件的，都不再捕获。如果要捕获目标中所有符合条件的字符串，可以用标识符 <code>g</code> 标明全局捕获</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'123aa456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+/</span>; <span class="comment">// 懒惰性：只捕获一次，贪婪性：一次尽可能多的捕获</span></span><br><span class="line"><span class="keyword">const</span> res = str.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &gt; ["123", index: 0, input: "123aa456", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/\d+/g</span>; <span class="comment">// 解决懒惰性，但有贪婪性</span></span><br><span class="line"><span class="keyword">const</span> res2 = str.match(reg2);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// &gt; ["123", "456"]</span></span><br><span class="line"><span class="keyword">const</span> reg3 = <span class="regexp">/\d+?/</span>; <span class="comment">// 解决贪婪性，但有懒惰性</span></span><br><span class="line"><span class="keyword">const</span> res3 = str.match(reg3);</span><br><span class="line"><span class="built_in">console</span>.log(res3); <span class="comment">// &gt; ["1", index: 0, input: "123aa456", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reg4 = <span class="regexp">/\d+?/g</span>; <span class="comment">// 解决贪婪性、懒惰性</span></span><br><span class="line"><span class="keyword">const</span> res4 = str.match(reg4);</span><br><span class="line"><span class="built_in">console</span>.log(res4); <span class="comment">// &gt; ["1", "2", "3", "4", "5", "6"]</span></span><br></pre></td></tr></table></figure><h2 id="正则的相关方法"><a href="#正则的相关方法" class="headerlink" title="正则的相关方法"></a>正则的相关方法</h2><ol><li><code>reg.test(str)</code>: 验证字符串是否符合正则，符合返回 <code>true</code>， 否则返回 <code>false</code></li><li><code>reg.exec(str)</code>: 用来捕获符合规则的字符串</li><li><code>str.match(reg)</code>: 如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返 <code>null</code></li><li><code>str.replace(reg)</code>: 替换字符串</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reg.test(str)</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\w+/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)); <span class="comment">// &gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reg.exec(str)</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'abc123cba456aaa789'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str)); <span class="comment">// &gt; ["123", index: 3, input: "abc123cba456aaa789", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// str.match(reg)</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'abc123cba456aaa789'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)); <span class="comment">// &gt; ["123", "456", "789"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// str.replace(reg)</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'a111bc222de'</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+/g</span>;</span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/\d/g</span>;</span><br><span class="line"><span class="keyword">const</span> res = str.replace(reg, <span class="string">'?'</span>);</span><br><span class="line"><span class="keyword">const</span> res2 = str.replace(reg2, <span class="string">'?'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &gt; a?bc?de</span></span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// &gt; a???bc???de</span></span><br></pre></td></tr></table></figure><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>用于查找在某些内容（但不包括这些内容）之前或之后的东西，这个位置应该满足一定的条件（即断言），因此也被称为零宽断言。</p><ul><li>零宽度正预测先行断言 <code>(?=exp)</code> 字符出现的位置的右边必须匹配到exp这个表达式</li><li>零宽读负预测先行断言 <code>(?!exp)</code> 字符出现的位置的右边不能是exp这个表达式</li><li>零宽度正回顾后发断言 <code>(?&lt;=exp)</code> 字符出现的位置的前边是exp这个表达式</li><li>零宽度负回顾后发断言 `(? 字符出现的位置的前边不是exp这个表达式</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (?=exp)</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"i'm singing and dancing"</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\w+(?=ing)/g</span>;</span><br><span class="line"><span class="keyword">const</span> res = str.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &gt; ["sing", "danc"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (?!exp)</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'nodejs'</span>;</span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/node(?!js)/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg2.test(str2)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (?&lt;=exp) </span></span><br><span class="line"><span class="keyword">const</span> str3 = <span class="string">'￥998$888'</span>;</span><br><span class="line"><span class="keyword">const</span> reg3 = <span class="regexp">/(?&lt;=\$)\d+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str3.match(reg3)); <span class="comment">// &gt; ["888"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (?&lt;!exp)</span></span><br><span class="line"><span class="keyword">const</span> str4 = <span class="string">'￥998$888'</span>;</span><br><span class="line"><span class="keyword">const</span> reg4 = <span class="regexp">/(?&lt;!\$)\d+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str4.match(reg4)); <span class="comment">// &gt; ["998", "88"]</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>正则</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>Anywhere本地静态服务</title>
    <url>/archives/f1c4558.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录本地服务的开启，anywhere的使用，类似有live-server。</p><a id="more"></a><h2 id="开启本地静态服务"><a href="#开启本地静态服务" class="headerlink" title="开启本地静态服务"></a>开启本地静态服务</h2><ol><li><code>npm install anywhere -g</code> ， 全局安装 <code>anywhere</code></li><li>cmd键入到要启动静态服务的目录</li><li><code>anywhere</code> 或者 <code>anywhere -p 7890</code> 启动静态服务</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Windows</category>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Anywhere</tag>
        <tag>静态服务</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Cmd命令</title>
    <url>/archives/fd31ce3.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录cmd常用的一些命令。</p><a id="more"></a><h2 id="常用Cmd命令"><a href="#常用Cmd命令" class="headerlink" title="常用Cmd命令"></a>常用Cmd命令</h2><ul><li><code>dir</code> 查看当前文件夹下的文件及文件夹</li><li><code>cd</code> 切换目录/文件</li><li><code>cd file</code> 进入当前文件夹下的file文件夹</li><li><code>cd fold1/fold2</code> 或者 <code>cd fold1\fold2</code> 进入多层文件夹</li><li><code>cd ..</code> 进入上一层文件夹</li><li><code>cd ../folder</code> 进入上一层文件夹中的folder文件夹</li><li><code>mkdir myfolder</code> 或 <code>md myfolder</code> 在当前目录下创建myfolder文件夹</li><li><code>type nul &gt; my.txt</code> 创建空白的my.txt文件</li><li><code>echo content &gt; test1.py</code> 创建内容是content的my.txt文件</li><li><code>type test1.py</code> 查看在当前目录下的test1.py文件内容，把内容打印到cmd中</li><li><code>test1.py</code> 直接输入文件名，用默认程序打开此文件（相当于鼠标双击）</li><li><code>ren oldname newname</code> 重命名</li><li><code>del test1.py</code> 删除文件</li><li><code>del myfolder</code> 删除myfolder文件夹中的所有文件（文件夹保留）</li><li><code>rd myfolder</code> 或者 <code>rmdir myfolder</code> 删除myfolder文件夹</li><li><code>tree myfolder</code> 将myfolder文件夹下的所有文件夹展示成树状结构（不展示文件）</li><li><code>tree myfolder /f</code> 展示文件夹及文件树状结构</li><li><code>tree myfolder /f &gt; my.txt</code> 将结果输出到my.txt文件中（新建的文件）</li><li><code>cls</code> 清屏</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Windows</category>
        <category>Cmd</category>
      </categories>
      <tags>
        <tag>Cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>Live-Server本地静态服务</title>
    <url>/archives/eb7f8542.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录本地服务的开启，live-server的使用，类似有anywhere。</p><a id="more"></a><h2 id="开启本地静态服务"><a href="#开启本地静态服务" class="headerlink" title="开启本地静态服务"></a>开启本地静态服务</h2><ol><li><code>npm install live-server -g</code> ， 全局安装 <code>live-server</code></li><li>cmd键入到要启动静态服务的目录</li><li><code>live-server</code> 或者 <code>live-server --port=7876</code> 启动静态服务</li></ol><div class="note info"><p>live-server 对比 anywhere ：live-serve 支持热更新，而anywhere则需要手动刷新。</p></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Windows</category>
        <category>Server</category>
      </categories>
      <tags>
        <tag>静态服务</tag>
        <tag>Live-Server</tag>
      </tags>
  </entry>
  <entry>
    <title>前端优化-浏览器解析调试</title>
    <url>/archives/8bab0c48.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录网页性能-浏览器解析HTML、CSS、JavaScript的过程记录。</p><a id="more"></a><h3 id="最简单的页面"><a href="#最简单的页面" class="headerlink" title="最简单的页面"></a>最简单的页面</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"stack.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开浏览的调试控制台，查看瀑布：</p><p><img data-src="../../assets/20200616153608.png" alt=""></p><p><img data-src="../../assets/20200616154431.png" alt=""></p><p><img data-src="../../assets/20200616154213.png" alt=""></p><ol><li><strong>浅蓝色条</strong>标识浏览器从发起请求到接收服务器返回第一个字节的时间，即 请求等待 时间(TTFB)：46毫秒。</li><li><strong>深蓝色条</strong>标识真正的HTML页面的下载时间，即 内容下载 时间：2毫秒。</li><li><strong>紫色虚线矩形</strong>表示浏览器下载完成HTML之后开始构建DOM，当发现第一个DOM标签（<code>&lt;image&gt;</code>）时所花费的时间。由此可见：DOM的顺序执行的，当发现 <code>&lt;image&gt;</code> 时便立即发起请求。</li><li><strong>绿色（浅绿色+深绿色）</strong>条标识 <code>&lt;image&gt;</code> 发起请求时等待到下载图片所消耗的时间：417毫秒。</li><li><strong>蓝色竖线</strong>所处的时间为DOMContentLoaded，即DOM内容加载完成或者说浏览器解析完文档的时间：170毫秒。它的触发不需要等待图片等其他资源加载完成。</li><li><strong>红色竖线</strong>所处的时间为Load，即页面所有资源加载完成的时间：532毫秒。</li></ol><h3 id="含有CSS的页面"><a href="#含有CSS的页面" class="headerlink" title="含有CSS的页面"></a>含有CSS的页面</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"my-style.css"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"stack.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开浏览的调试控制台，查看瀑布：</p><p><img data-src="../../assets/20200616162103.png" alt=""></p><ol><li><strong>蓝色竖线</strong>位于<strong>紫色条</strong>之后，说明DOMContentLoaded，即解析完文档必须等待CSS解析完成。也就是构建DOM树必须等待CSS解析完成。</li><li><strong>紫色条</strong>和<strong>绿色条</strong>开始的时间几乎相同，说明 <code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> DOM位于相同层级的DOM。</li></ol><h3 id="浏览器解析流程图"><a href="#浏览器解析流程图" class="headerlink" title="浏览器解析流程图"></a>浏览器解析流程图</h3><p><img data-src="../../assets/20200616183434.png" alt=""></p><h3 id="含有JavaScript和CSS的页面"><a href="#含有JavaScript和CSS的页面" class="headerlink" title="含有JavaScript和CSS的页面"></a>含有JavaScript和CSS的页面</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"my-style.css"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"stack.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"changeImgSize.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开浏览的调试控制台，查看瀑布：</p><p><img data-src="../../assets/20200616165254.png" alt=""></p><ol><li>由于JavaScript代码可能会更改CSS属性或者是DOM的结构，所以在形成Render Tree之前必须等待JavaScript解析完成才能接着构建Render Tree。</li><li>将 Javascript 放在 <code>head</code> 内和 <code>body</code> 底部的区别也在于此，放在 <code>head</code> 里面，由于浏览器发现 <code>head</code> 里面有 Javascript 标签就会暂时停止其他渲染行为，等待 Javascript 下载并执行完成才能接着往下渲染，而这个时候由于在 <code>head</code> 里面这个时候页面是白的，如果将 Javascript 放在页面底部，RenderTree 已经完成大部分，所以此时页面有内容呈现，即使遇到 Javascript 阻塞渲染，也不会有白屏出现。</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>当浏览器从服务器接收到了 HTML 文档，并把 HTML 在内存中转换成 DOM 树，在转换的过程中如果发现某个节点 (node) 上引用了 CSS 或者 IMAGE，就会再发 1 个 request 去请求 CSS 或 image, 然后继续执行下面的转换，而不需要等待 request 的返回，当 request 返回 后，只需要把返回的内容放入到 DOM 树中对应的位置就 OK。但当引用了 JS 的时候，浏览器发送 1 个 js request 就会一直等待该 request 的返回。因为浏览器需要 1 个稳定的 DOM 树结构，而 JS 中很有可能有代码直接改变了 DOM 树结构，浏览器为了防止出现 JS 修改 DOM 树，需要重新构建 DOM 树的情况，所以 就会阻塞其他的下载和呈现。</p><ol><li>在 <code>&lt;head&gt;</code> 里尽量不要引入JavaScript。</li><li>如果要在 <code>&lt;head&gt;</code> 引入JavaScript，尽量将JavaScript内嵌。</li><li>把内嵌 <code>JavaScript</code> 放在所有CSS的前面。</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端正则-常用正则整理</title>
    <url>/archives/94c6a923.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要了常用的正则表达式，便于工作查询。</p><a id="more"></a><h2 id="校验数字"><a href="#校验数字" class="headerlink" title="校验数字"></a>校验数字</h2><ol><li>大于等于0的整数：<code>/^\d+$/</code></li><li>大于等于1的整数：<code>/^[1-9]\d*$/</code>·····1</li><li>大于等于2的整数：<code>/^([1-9]\d+|[2-9])$/</code></li><li>大于0（包括小数）：<code>/^(?!(0[0-9]{0,}$))[0-9]{1,}[.]{0,}[0-9]{0,}$/</code></li><li>大于等于0（包括小数）：<code>/^([0-9]+(\.\d+)?|0\.\d+)$/</code></li></ol><h2 id="校验字符"><a href="#校验字符" class="headerlink" title="校验字符"></a>校验字符</h2><ol><li>中文：<code>/[\u4E00-\u9FA5]/</code></li><li>英文和数字：<code>/^[A-Za-z0-9]+$/</code></li><li>数字、26个英文字母或者下划线组成：<code>^\w+$</code></li></ol><h2 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h2><ol><li>超链接：<code>/http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&amp;=]*)?/</code></li><li>身份证号码：<code>/^([0-9]){7,18}(x|X)?$/</code></li><li>用户名（只能包括数字、字母、下划线，4-12位）：<code>/^[a-zA-z]\w{3,11}$/</code></li><li>密码（只能包括数字、字母、下划线，6-12位）：<code>/^[a-zA-z]\w{5,11}$/</code></li><li>手机号码：<code>/^1\d{10}$/</code></li><li>座机号码：<code>/^0\d{2,3}-?\d{7,8}$/</code></li><li>邮箱：<code>/^(\w-*\.*)+@(\w-?)+(\.\w{2,})+$/</code></li><li>微信号：<code>/^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/</code></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>正则</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue集成1-生成项目</title>
    <url>/archives/c373e9aa.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录Vue项目基于 <code>Vue</code> + <code>Vant</code> 的二次集成及优化。以便开箱即用。</p><a id="more"></a><h3 id="安装Vue"><a href="#安装Vue" class="headerlink" title="安装Vue"></a>安装Vue</h3><p>具体的安装可以参照 <a href="https://cli.vuejs.org/zh/guide/" target="_blank" rel="noopener external nofollow noreferrer">官网</a>。</p><ol><li>打开cmd</li><li>安装 <code>Vue-cli</code>：<code>npm install @vue/cli -g</code></li><li>安装 <code>yarn</code>：<code>npm install yarn -g</code>（可以不使用 <code>yarn</code>）</li><li>切换到对应磁盘，以便建立项目：<code>E:</code></li><li>这里以UI形式创建项目：<code>vue ui</code></li><li>创建完成项目、安装依赖：<code>yarn install</code></li></ol><h3 id="集成Vant"><a href="#集成Vant" class="headerlink" title="集成Vant"></a>集成Vant</h3><ol><li><p>安装 <code>vant</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add vant</span><br><span class="line">yarn add babel-plugin-import --dev</span><br></pre></td></tr></table></figure></li><li><p>配置 <code>.babel.config.js</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [<span class="string">"@vue/cli-plugin-babel/preset"</span>],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"import"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        libraryName: <span class="string">"vant"</span>,</span><br><span class="line">        libraryDirectory: <span class="string">"es"</span>,</span><br><span class="line">        style: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"vant"</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="集成Rem"><a href="#集成Rem" class="headerlink" title="集成Rem"></a>集成Rem</h3><ol><li><p>安装插件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add postcss-pxtorem --dev</span><br><span class="line">yarn add amfe-flexible</span><br></pre></td></tr></table></figure></li><li><p><code>main.js</code> 引入：<code>import “amfe-flexible”</code></p></li><li><p>修改(新建) <code>post.config.js</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    autoprefixer: &#123;</span><br><span class="line">      overrideBrowserslist: [</span><br><span class="line">        <span class="string">"Android 4.1"</span>,</span><br><span class="line">        <span class="string">"iOS 7.1"</span>,</span><br><span class="line">        <span class="string">"Chrome &gt; 31"</span>,</span><br><span class="line">        <span class="string">"ff &gt; 31"</span>,</span><br><span class="line">        <span class="string">"ie &gt;= 8"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"postcss-pxtorem"</span>: &#123;</span><br><span class="line">      rootValue: <span class="number">37.5</span>,</span><br><span class="line">      propList: [<span class="string">"*"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Vue</category>
        <category>集成</category>
      </categories>
      <tags>
        <tag>集成</tag>
      </tags>
  </entry>
  <entry>
    <title>读《启示录-打造用户喜爱的产品》</title>
    <url>/archives/f9d474c3.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录阅读《启示录-打造用户喜爱的产品》一书的重点笔记。</p><a id="more"></a><p>打造一款成功产品的十条规律：</p><ol><li><p>产品经理的任务是探索产品的价值、可用性、可行性。</p></li><li><p>探索（定义）产品需要产品经理、交互设计师、软件架构师的通力合作。</p></li><li><p>开发人眼不擅长用户体验设计，因为开发人员脑子里想的是实现模型，而用户看重的是产品的概念模型。</p></li><li><p>用户体验设计就是交互设计、视觉设计。</p></li><li><p>功能（产品需求）和用户体验设计密不可分。</p></li><li><p>产品创意必须尽早的、反复的接受目标用户的试用，以便获取有效的用户体验。</p></li><li><p>为了验证产品的价值和可用性，必须尽早的、反复的请目标用户测试产品创意。</p></li><li><p>采用高保真的产品原型是全体团队成员了解用户需求和用户体验最有效的途径。</p></li><li><p>产品经理的目标是在最短的时间内把握复杂的市场、用户需求，确定产品的基本要求-价值、可用性、可行性。</p></li><li><p>一旦认定产品符合以上基本要求，它就是一个完整的概念，去掉任何因素，都不可能达到预期结果。</p></li></ol><h2 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h2><p>人员是指负责定义和开发产品的团队成员的角色和职责。</p><h3 id="界定产品经理和产品营销人员的职责"><a href="#界定产品经理和产品营销人员的职责" class="headerlink" title="界定产品经理和产品营销人员的职责"></a>界定产品经理和产品营销人员的职责</h3><ul><li>产品经理负责详细定义待开发的产品，让真实的用户测试产品</li><li>产品营销负责向外宣传和推广产品，负责产品发布，为扩展市场销售渠道、组织营销活动、醋精产品销售提供服务</li><li>营销人员是产品经理获取产品需求的重要来源，产品经理是营销人眼获取市场营销信息的重要来源</li></ul><h3 id="界定产品管理和项目管理"><a href="#界定产品管理和项目管理" class="headerlink" title="界定产品管理和项目管理"></a>界定产品管理和项目管理</h3><ul><li>产品管理的职责是探索（定义）有价值的、可用的、可行的产品</li><li>项目管理则关注如何执行计划以按期交付产品</li></ul><h3 id="优秀项目经理的七个特点"><a href="#优秀项目经理的七个特点" class="headerlink" title="优秀项目经理的七个特点"></a>优秀项目经理的七个特点</h3><ul><li>工作紧迫感。可以传递给大家工作的积极性和高效性。</li><li>善于捕捉问题。迅速的、准确的指出问题要害，改善会议效果。</li><li>思路清晰。需要排除排期冲突，日程中断等因素，专注执行时间和效率。</li><li>用数据说话。懂得利用数据识别项目方向，确认项目进度，改善开发流程。</li><li>果断。及时向团队收集数据和建议，适时向上级汇报，帮助大家有问题利用数据做出决策。</li><li>判断力。何时催促进度，何时向上级汇报，何时收集更多信息。</li><li>态度。不能为可行性、资源不足，时间不够，资金匮乏等找借口，必须自己克服。</li></ul><h3 id="产品经理与软件开发"><a href="#产品经理与软件开发" class="headerlink" title="产品经理与软件开发"></a>产品经理与软件开发</h3><ul><li>只有与开发团结融洽合作，才有可能开发出合格的产品</li><li>形成合作关系的关键是双方承认平等-任何一方不从属于另一方</li><li>开发可以帮助产品经理完善产品定义，因为开发最清楚产品设计的可行性</li><li>开发帮助产品经理完善产品定义的3种方式<ul><li>让开发人员直接面对用户或顾客，比如要求开发人员参加产品原型测试</li><li>项开发人员了解最新的技术发展动向，讨论哪些新技术可以应用于产品</li><li>在产品的初期阶段，让开发参与产品评估，协助策划方案</li></ul></li><li>产品经理配合开发人员的3条建议<ul><li>只定义满足基本要求的产品，然后更多的与开发之间形成良好的互动</li><li>一旦进入开发阶段，尽可能避免修改产品的需求</li><li>开发阶段如果遇到诸多问题，比如，用例丢失，设计缺陷等，应迅速在维持产品基本功能，尽量避免修改的原则上，拿出解决方案</li></ul></li><li>与开发团结合作应该遵循的规则：预留余量（20%）的自主时间。在产品管理上为开发团队预留20%的自主时间，让他们自由支配。开发团结可以利用这些时间重写代码、完善架构、重构代码库中有缺陷的部分，提高系统性能，避免“需要停下来重写代码”的情形发生。</li></ul><h3 id="产品经理必须成长的技能"><a href="#产品经理必须成长的技能" class="headerlink" title="产品经理必须成长的技能"></a>产品经理必须成长的技能</h3><ul><li>时间管理。熟练，迅速的区分重要任务和紧急任务，合理的规划和安排时间</li><li>对产品的热情。如果是你，你打算怎样完善自己最喜欢的产品</li><li>运用技术的能力。多学习和理解技术，并适时运用于产品当中</li><li>沟通技能。头口表达和书面表达。条理清晰，言简意赅。演讲推荐：《演讲致胜：讲故事的一书》</li><li>商业知识面。技术讨论、成本结构、边际效应、市场份额、产品定位和品牌等</li><li>学习思路：研发产品之前，需要学习哪些知识，需要多长时间，如何利用这些知识</li></ul><h3 id="产品总监"><a href="#产品总监" class="headerlink" title="产品总监"></a>产品总监</h3><ul><li>建设产品团队。注意要雇佣比自己聪明的人，团队成员的出色表现就是自己的出色表现</li><li>规划公司的产品战略。产品总监要负责制定产品组合路线图，兼顾用户需求和商业目标，从全局出发制定产品发布计划</li></ul><h3 id="产品经理的目标管理"><a href="#产品经理的目标管理" class="headerlink" title="产品经理的目标管理"></a>产品经理的目标管理</h3><ul><li>永远不要告诉别人怎么做。告诉他们做什么，他们自然会发挥天赋，给你惊喜</li><li>留给用户体验设计师和开发人员的空间越大，他们就越有可能打造出用户喜爱的产品</li></ul><h3 id="管理上司的几条经验"><a href="#管理上司的几条经验" class="headerlink" title="管理上司的几条经验"></a>管理上司的几条经验</h3><ol><li>为项目波动做好准备。提高警惕，记录工作进度。指定项目计划时，预留出时间应对变化和调整，做好“做无用功”的心理准备</li><li>注意沟通的方式和频率。有写人喜欢用邮件、聊天软件或是口头汇报，弄清上司的喜好，对症下药</li><li>会前沟通。组织好会议的诀窍是在正式会议召开前充分沟通，也就是逐一向高管和上司确认你的观点和建议，确保会议取得大家的一致意见，确保会议的高效率性</li><li>多提建议，少谈问题。管理者希望听到解决问题的方法，而不是抱怨。所以在提出问题的同时，并附上你的依据和建议</li><li>向上司借力。把想法告诉上司，让上司向高管传达建议</li><li>充分准备。在思路和计划上的漏洞多做思考做到事无巨细</li><li>多用数据和事实说话。多做准备工作，收集事实和数据，才有说服力</li></ol><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>流程是指探索、开发富有创意的产品时，反复应用的步骤和成功的实践经验。</p><h3 id="评估产品机会"><a href="#评估产品机会" class="headerlink" title="评估产品机会"></a>评估产品机会</h3><ol><li>产品要解决什么问题？（产品价值）</li><li>为谁解决这个问题？（目标市场）</li><li>成功的机会有多大？（市场规模）</li><li>怎样判断产品成功与否？（度量指标或收益指标）</li><li>有哪些同类产品？（竞争格局）</li><li>为什么我们适合做这个产品？（竞争优势）</li><li>时机合适吗？（市场时机）</li><li>如何把产品推向市场？（营销组合策略）</li><li>成功的必要条件是什么？（解决方案要满足的条件）</li><li>根据以上问题，给出评估结论。（继续或放弃）</li></ol><h3 id="软件项目的两个阶段"><a href="#软件项目的两个阶段" class="headerlink" title="软件项目的两个阶段"></a>软件项目的两个阶段</h3><ol><li>探索产品。弄清楚要开发什么产品，定义正确的产品。重心在分析各种创意，收集用户需求，运用新技术等</li><li>执行产品。开发该产品，正确的开发产品。重心在于执行-开发、测试、发布</li></ol><p>采用流水线方式并行开发产品。也就是说，一旦1.0版本的产品进入项目执行阶段，就开始定义2.0版本的产品。一旦前一个版本进入开发阶段，就把创造的热情投入到下一个版本中，这个版本可以收集上一个版本的问题，遗漏或建议等</p><h3 id="产品说明文档"><a href="#产品说明文档" class="headerlink" title="产品说明文档"></a>产品说明文档</h3><p>产品经理的核心责任是确保向开发团队交付具有成功潜力的产品说明文档。</p><p>理想的产品说明文档：</p><ol><li>产品说明文档应该完整地描述用户体验。不只是用户需求，还包括交互设计和视觉设计。</li><li>产品说明文档必须准确地描述软件的行为。文字和图片尽可能表达。</li><li>产品说明文档的直观化。由于受众较广，需要直接表现。</li><li>产品说明文档应该可以修改。开发阶段，总有意想不到的情况出现，需要修改说明文档以适应新情况。</li><li>产品说明文档，应该逻辑清晰，条理清晰，以主线或模块划分。</li></ol><p>只有一种形式的产品说明文档可以满足上述要求，那就是 <strong>高保真原型</strong>。</p><h3 id="用户体验设计"><a href="#用户体验设计" class="headerlink" title="用户体验设计"></a>用户体验设计</h3><p>敏捷方法里有个概念叫 “第零次迭代”，产品经理和用户体验设计师利用这段时间先完成产品设计工作，然后交由开发人员开始迭代开发。</p><h3 id="产品设计方式"><a href="#产品设计方式" class="headerlink" title="产品设计方式"></a>产品设计方式</h3><ol><li>产品经理与设计师合作设计产品的高保真原型。这个原型只具备实现商业目标的最基本的功能要求，以及良好的用户体验和吸引力。只设计基本功能的产品可以把复杂度降到最低，把开发时间减到最少。</li><li>邀请以为开发人员（比如架构师或主程序员）参与设计原型。请他检查原型，帮助产品经理和设计师估算各种功能的直接成本和间接成本，指出设计上的误区，并分析、评估尚不确定是否可行的功能。</li><li>请真实用户验证（测试）产品原型，这一点至关重要。在产品团队全力开发产品前，产品经理和设计师必须确信产品是用户需要的。</li></ol><h3 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h3><ul><li>创新不是发现新的问题，而是用新方法解决已有的问题。观察人们对现有产品的不满，是创新的最佳途径。</li><li>20%法则。用20%的工作时间来从事创新研究。</li></ul><h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><p>产品是指富有创意的产品具有的鲜明特征。</p><h3 id="苹果公司的产品启示"><a href="#苹果公司的产品启示" class="headerlink" title="苹果公司的产品启示"></a>苹果公司的产品启示</h3><ul><li>硬件为软件服务。与其他硬件公司不同，苹果公司明白硬件必须为软件服务，这种关系不能颠倒。软件直接服务用户，满足用户需求。</li><li>软件为用户体验服务。苹果公司的所有工作都围绕着产品的可用性、交互设计、视觉设计、工业设计展开。</li><li>用户体验为情感服务。他们比谁都清楚是什么让消费者为产品疯狂，他们知道怎样抓住用户的情感需求。</li><li>产品为真正的需求服务。手机并非苹果公司首创，但他们挖掘出尚未被满足的用户需求。</li></ul><h3 id="客户需求和产品需求"><a href="#客户需求和产品需求" class="headerlink" title="客户需求和产品需求"></a>客户需求和产品需求</h3><p>产品需求不能用户说了算，原因如下：</p><ol><li>在看到具体的产品之前，用户很难知道自己需要什么</li><li>用户不知道什么样的产品是可行的（在目前的技术条件下可以实现）</li><li>用户之前缺少沟通，需求很难统一</li></ol><h3 id="新瓶装老酒"><a href="#新瓶装老酒" class="headerlink" title="新瓶装老酒"></a>新瓶装老酒</h3><p>想要在成熟的市场抢占一席之地，精明的公司至少要手握两件“法宝”：</p><ol><li>对目标市场了如指掌，对现有产品的缺陷洞若观火。</li><li>跟踪最新的技术趋势，让之前无法实现的方案变得可能。</li></ol><h3 id="产品情感挖掘"><a href="#产品情感挖掘" class="headerlink" title="产品情感挖掘"></a>产品情感挖掘</h3><p>消费者分类：</p><ol><li>非理性消费者（即尝鲜者）的情感需求与大众的相同，但更为强烈。愤怒、恐惧、孤独这类消极情绪被放大后，会导致非理性消费行为。在生活中，非理性消费者为了满足情感需求，会付出大大超出解决问题本身所需要的精力和成本。</li><li>技术爱好者（即技术创新者）购买产品，仅仅是因为产品采用了新的技术。这类消费者容易误导产品经理。</li><li>普通大众具有和非理性消费者同样的情感需求，只是在程度上没有那么强烈。随着产品的完善，他们也会逐步加入消费者队伍。</li><li>理性消费者只会购买他们认为实用、成熟的产品。他们更务实，只会购买性价比合适的产品。</li><li>观望者（即跟随者）约占总数的15%,他们同样有需求，但只会购买公认好用的产品。</li></ol><p>这几类消费者中，非理性消费者最值得产品经理注意。发现产品的内在价值，比如产品经理可以深入了解他们的想法和感受，就能抓住这种情感需求。</p><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><ul><li>交互设计和视觉设计缺一不可。但大部分团队缺固执地认为只要招聘一位设计师，就能完成这两项工作。</li><li>视觉设计可以满足用户的情感需求。比如：协调的配色、优美的字体、漂亮的布局等</li></ul><h3 id="大众网络服务产品的要点"><a href="#大众网络服务产品的要点" class="headerlink" title="大众网络服务产品的要点"></a>大众网络服务产品的要点</h3><ol><li>可用性。大众网络服务产品必须具有良好的用户体验。比如，页面加载缓慢让用户无法忍受，也是糟糕的用户体验。</li><li>人物角色。用户一旦过多，就应该按典型特征将用户分类。比如，到时测试就可以邀请典型用户参与。</li><li>扩展性。建议开发资源和运维资源预留20% 专门为扩展做好准备。</li><li>持续可用性。比如网络中断，系统故障，在系统设计上最好有相关方案。</li><li>保护用户隐私。</li><li>口碑营销。向推荐产品的用户给予奖励。</li><li>全球化。产品设计之初需要考虑，避免之后开发增加开发成本。</li><li>平滑部署。 逐步过渡，尽量让用户适应缓慢，比如，用户版本可切换，模块逐步重构，等。</li><li>用户社区管理。多用类似“回馈用户”的活动表达对他们的重视。</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>书籍</category>
        <category>产品</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title>读《你不知道的JavaScript(上卷)》</title>
    <url>/archives/3dacf7de.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录阅读《你不知道的JavaScript（上卷）》的一些笔记，主要内容为作用域和闭包、this和原型对象。</p><a id="more"></a><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p><strong>作用域</strong> 用一套设计好的规则来存储变量，并在之后能够方便的找到这些变量，这套规则称之为作用域。</p><p><strong><code>JavaScript</code>的工作原理</strong></p><ul><li><code>JavaScript</code>引擎：从头到尾负责整个 <code>JavaScript</code> 程序的编译及执行过程</li><li><code>JavaScript</code>编译器：负责语法分析及代码生成等<ol><li>分词/词法分析(Tokenizing/Lexing)：这个过程会将字符代码分解为有意义的代码块，这些代码块称为词法单元(token)。例如：<code>var a = 2;</code> , 这段程序会被分解为 <code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>、<code>;</code>。</li><li>语法分析(Parsing)：这个过程是将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个数被称为“抽线语法树”(Abstract Syntax Tree, AST)。</li><li>代码生成()：将 <code>AST</code> 转换为可执行代码，简单来说就是有某种方法可以将 <code>var a = 2;</code> 的 <code>AST</code> 转换为一组机器指令，用来创建一个叫作 <code>a</code> 的变量(包括分配内存等)，并将一个值存储在 <code>a</code> 中。</li></ol></li><li><code>JavaScript</code>作用域：负责收集并维护由所有声明的标识符(变量)组成的一系列查询</li></ul><p><strong>作用域查询规则</strong></p><ul><li>LHS查询(Left Handle Search)：查找的目的是对变量进行赋值会触发（赋值操作的目标是谁，我要赋值了）</li><li>RHS查询(Right Handle Search)：查找的目的是获取变量的值会触发（谁是赋值操作的源头，我要用它）<ul><li>其查询规则为嵌套查询，也就是在当前作用域中没有查找到，引擎就会在外层嵌套中继续查找，直到最外层(全局作用域)为止</li><li>如果没有查找到，严格模式下，会抛出 <code>ReferenceError</code> 错误，非严格模式下，会自动在全局作用域下创建此变量</li><li>如果找到了，但是其之前没有被赋值，那么就会返回 <code>undefined</code></li></ul></li></ul><div class="note warning"><p>对象的属性或方法调用也会触发RHS查询</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure><p>上面代码解析过程如下：</p><ol><li>编译器对上面字符串进行分词、语法分析，然后生成代码</li><li>JS引擎联合作用域开始执行代码<ol><li><code>c</code> 需要被赋值，会触发一次LHS查询，然后需要使用 <code>foo(2)</code> 这个变量的值，这里会触发一次RHS查询</li><li><code>foo(2)</code> 调用过程中，参数赋值会隐式地触发一次 <code>a = 2</code> 的赋值操作，触发一次LHS查询</li><li>进入函数体，<code>var b = a;</code> <code>b</code> 需要被赋值，会触发一次LHS查询，然后需要使用 <code>a</code> 这个变量，这里会触发一次RHS查询，获取值</li><li><code>return a + b;</code> ，这里需要分别获取 <code>a</code> 和 <code>b</code> 这两个变量的值，所以会各自触发一次RHS查询，自此这一步，引擎共计进行了3次LHS查询，4次RHS查询</li></ol></li></ol><p><strong>作用域异常</strong></p><ul><li><code>ReferenceError</code>：作用域判别失败触发，比如在使用变量的时候未找到此变量的创建</li><li><code>TypeError</code>：作用域判别成功了，但是对结果的操作是非法或不合理<ul><li>引用 <code>null</code> 或 <code>undefined</code> 类型值中的属性</li><li>对一个非函数类型的值进行函数调用</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>.a); <span class="comment">// Uncaught TypeError: Cannot read property 'a' of null</span></span><br><span class="line"><span class="built_in">console</span>.log(b()); <span class="comment">// Uncaught TypeError: b is not a function</span></span><br></pre></td></tr></table></figure><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p><strong>作用域共有两种工作模型</strong></p><ul><li>词法作用域（大多数语言采用）</li><li>动态作用域（<code>Bash</code> 脚本、<code>Perl</code> 中的一些模式）</li></ul><p><strong>词法作用域</strong></p><p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里决定的，因此当词法分析器处理代码时会保持作用域不变。</p><p><strong>遮比效应</strong></p><div class="note warning"><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><p>我们要牢牢记住，词法作用域只关注函数在何处被声明，而不是在何处被调用，<code>foo</code> 函数位于全局作用域被声明，所以它对 <code>a</code> 变量的RHS查找当然是在全局作用域中。</p><p><strong>欺骗词法</strong></p><ul><li><code>eval()</code> <code>eval()</code> 函数可以接受一个字符串作为参数，并将里面的内容作为生成代码并执行。在正常模式下，<code>eval()</code> 中的内容中的声明（变量或函数），就会对所处的词法作用域进行修改</li><li><code>with</code> <code>with</code> 通常被当作重复引用同一个对象中的多个属性的快捷键，可以不需要重复引用对象本身</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 单调乏味的重复 obj</span></span><br><span class="line">obj.a = <span class="number">3</span>;</span><br><span class="line">obj.b = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 简单的快捷方式</span></span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning no-icon"><p><code>eval()</code> 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 <code>with</code> 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(obj) &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">    b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">foo(o1);</span><br><span class="line"><span class="built_in">console</span>.log(o1.a); <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line">foo(o2);</span><br><span class="line"><span class="built_in">console</span>.log(o2.a); <span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><p>为什么最后输出2？可以这样理解，当我们传递<code>o1</code>给<code>with</code>时，<code>with</code>所声明的作用域是<code>o1</code>，而这个作用域中含有一个同<code>o1.a</code>属性相符的标识符。但当我们将<code>o2</code>作为作用域时，其中并没有<code>a</code>标识符，因此进行了正常的LHS标识符查找。<code>o2</code>的作用域、<code>foo(..)</code>的作用域和全局作用域中都没有找到标识符<code>a</code>，因此当<code>a = 2</code>执行时，自动创建了一个全局变量（因为是非严格模式）。</p></div><div class="note warning"><p><code>eval()</code> 和 <code>with</code> 这两个可以欺骗词法作用域的机制，会导致 <code>JavaScript</code> 引擎在编译阶段的数项性能优化（基于词法静态分析的优化）失效，最终会导致性能下降。所以，在“严格模式”下，或是日常使用中，禁止使用它们。</p></div><h3 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h3><ul><li>函数内部的全部变量都可以在整个函数范围内使用和复用，函数外部无法访问到这些变量。</li><li>如果想要隐藏内部实现，可以再用一个函数包裹</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    foo(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line">foo(<span class="number">3</span>); <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure><p><strong>函数声明和函数表达式</strong></p><p>区分函数声明和函数表达式最简单的方法是看 <code>function</code> 关键字出现在声明中的位置，如果 <code>function</code> 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>)</span>&#123;&#125;)()</span><br></pre></td></tr></table></figure><div class="note warning"><p>立即执行函数（IIFE [Immedidately Invoked Function Expression]），比如：<code>(function foo(){..})()</code> 第一个 <code>()</code> 将函数变成表达式，第二个 <code>()</code> 执行了这个函数</p></div><p><strong>块作用域</strong></p><p>块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 <code>{..}</code> 内部）</p><ul><li>从ES3开始，<code>try/catch</code> 结构在 <code>catch</code> 分句中具有块作用域</li><li>ES6中， <code>let/const</code> 可以将变量绑定到所在的任意作用域中</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// =&gt; 0, 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码等同</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// =&gt; 0, 1, 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// =&gt; 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，<code>i</code> 会被绑定在 <code>for</code> 循环的外部作用域中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// =&gt; 0, 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码等同</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">let</span> i = j;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// =&gt; 0, 1, 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，<code>for</code> 循环头部的 <code>let</code> 不仅将 <code>i</code> 绑定到了 <code>for</code> 循环中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</p><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><ul><li>函数声明和变量(<code>var</code>)声明都会被提升，但函数会优先被提升，然后才是变量</li><li>提升出现在编译阶段，赋值则是执行阶段的任务</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上面代码第一个示例： <code>var a = 1</code>，<code>JavaScript</code> 实际上会将其看成两个声明 <code>var a;</code>, <code>a = 1;</code></p><ul><li><code>var a;</code> 是在编译阶段进行的</li><li><code>a = 1;</code> 赋值声明会在原地等待执行阶段，才进行处理</li></ul><p>上面代码第二个示例，虽然 <code>var a;</code> 被提升了，但查询 <code>a</code> 比赋值 <code>a</code> 早了一步， 所以输出是 <code>undefined</code></p><p><strong>函数优先</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">// =&gt; "Function"</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Var"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Fucntion"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数声明覆盖</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo(); &#x2F;&#x2F; 2</span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多的详情可见 <code>let</code>、<code>const</code>、<code>function</code>、<code>var</code> 详解，<a href="/archives/71a05d55.html">链接</a></p></blockquote><h3 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h3><h2 id="This和对象原型"><a href="#This和对象原型" class="headerlink" title="This和对象原型"></a>This和对象原型</h2><!-- rebuild by neat -->]]></content>
      <categories>
        <category>书籍</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-三次握手四次挥手</title>
    <url>/archives/19577025.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录TCP建立连接需要三次握手和断开连接需要四次挥手的详解。</p><a id="more"></a><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><ul><li>TCP/IP 不是一个协议，而是一个协议族的统称，里面包含了 IP协议、IMCP协议、TCP协议、HTTP协议、FTP协议、POP3协议等</li><li>IP 用于计算机之间的通信</li><li>TCP 用于应用程序之间的通信，比如客户端与服务端的通信。当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工（full-duplex）的通信。这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</li><li>TCP 赋值将数据分割并装入 IP 包，然后在他们到达的时候重新组合它们。</li><li>IP 负责将包发送至接受者。</li></ul><p>由于 TCP 不存在连接的概念，只存在请求和响应，请求和响应都是数据包，它们之间都是经过由 TCP 创建的一个从客户端发起，服务器接收的类似连接通道，这个连接可以一直保持，HTTP 请求就是在这个连接的基础上发送的。在一个 TCP 连接上是可以发送多个 HTTP 请求的，不同的版本这个模式不一样：</p><ol><li>HTTP/1.0中：这个 TCP 连接是在 HTTP 请求创建的时候同步创建的，HTTP 请求发送到服务器端，服务器端响应了之后，这个 TCP 连接就关闭了；（无需握手）</li><li>HTTP/1.1中，这个 TCP 连接可以以某种方式声明这个连接一直保持，一个请求传输完之后，另一个请求可以接着传输。这样的好处是：在创建一个 TCP 连接的过程中需要“三次握手”的消耗，“三次握手”代表有三次网络传输。之后的请求就无需“三次握手”的消耗；</li><li>HTTP/2.0中，除了可以“三次握手”建立长连接，还可以在同一个 TCP 连接里并发地传输 HTTP 请求</li></ol><div class="note primary"><p>更多的HTTP1.0、HTTP1.1、HTTP2.0区别，可查看 <a href="/archives/63110c3b.html">链接</a></p></div><h2 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h2><p><img data-src="../../assets/20200603170910.png" alt=""></p><ul><li><strong>端口号：</strong>用来标识同一台计算机的不同的应用进程。</li><li><strong>源端口：</strong>源端口和IP地址的作用是标识报文的返回地址。</li><li><strong>目的端口：</strong>端口指明接收方计算机上的应用程序接口。</li><li><strong>序号：</strong><code>Seq</code>序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li><li><strong>确认号：</strong><code>Ack</code>序号，占32位，只有 <code>ACK</code> 标志位为 <code>1</code> 时，确认序号字段才有效，<code>Ack = Seq + 1</code>。</li><li><strong>标志位：</strong>共6个，每一个标志位表示一个控制功能<ul><li><strong>URG：</strong>紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。</li><li><strong>ACK：</strong>确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。<strong>只要有应答连接，就需要置1，并且携带ack确认号。</strong></li><li><strong>PSH：</strong>push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。</li><li><strong>RST：</strong>重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。</li><li><strong>SYN：</strong>同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。<strong>只要有请求建立连接，就需要置为1，并且携带seq序号。</strong></li><li><strong>FIN：</strong>finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</li></ul></li></ul><div class="note warning no-icon"><ol><li>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。</li><li>不要将确认序号Ack与标志位中的ACK搞混了。</li><li>对应关系为：<ul><li>SYN（标志位）　＜－＞　seq（序号）</li><li>ACK（标志位）　＜－＞　ack（确认序号）</li></ul></li><li>报文（数据包）在握手和挥手传输中，都不是同一个报文，而是每一次传输都是一个新的报文。</li></ol></div><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><p><img data-src="../../assets/20200603173928.png" alt=""></p><ol><li>第一次，客户端将标志位SYN（同步序号）置为1（SYN=1），随机产生一个序号值seq=J，并将该数据包发送给到服务器，然后进入到SYN_SEND状态，等待服务器确认。</li><li>第二次，服务器收到数据包后由标志位SYN=1包可知，客户端请求建立连接，为表示同意客户端的请求，将标志位SYN和ACK都置为1，ack=J+1，并随机产生一个序号值seq=K，发送给客户端，然后进入到SYN_RCVD状态，等待客户端确认。</li><li>第三次，客户端确认收到后，检查ack是否为J+1，ACK是否为1，如果正确则将确认标志位置为1，ack=K+1,并将数据包发送给服务器，服务器检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务端则进入ESTABLISHED状态，完成了三次握手，可以传输数据了。</li></ol><p>简易理解模式：</p><ol><li>第一步：C: 喂，你听得到吗？C -&gt; SYN_SEND</li><li>第二步：S: 嗯，听得到，我说话你也听得到吗？S -&gt; SYN_RCVD | C -&gt; ESTABLISHED</li><li>第三步：C: 我也听得到。那我们说正事吧… S -&gt; ESTABLISHED</li></ol><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p><img data-src="../../assets/20200603174518-1591240733035.png" alt=""></p><ol><li>第一次：客户端将TCP报文中的一个释放标志位（FIN）置为1，并随机产生一个序号seq=u，并将该数据包（注意该数据包没有数据）发送给到服务器，这时客户端已关闭发送消息（但仍可以接收消息），然后进入释放等待状态。</li><li>第二次：服务器接收到客户端发送来的数据包，由FIN=1知道客户端想要关闭连接，为了应答，将应答标志位置为1，同时生成确认号ack=u+1,并随机产生一个序号seq=v，发送给客户端，告知客户端已知晓，注意此时服务端并没有将FIN标志位置为1，所以客户端仍旧是等待状态。</li><li>第三次：服务器确认没有数据要给客户端了，就将FIN标志位和ACK标志位置为1，确认号为之前的ack=u+1,随机产生一个序号seq=w，请求释放连接，发给客户端，然后进入等待状态。</li><li>第四次：客户端确认收到后，检查ack是否为u+1，ACK是否为1，如果正确将ACK标志位置1，ack=w+1,序号为seq=u+1，发送给服务端，表示应答，服务端接收到后，关闭连接，此时服务端进入最大报文生存时间，如果在这段时间内，没有接收报文，则关闭连接。</li></ol><p>简易理解模式：</p><ol><li>第一步：C: 喂，我要挂电话了！C -&gt; FIN_WAIT1</li><li>第二步：S: 嗯，好，等下，我刚才那个事还没说完呢… S -&gt; CLOSE_WAIT | C -&gt; FIN_WAIT2</li><li>第三步：S: 好了，说完了，那就挂电话吧 S-&gt; CLOSE</li><li>第四步：C: 好，再见 C -&gt; TIME_WAIT | S -&gt; CLOSED C等待2MSL,保证S收到了消息，否则重说一次“好，再见” C -&gt; CLOSED</li></ol><div class="note warning no-icon"><p>中断连接端可以是Client端，也可以是Server端。</p></div><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>【问题一】为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p><div class="note info no-icon"><p>这是因为服务端在收到建立连接请求的SYN报文后，把ACK好SYN放在一个报文里发送给客户端。而关闭连接时，当服务端收到客户端释放（关闭）连接的FIN报文后，仅仅表示客户端不再发送数据了但是能还能接收数据，服务端也未必全部数据都发送给了客户端，所以服务端需要检查是否还有数据未发送给客户端，等全部数据都给了客户端，再发送服务端的释放（关闭）连接的FIN报文给客户端，表示同意现在关闭连接，因此，服务端的ACK和FIN一般会分开发送。</p></div><p><strong>【问题二】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong></p><div class="note info no-icon"><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP</tag>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP-缓存机制</title>
    <url>/archives/bff68fd9.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录HTTP协议缓存机制的详解。</p><a id="more"></a><h3 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类"></a>缓存的分类</h3><ul><li>服务端缓存（Ngnix、Apache）</li><li>客户端缓存（Web browser）</li></ul><p><strong>服务端缓存</strong>又分为代理服务器缓存和反向服务器缓存(也叫网关缓存，比如Nginx反向代理、Squid等)，其实广泛使用的CND也是一种服务器缓存，目的都是让用户的请求走“捷径”，并且都是缓存图片、文件等静态资源。</p><p><strong>客户端缓存</strong>一般指的是浏览器缓存，目的就是加速各种静态资源的访问。浏览器缓存控制机制有两种：HTML Meta标签、HTTP头信息。</p><ul><li>强缓存</li><li>协商缓存</li></ul><p><strong>强缓存</strong>是指从浏览器本地直接获取缓存文件，不发送请求到服务器。服务端第一次响应请求时，告知浏览器是否可以存在浏览器本地，设置时间，时间之内可以从浏览器本地获取该资源。状态码为： <code>200(from cache)</code></p><p><strong>协商缓存</strong>是指浏览器发送请求后，服务器根据请求头部的一些缓存相关参数判断是否命中协商缓存，如果命中则使用浏览器本地缓存。比如，服务器判断请求资源是否有更新，如果决策响应请求状态码为200（有更新），则会进行新数据返回并缓存协商，则返回响应结果；如果决策响应请求状态码为304（无更新，协商缓存），告知浏览器直接使用本地缓存数据。状态码为： <code>304(not modified)</code></p><div class="note warning no-icon"><ul><li><strong>缓存协商</strong> 和 <strong>协商缓存</strong> 需要注意，协商缓存指的是状态码为 <code>304(not modified)</code>，通过服务器来告知缓存是否可用，而缓存协商指的是服务器在响应中通过设置相关HTTP头信息来控制缓存的过程。</li><li><strong>强缓存</strong> 和 <strong>协商缓存</strong> 都是从浏览器本地缓存中获取资源，不同的是，强缓存是直接从缓存中取数据，而协商缓存需要发送请求到服务器，通过服务器来告知缓存是否可用。</li></ul></div><h3 id="HTML-Meta控制缓存"><a href="#HTML-Meta控制缓存" class="headerlink" title="HTML-Meta控制缓存"></a>HTML-Meta控制缓存</h3><p>浏览器缓存机制，其实主要就是HTTP协议定义的缓存机制（如：Expires；Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta标签，Web开发者可以在HTML页面的 <code>&lt;head&gt;</code> 节点中加入 <code>&lt;meta&gt;</code> 标签，代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码用于设定当前页面不被缓存，每次访问都需要去服务器拉取。 这样设定，访问者将无法脱机浏览。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内部本身。所以，Meta标签控制这种方法不会广泛使用。</p><h3 id="HTTP头信息控制缓存"><a href="#HTTP头信息控制缓存" class="headerlink" title="HTTP头信息控制缓存"></a>HTTP头信息控制缓存</h3><p>HTTP协议定义的缓存机制才是被广泛应用的一种客户端缓存机制。</p><p><img data-src="../../assets/20200612113452.png" alt=""></p><p>上面为浏览器第一次、再次请求的流程图。</p><h3 id="Pragma策略-缓存开关"><a href="#Pragma策略-缓存开关" class="headerlink" title="Pragma策略 - 缓存开关"></a>Pragma策略 - 缓存开关</h3><p>HTTP1.0中通过Pragma(编译提示)控制页面缓存，通常设置为 <code>Pragma: no-cache</code>，不过这个值不怎么保险，通常还需要加上 <code>Expires: 0</code> 来达到目的。</p><p>Expires是Web服务器响应消息头字段，在响应Http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存读取数据，而无需再次请求。不过Expires是HTTP1.0的东西，现在默认浏览器均默认使用HTTP1.1，所以它的作用基本忽略。Expires的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以从HTTP1.1开始，使用 <code>Cache-Control：max-age=XXX</code>替代Expires。</p><h3 id="Cache-control策略"><a href="#Cache-control策略" class="headerlink" title="Cache-control策略"></a>Cache-control策略</h3><p>Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存读取数据还是重新发送请求到服务器获取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Pragma和Expires。其值有：</p><p>在请求中使用 Cache-Control 时，其常用可选值有：</p><ul><li><code>no-cache</code>：告知（代理）服务器不直接使用缓存，要求向原服务器发起请求</li><li><code>no-store</code>：所有内容都不会保存到缓存或Internet临时文件中</li><li><code>only-if-cached</code>：告知（代理）服务器客户端希望获取缓存的内容（若有），而不用向原服务器发起请求</li></ul><p>在响应中使用 Cache-Control 时，其可选值有（按优先级排序）：</p><ul><li><code>no-store</code>：所有内容都不会保存到缓存或Internet临时文件中</li><li><code>must-revalidate</code>：当前资源一定是向原服务器发起验证请求，若请求失败会返回504（而非代理服务器上的缓存）</li><li><code>no-cache</code>：不使用缓存，要求要原服务器发起请求，并不是不缓存</li><li><code>public</code>：浏览器和缓存服务器都可以缓存资源（即使是需要HTTP认证的资源）</li><li><code>max-age</code>：告知客户端该资源在多少秒内是新鲜的，不需要向服务器发请求</li></ul><div class="note warning no-icon"><p>缓存开关：Pragma，Cache-control。用于标识请求或访问中是否开启了缓存，使用了哪种缓存方式。</p><p>缓存校验：Expires，Last-Modified，Etag。用户定义缓存的有效期，怎么确保缓存是最新的。</p><p>在HTTP1.0中：</p><ul><li>如果想要使用缓存，那么即可设置 <code>Expires</code> 来设置缓存有效时间</li><li>如果想要禁用缓存，那么即可设置 <code>Pragma: no-cache</code>，最好加上 <code>Expires: 0</code> 来禁用缓存，等效于HTTP1.1中的 <code>Cache-Control: no-cache</code></li></ul><p>在HTTP1.1中：</p><ul><li>如果想要使用缓存，即可设置 <code>Cache-Control</code> 来设置相关参数，如果还有 <code>Expires</code> 相关设置，其优先级为：<code>Cache-Control</code> &gt; <code>Expires</code></li><li>如果想要禁用缓存，那么即可设置 <code>Cache-Control: no-cache</code>，如果还有 <code>Pragma</code> 相关设置，其优先级为：<code>Cache-Control</code> &gt; <code>Pragma/Expires</code></li></ul><p>两个容易忽视的地方：</p><ul><li>符合缓存策略时，服务器不会发送新的资源，但不是说客户端和服务器就没有会话了，客户端还是会发请求到服务器的。</li><li>Cache-Control除了在响应中使用，在请求中也可以使用。比如在开发者工具模拟请求时勾选【Disable cache】，则页面请求时，Request Headers中就会自动加入参数 <code>Cache-Control: no-cache</code>。</li></ul></div><h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h3><p>要配合Cache-Control使用。Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更多准确地控制缓存。Last-Modified 与 Etag 一起使用时，服务器会优先验证Etag。</p><ul><li><code>Etag</code>：Web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则有服务器决定）。</li><li><code>If-None-Match</code>：当资源过期时（使用Cache-Control标识的 <code>max-age</code>），发现资源具有 <code>Etag</code> 声明，则再次向Web服务器请求时带上头 <code>If-None-Match</code> （Etag的值）。Web服务器收到请求后发现有头 <code>If-None-Match</code> 则与被请求资源的相应校验串进行比较，决定返回200或304。</li></ul><div class="note warning no-icon"><p>既然有了 <code>Last-Modified</code> 为何还需要 <code>Etag</code>?</p><ul><li><code>Last-Modified</code> 标注的最后修改只能精确到秒级，如果某些文件在1秒钟之内，被修改多次的话，它将不能准确标注文件的修改时间</li></ul></div><h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h3><p>要配合Cache-Control使用。</p><ul><li><code>Last-Modified</code>：标识这个响应资源的最后修改时间。Web服务器在响应请求时，告诉浏览器资源的最后修改时间。</li><li><code>If-Modified-Since</code>：当资源过期时（使用Cache-Control标识的 <code>max-age</code>），发现资源具有 <code>Last-Modified</code> 声明，则再次向Web服务器请求时带上头 <code>If-Modified-Since</code>， 表示请求时间。Web服务器收到请求后发现有头 <code>If-Modified-Since</code> 则与被请求资源的最后修改时间进行对比，若最后修改时间较新，说明资源又被改动过，则相应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则相应HTTP 304 （无需包体，节省浏览），告知浏览器继续使用所保存的Cache。</li></ul><p><img data-src="../../assets/20200612174113.png" alt=""></p><div class="note warning no-icon"><ul><li>200：当浏览器本地没有缓存，或者用户点击了 <code>CLT + F5</code> 时，浏览器直接去服务器下载最新数据</li><li>200（from cache）：由 <code>Expires/Cache-Control</code> 控制，只要没有失效，浏览器就只会访问浏览器本地的缓存</li><li>301：永久重定向</li><li>302：临时重定向</li><li>304：服务器资源未变化。由 <code>Last-Modified/Etag</code> 控制，或者用户点击了 <code>Refresh/F5</code> 时，浏览器就会发送请求到服务器，如果服务器端资源没有变化，则返回304给浏览器</li></ul></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-原型和原型链</title>
    <url>/archives/d76fa986.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录原型和原型链的简单式理解。</p><a id="more"></a><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>简单来说就是有一个构造函数，当用这个构造函数 <code>new</code> 一个实例出来的时候，这个实例的原型就是这个构造函数。在 <code>JavaScript</code> 中，有两个原型：</p><ul><li><code>prototype</code>：这个一个显式原型属性，只有函数才拥有该属性</li><li><code>__proto__</code>：这是每个对象（引用类型）都有的隐式原型属性，指向了创建该对象（实例）的构造函数的原型</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">   <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'zi jun'</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><div class="note warning no-icon"><ul><li><p><code>JavaScript</code> 中所有的引用类型（<code>Fucntion</code>/ <code>Array</code>/<code>Object</code>）都有自己的构造函数。</p></li><li><p><code>let arr = []</code> 的时候其实就是等于 <code>let arr = new Array()</code>。</p></li></ul></div><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>创建函数有两种方式：</p><ol><li>通过 <code>function</code> 关键字定义</li><li>通过 <code>new Function</code></li></ol><p>其中函数又分为 普通函数 和 构造函数，两者唯一的区别就是调用的方式不同，语法上没有差异</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalFn</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 普通函数（函数名首字母小写）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructFn</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 构造函数（函数名首字母大写）</span></span><br></pre></td></tr></table></figure><p>传统对象的方式有多种，其中传统方法是通过构造函数来创建对象，使用 <code>new</code> 关键字即可创建，创建出来的对象实例可通过 <code>constructor</code> 来访问构造函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructFn</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> ConstructFn(); <span class="comment">// 构造函数实例化（创建）对象</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor); <span class="comment">// &gt; f ConstuctFn() &#123;&#125; 对象可以通过 constructor 来访问构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(ConstructFn.prototype); <span class="comment">// &gt; &#123;constructor: f&#125;</span></span><br><span class="line">ConstructFn.prototype.name = <span class="string">'zi'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ConstructFn.prototype); <span class="comment">// &gt; &#123;name: "zi", constructor: f ConsturctFn()&#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure><div class="note warning"><p>在 <code>JavaScript</code> 中，万物皆对象，函数也是对象，只不过函数相对于对象有着更为精确的定义。</p></div><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>为了证明 <code>prototype</code> 属性是函数独有，而 <code>__proto__</code> 是每个对象都有的，可以用以下代码测试：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype); <span class="comment">// &gt; &#123;constructor: f&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__); <span class="comment">// &gt; f () &#123;[native code]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(obj.prototype); <span class="comment">// &gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// &gt; &#123;constructor: ƒ, __defineGetter__: ƒ,  …&#125;</span></span><br></pre></td></tr></table></figure><div class="note warning no-icon"><p><code>undefined</code> 和 <code>null</code> 同属于对象，但是他们都没有原型，为什么？在 <code>JavaScript</code> 中，目前只有两个只有一个值的数据类型，那就是 <code>undefined</code> 和 <code>null</code>，由于这两种数据类型有且只有一个值，并且没有方法，所以自然就没有原型了。</p></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>.__proto__); <span class="comment">// Uncaught TypeError: Cannot read property '__proto__' of undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>.__proto__); <span class="comment">// // Uncaught TypeError: Cannot read property '__proto__' of null</span></span><br></pre></td></tr></table></figure><h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><ol><li>创建一个新对象</li><li>将新创建的对象的隐式原型指向其构造函数的显示原型</li><li>赋值，将 <code>this</code> 指向这个新对象</li><li>返回新对象</li></ol><p>将新创建的对象的隐式原型指向其构造函数的显示原型，也就是说：<code>对象.__proto__ === 构造函数.prototype</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === Fn.prototype); <span class="comment">// &gt; true</span></span><br></pre></td></tr></table></figure><p>那么，我们在为构造函数添加原型方法时，就可以通过两种方式来访问：</p><ol><li>通过构造函数的显式原型</li><li>通过实例化对象的隐式原型</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Fn();</span><br><span class="line">Fn.prototype.more = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'Fn-protopype-more'</span>)&#125;</span><br><span class="line"><span class="comment">// 通过构造函数的显式原型</span></span><br><span class="line">Fn.prototype.more(); <span class="comment">// &gt; "Fn-prototype-more"</span></span><br><span class="line"><span class="comment">// 通过实例化对象的隐式原型</span></span><br><span class="line">obj.__proto__.more(); <span class="comment">// &gt; "Fn-prototype-more"</span></span><br></pre></td></tr></table></figure><p>用原生new操作符实例化构造函数创建对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name; <span class="comment">// 构造函数中this指向window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'zi'</span>); <span class="comment">// this指向person对象</span></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// &gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person); <span class="comment">// &gt; true</span></span><br></pre></td></tr></table></figure><p>用自定义NEW操作符实例化构造函数创建对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name; <span class="comment">// 构造函数中this指向window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> NEW = <span class="function"><span class="keyword">function</span> (<span class="params">p, ...params</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> o = &#123;&#125;; <span class="comment">// 创建一个新对象</span></span><br><span class="line">   o.__proto__ = p.prototype; <span class="comment">// 新对象的隐式原型指向构造函数的显示原型</span></span><br><span class="line">   p.call(o, ...params); <span class="comment">// 改变this指向</span></span><br><span class="line">   <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = NEW (Person, <span class="string">'zi'</span>); <span class="comment">// this指向person对象</span></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// &gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person); <span class="comment">// &gt; true</span></span><br></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><strong>原型链就是实例与原型之间的链接。</strong></p><p>先看上面使用过的一个简单例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Fn();</span><br><span class="line">Fn.prototype.more = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'Fn-protopype-more'</span>)&#125;</span><br><span class="line"><span class="comment">// 通过实例化对象的隐式原型</span></span><br><span class="line">obj.__proto__.more(); <span class="comment">// &gt; "Fn-prototype-more"</span></span><br><span class="line">obj.more(); <span class="comment">// &gt; "Fn-prototype-more"</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__.more === obj.more); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>以上代码可知： <code>obj.__proto__.more() === obj.more()</code>。</p><p>再看下面一个稍微复杂的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"Fn-fn"</span>) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对构造函数的原型修改（因为构造函数已存在此方法）方法</span></span><br><span class="line">Fn.prototype.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"Fn-prototype-fn"</span>) &#125;;</span><br><span class="line"><span class="comment">// 对象的原型新增方法</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"Object-fn"</span>) &#125;;</span><br><span class="line"><span class="comment">// 构造函数创建新对象</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="comment">// 新对象修改（因为对象原型已存在此方法）方法</span></span><br><span class="line">obj.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"obj-fn"</span>) &#125;;</span><br><span class="line">obj.fn(); <span class="comment">// &gt; obj-fn</span></span><br><span class="line">obj.fn2; <span class="comment">// &gt; undefined</span></span><br></pre></td></tr></table></figure><p>以上代码中，有4个重名的 <code>fn</code> 函数，分别是：</p><ol><li>构造函数 <code>Fn</code> 的方法</li><li>构造函数 <code>Fn</code> 原型上的方法</li><li><code>Object</code> 对象原型上的方法</li><li>实例对象 <code>ojb</code> 的方法</li></ol><p>具体查找 <code>fn</code> 方法的原型链如下：</p><ol><li>寻找某个方法或者属性，会先从自身对象寻找</li><li>如果没有，则会去构造函数寻找，注意这里没有用到原型链</li><li>紧接着，会到构造函数的原型上寻找，这里开始用到了原型链</li><li>接下来，回到 <code>Object</code> 对象的原型寻找，因为 <code>Object</code> 对象是所有对象之父，可以说所有的对象都继承了 <code>Object</code></li><li>最后，由于 <code>Object.__proto__</code> 指向了 <code>null</code>，这也就是原型链的末端</li></ol><p><img data-src="../../assets/20200703171428.png" alt=""></p><p>向上第一层原型是：<code>obj.__proto__</code>，访问到了 <code>Fn.prototype</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === Fn.prototype); <span class="comment">// &gt; true</span></span><br></pre></td></tr></table></figure><p>向上第二层原型是：<code>obj.__proto__.__proto__</code>，访问到了 <code>Object.prototype</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.__proto__.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// &gt; true</span></span><br></pre></td></tr></table></figure><p>向上第三层原型是：<code>obj.__proto__.__proto__.__proto__</code>，访问到了 <code>Object.prototype.__proto__</code>，最后指向了 <code>null</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.__proto__.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// &gt; true</span></span><br></pre></td></tr></table></figure><h3 id="原型链图"><a href="#原型链图" class="headerlink" title="原型链图"></a>原型链图</h3><p><img data-src="../../assets/image-20200706144951384.png" alt=""></p><ul><li><p>原型对象层级（属性的原型链查找过程）：<br><code>obj</code> -&gt; <code>Fn.prototype</code> -&gt; <code>Object.prototype</code> -&gt; <code>null</code><br><code>function Fn</code> / <code>function Object</code> -&gt; <code>function Function</code> -&gt; <code>Object.prototype</code> -&gt; <code>null</code></p></li><li><p>构造函数层级（构造函数作为对象，是由谁创建的）：<br><code>obj</code> -&gt; <code>function Fn()</code> -&gt; <code>function Function()</code></p><p><code>function Object()</code> -&gt; <code>function Function()</code></p></li></ul><div class="note warning no-icon"><ul><li>所有的实例（对象）的 <code>__proto_</code> 都指向该构造函数的原型对象（<code>prototype</code>）</li><li>所有的函数（包括构造函数）都是 <code>Function</code> 的实例，所以所有函数的 <code>__proto_</code> 都指向 <code>Function</code> 的原型对象（Function.prototype）</li><li>所有的原型对象（包括 <code>Function</code>的原型对象-<code>Function.prototype</code>）都是 <code>Object</code> 的实例，所以 <code>__proto_</code> 都指向 <code>Object</code>(构造函数)的原型对象。而 <code>Object</code>构造函数的 <code>__proto__</code>指向 <code>null</code></li><li><code>Function</code> 构造函数本身就是 <code>Function</code> 的实例，所以 <code>__proto_</code> 指向 <code>Function</code> 的原型对象</li></ul></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript精华-常用工具方法集合</title>
    <url>/archives/7f02b3bf.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录工作总常用的一些工具方法集合，也适用于vue项目中的utlils目录下的方法整理。为方便使用，这里已模块化方式书写。</p><a id="more"></a><h3 id="判断相关方法"><a href="#判断相关方法" class="headerlink" title="判断相关方法"></a>判断相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// judge-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断对象是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>obj &#123;Object&#125; 判断对象参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isEmptyObj = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(obj) === <span class="string">'&#123;&#125;'</span> || obj === <span class="literal">null</span> || obj === <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>arr &#123;Array&#125; 判断数组参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isEmptyArray = <span class="function"><span class="params">arr</span> =&gt;</span> !arr.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测空格、回车、换行、空白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isBlank = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/^\s*$/</span>;</span><br><span class="line">  <span class="keyword">return</span> reg.test(str)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是超链接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isHttps = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&amp;=]*)?/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.test(str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是合法的省份证号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isIdCardNo = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^([0-9])&#123;7,18&#125;(x|X)?$/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.test(str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是合法的手机号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isMobile = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^1\d&#123;10&#125;$/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.test(str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是合法的邮箱</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isEmail = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^(\w-*\.*)+@(\w-?)+(\.\w&#123;2,&#125;)+$/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.test(str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是合法的微信号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isWeChatNo = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.test(str);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="设备相关方法"><a href="#设备相关方法" class="headerlink" title="设备相关方法"></a>设备相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// device-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取设备机型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;stirng&#125;</span> </span>浏览器类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> browserType = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> userAgent = navigator.userAgent;</span><br><span class="line">    <span class="keyword">let</span> isOpera = userAgent.indexOf(<span class="string">"Opera"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> isIE = userAgent.indexOf(<span class="string">"compatible"</span>) &gt; <span class="number">-1</span></span><br><span class="line">        &amp;&amp; userAgent.indexOf(<span class="string">"MSIE"</span>) &gt; <span class="number">-1</span> &amp;&amp; !isOpera;</span><br><span class="line">    <span class="keyword">let</span> isEdge = userAgent.indexOf(<span class="string">"Edge"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> isFF = userAgent.indexOf(<span class="string">"Firefox"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> isSafari = userAgent.indexOf(<span class="string">"Safari"</span>) &gt; <span class="number">-1</span></span><br><span class="line">        &amp;&amp; userAgent.indexOf(<span class="string">"Chrome"</span>) == <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> isChrome = userAgent.indexOf(<span class="string">"Chrome"</span>) &gt; <span class="number">-1</span></span><br><span class="line">        &amp;&amp; userAgent.indexOf(<span class="string">"Safari"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isIE) &#123;</span><br><span class="line">        <span class="keyword">var</span> reIE = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"MSIE (\\d+\\.\\d+);"</span>);</span><br><span class="line">        reIE.test(userAgent);</span><br><span class="line">        <span class="keyword">var</span> fIEVersion = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>[<span class="string">"$1"</span>]);</span><br><span class="line">        <span class="keyword">if</span> (fIEVersion === <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IE7"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fIEVersion === <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IE8"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fIEVersion === <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IE9"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fIEVersion === <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IE10"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fIEVersion === <span class="number">11</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IE11"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"IE"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isOpera &amp;&amp; <span class="keyword">return</span> <span class="string">"Opera"</span>;</span><br><span class="line">    isEdge &amp;&amp; <span class="keyword">return</span> <span class="string">"Edge"</span>;</span><br><span class="line">    isFF &amp;&amp; <span class="keyword">return</span> <span class="string">"FF"</span>;</span><br><span class="line">    isSafari &amp;&amp; <span class="keyword">return</span> <span class="string">"Safari"</span>;</span><br><span class="line">    isChrome &amp;&amp; <span class="keyword">return</span> <span class="string">"Chrome"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否在IOS中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isIOS = <span class="regexp">/(iphone|ipad|ipod|ios)/i</span>.test(navigator.userAgent.toLowerCase());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否在Android中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isAndroid = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> u = navigator.userAgent;</span><br><span class="line">    <span class="keyword">return</span> (u.indexOf(<span class="string">"Android"</span>) &gt; <span class="number">-1</span>) || (u.indexOf(<span class="string">"Linux"</span>) &gt; <span class="number">-1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否在微信中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isWx = <span class="regexp">/micromessenger/</span>.test(<span class="built_in">window</span>.navigator.userAgent.toLowerCase());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否在微信小程序中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isWxMiniProgram = <span class="regexp">/miniprogram/</span>.test((<span class="built_in">window</span>.__wxjs_environment || navigator.userAgent).toLowerCase());</span><br></pre></td></tr></table></figure><h3 id="字符串相关方法"><a href="#字符串相关方法" class="headerlink" title="字符串相关方法"></a>字符串相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串去除所有html标签</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;string&#125; 需要处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeHtmlTag = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> reg = <span class="regexp">/&lt;\/?.+?\/?&gt;/g</span>;</span><br><span class="line">  <span class="keyword">return</span> str.replace(reg, <span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除字符前后空格</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 需要处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> clearSpace = <span class="function"><span class="params">str</span> =&gt;</span> str.replace(<span class="regexp">/(^\s*)|(\s*)$/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除所有空格</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>v &#123;String&#125; 需要处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>返回正确的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeAllSpace = <span class="function"><span class="params">v</span> =&gt;</span> v.replace(<span class="regexp">/\s+/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除所有超链接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>html &#123;String&#125; html字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>返回移除超链接之后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeAllHyperLink = <span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/&lt;a[^&gt;]*href=['"]([^"]*)['"].*?[^&gt;]*&gt;(.*?)&lt;\/a&gt;/gi</span>);</span><br><span class="line">  <span class="keyword">return</span> reg.test(html) ? html.replace(reg, <span class="string">''</span>) : html;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换文本中所有换行(\n)为&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 需要处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>替换之后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> replaceAllLineBreakWithBr = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/\\+n/g</span>);</span><br><span class="line">  <span class="keyword">return</span> reg.test(str) ? str.replace(reg, <span class="string">'&lt;br/&gt;'</span>) : str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除内容中 \n | \\n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 需要处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>清除之后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeAllLineBreak = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/\\+n/g</span>);</span><br><span class="line">  <span class="keyword">return</span> reg.test(str) ? str.replace(reg, <span class="string">''</span>) : str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去除字符串中&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str &#123;String&#125; 需要处理的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>去除之后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeBr = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/&lt;br\s*\\?\/?&gt;/gi</span>);</span><br><span class="line">  <span class="keyword">return</span> reg.test(str) ? str.replace(reg, <span class="string">''</span>) : str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件后缀名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>filePath &#123;String&#125; file地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example </span>https://baidu.com/file/123.mp4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span> </span>文件后缀 mp4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getFileType = <span class="function">(<span class="params">filePath</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> startIndex = filePath.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">if</span>(startIndex !== <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> filePath.substring(startIndex + <span class="number">1</span>, filePath.length).toLowerCase();</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析url参数，转换为参数对象模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>url &#123;String&#125; url地址 default: window.location.href</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example </span>?id=12345&amp;a=b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span> </span>转换之后的对象 &#123;id:12345, a:b&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> parseQueryString = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  url = !url ? <span class="built_in">window</span>.location.href : url;</span><br><span class="line">  <span class="keyword">if</span> (url.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> search = url[<span class="number">0</span>] === <span class="string">'?'</span> ? url.substr(<span class="number">1</span>) : url.substring(url.lastIndexOf(<span class="string">'?'</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (search === <span class="string">''</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  search = search.split(<span class="string">'&amp;'</span>);</span><br><span class="line">  <span class="keyword">let</span> query = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; search.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = search[i].split(<span class="string">'='</span>);</span><br><span class="line">    query[<span class="built_in">decodeURIComponent</span>(pair[<span class="number">0</span>])] = <span class="built_in">decodeURIComponent</span>(pair[<span class="number">1</span>] || <span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> query;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数值相关方法"><a href="#数值相关方法" class="headerlink" title="数值相关方法"></a>数值相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// number-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四舍五入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>number &#123;Number&#125; 处理的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>digit &#123;Number&#125; 需要保留的小数位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>12.34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getMathRound = <span class="function">(<span class="params">number = <span class="number">0</span>, digit = <span class="number">2</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> exponent = <span class="built_in">Math</span>.pow(<span class="number">10</span>, digit);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round(number * exponent) / exponent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取两个数之间的随机数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>min &#123;Number&#125; 范围最小值(包此值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>max &#123;Number&#125; 范围最大值(含此值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>随机数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example </span>(1,7) =&gt; 1/2/3/4/5/6/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> randomInt = <span class="function">(<span class="params">min, max</span>) =&gt;</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min) + min);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式化手机号为 3-4-4结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">v</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string|*&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> formatPhoneNum = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> _v = removeAllSpace(v);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isNaN</span>(_v)) &#123;</span><br><span class="line">    <span class="keyword">return</span> _v</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_v.length &gt;= <span class="number">3</span> &amp;&amp; _v.length &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> FIRST_PART = _v.substr(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">      <span class="keyword">const</span> SECOND_PART = _v.substr(<span class="number">3</span>);</span><br><span class="line">      v = FIRST_PART + <span class="string">' '</span> + SECOND_PART</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_v.length &gt; <span class="number">7</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> FIRST_PART = _v.substr(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">      <span class="keyword">const</span> SECOND_PART = _v.substr(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">const</span> THIRD_PART = _v.substr(<span class="number">7</span>);</span><br><span class="line">      v = FIRST_PART + <span class="string">' '</span> + SECOND_PART + <span class="string">' '</span> + THIRD_PART</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强制保留n位小数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>value &#123;String | Number&#125; 需要处理的数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>n &#123;Number&#125; 需要保留的小数位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> returnFloat = <span class="function">(<span class="params">value, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> v = <span class="built_in">Math</span>.round(<span class="built_in">parseFloat</span>(value) * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">let</span> xsd = v.toString().split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">if</span> (xsd.length === <span class="number">1</span>) &#123;</span><br><span class="line">    v = v.toString() + <span class="string">'.'</span> + <span class="string">'0'</span>.repeat(n);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (xsd.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xsd[<span class="number">1</span>].length &lt; n) &#123;</span><br><span class="line">      v = v.toString() + <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 金钱“，”格式处理，保留n位小数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>value &#123;String | Number&#125; 需要处理的数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>n &#123;Number&#125; 需要保留的小数位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>5,000.00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> formatMoney = <span class="function">(<span class="params">s, n</span>) =&gt;</span> &#123;</span><br><span class="line">  n = n &gt; <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">20</span> ? n : <span class="number">2</span>;</span><br><span class="line">  s = <span class="built_in">parseFloat</span>((s + <span class="string">''</span>).replace(<span class="regexp">/[^\d.-]/g</span>, <span class="string">''</span>)).toFixed(n) + <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> l = s.split(<span class="string">'.'</span>)[<span class="number">0</span>].split(<span class="string">''</span>).reverse()</span><br><span class="line">  <span class="keyword">let</span> r = s.split(<span class="string">'.'</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> t = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l.length; i++) &#123;</span><br><span class="line">    t += l[i] + ((i + <span class="number">1</span>) % <span class="number">3</span> === <span class="number">0</span> &amp;&amp; (i + <span class="number">1</span>) !== l.length ? <span class="string">','</span> : <span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) + <span class="string">'.'</span> + r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 百分比格式处理，保留n位小数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>value &#123;String | Number&#125; 需要处理的数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>n &#123;Number&#125; 需要保留的小数位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>20.00%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fPercent = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> number = (<span class="built_in">Number</span>(n) * <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;number&#125;</span>%`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组、对象相关方法"><a href="#数组、对象相关方法" class="headerlink" title="数组、对象相关方法"></a>数组、对象相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个数组合并一个对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>arr1 &#123;Array&#125; 被合并数组，在对象中以 键 存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>arr2 &#123;Array&#125; 被合并数组，在对象中以 值 存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span> </span>返回键值对的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrContactObject = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">    obj[arr1[i]] = arr2[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝，支持常见类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>values 复制之前的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;&#123;&#125;</span></span>|Array|Date|*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> deepClone = <span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> copy;</span><br><span class="line">  <span class="keyword">if</span> (values === <span class="literal">null</span> || <span class="keyword">typeof</span> values !== <span class="string">'object'</span>) <span class="keyword">return</span> values;</span><br><span class="line">  <span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    copy = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    copy.setTime(values.getTime());</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    copy = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = values.length; i &lt; len; i++) &#123;</span><br><span class="line">      copy[i] = deepClone(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">    copy = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> values) &#123;</span><br><span class="line">      <span class="keyword">if</span> (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Unable to copy values! Its type isn't supported."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="图片相关方法"><a href="#图片相关方法" class="headerlink" title="图片相关方法"></a>图片相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将html转化为图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>element &#123;Object&#125; 需要转化的dom</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>scale &#123;Number&#125; 放大倍数，默认2倍，原因为保持转化后图片的清晰度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>isSaveImg &#123;Boolean&#125; 是否保存图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>callback &#123;Function&#125; 转化后的成功回调，参数为图片的DOM,用于图片操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> generateCanvasImage = <span class="function">(<span class="params">element, scale = <span class="number">2</span>, isSaveImg = <span class="literal">false</span>, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> width = element.offsetwidth;</span><br><span class="line">  <span class="keyword">let</span> height = element.offsetheight;</span><br><span class="line">  <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">  <span class="keyword">const</span> SCALE = scale;</span><br><span class="line">  canvas.width = width * SCALE;</span><br><span class="line">  canvas.height = height * SCALE;</span><br><span class="line">  canvas.getContext(<span class="string">'2d'</span>).scale(scale, scale);</span><br><span class="line">  <span class="keyword">const</span> opts = &#123;</span><br><span class="line">    scale,</span><br><span class="line">    canvas,</span><br><span class="line">    width,</span><br><span class="line">    height,</span><br><span class="line">    useCORS: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">  html2canvas(element, opts).then(<span class="function"><span class="params">canvasObj</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = canvasObj.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    context.webkitImageSmoothingEnabled = <span class="literal">false</span>;</span><br><span class="line">    context.imageSmoothingEnabled = <span class="literal">false</span>;</span><br><span class="line">    isSaveImg &amp;&amp; Canvas2Image.saveAsPNG(canvasObj, canvasObj.width, canvasObj.height);</span><br><span class="line">    <span class="keyword">const</span> IMGDOM = Canvas2Image.convertToPNG(canvasObj, canvasObj.width, canvasObj.height);</span><br><span class="line">    callback &amp;&amp; callback(IMGDOM);</span><br><span class="line">    <span class="keyword">return</span> IMGDOM;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时间相关方法"><a href="#时间相关方法" class="headerlink" title="时间相关方法"></a>时间相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// date-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倒计时计算年，天，时，分，秒</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>targetTime &#123;Number/String&#125; 目标时间（将来的设定时间）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>startTime &#123;Number/String&#125; 开始时间（一般为现在时间）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;&#123;years: *, days: *, hours: *, minutes: *, seconds: *&#125;</span></span>&#125; 返回对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> returnLeftTime = <span class="function">(<span class="params">targetTime, startTime</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkTime</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      i = <span class="string">'0'</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> currTime = startTime || <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">let</span> leftTime = <span class="built_in">Number</span>(targetTime) - <span class="built_in">Number</span>(currTime);</span><br><span class="line">  <span class="keyword">if</span> (leftTime &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> years = <span class="built_in">parseInt</span>(leftTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span> / <span class="number">365</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> days = <span class="built_in">parseInt</span>(leftTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> hours = <span class="built_in">parseInt</span>(leftTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> % <span class="number">24</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> minutes = <span class="built_in">parseInt</span>(leftTime / <span class="number">1000</span> / <span class="number">60</span> % <span class="number">60</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> seconds = <span class="built_in">parseInt</span>(leftTime / <span class="number">1000</span> % <span class="number">60</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      years: checkTime(years),</span><br><span class="line">      days: checkTime(days),</span><br><span class="line">      hours: checkTime(hours),</span><br><span class="line">      minutes: checkTime(minutes),</span><br><span class="line">      seconds: checkTime(seconds)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前日期的N个月/天前后的日期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>months &#123;number&#125; N月，+N 表示N月之后; -N 表示N月之前</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>days &#123;number&#125; N日， +N 表示N天之后; -N 表示N天之前</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>isZero &#123;boolean&#125; 是否需要补零 true(默认) 需要;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>joinSign &#123;string&#125; 日期连接符号 ‘-’(默认)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>输出需求格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getFewMonthAgoOrAfterDate = <span class="function">(<span class="params">months = <span class="number">0</span>, days = <span class="number">0</span>, isZero = <span class="literal">true</span>, joinSign = <span class="string">'-'</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  dt.setMonth(dt.getMonth() + months, dt.getDate() + days);</span><br><span class="line">  <span class="keyword">let</span> Year = dt.getFullYear();</span><br><span class="line">  <span class="keyword">let</span> Month = dt.getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> Day = dt.getDate();</span><br><span class="line">  <span class="keyword">if</span> (isZero) &#123;</span><br><span class="line">    Month = Month &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + Month) : Month;</span><br><span class="line">    Day = Day &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + Day) : Day;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;Year&#125;</span><span class="subst">$&#123;joinSign&#125;</span><span class="subst">$&#123;Month&#125;</span><span class="subst">$&#123;joinSign&#125;</span><span class="subst">$&#123;Day&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否为闰年</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>输出需求格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isLeapYear = <span class="function">(<span class="params">year</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化相关方法"><a href="#优化相关方法" class="headerlink" title="优化相关方法"></a>优化相关方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// optimize-methods.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay &#123;number&#125; 等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn &#123;Function&#125; 需执行函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">delay, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn(...args);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay &#123;number&#125; 计划好的执行间隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn &#123;Function&#125; 需执行函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params">delay, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastCall = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> NOW = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</span><br><span class="line">        <span class="keyword">if</span>(NOW - lastCall &lt; delay) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastCall = NOW;</span><br><span class="line">        <span class="keyword">return</span> fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>精华</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>工具</tag>
        <tag>精华</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶-模块化</title>
    <url>/archives/b92372a3.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录JavaScript模块化的几个重要发展阶段，无模块化，CommonJS，AMD规范，CMD规范，ES6模块化。</p><a id="more"></a><p>随着前端 <code>JavaScript</code> 代码复杂度的提高，<code>JavaScript</code> 模块化这个概念被提出来，前端社区也不断地实现前端模块化。下面介绍 <code>JavaScript</code> 模块化及其是如何一步一步地发展起来的。</p><h3 id="无模块化"><a href="#无模块化" class="headerlink" title="无模块化"></a>无模块化</h3><p><code>JavaScript</code> 最初的作用仅仅是验证表单，后来会添加一些动画，但是这些 <code>JavaScript</code> 代码很多在一个文件中就可以完成了，所以，我们只需在 <code>html</code> 文件中添加一个 <code>script</code> 标签。</p><p>后来，随着前端复杂度的提高，为了能够提高项目的可读性、可扩展性等，我们的 <code>JavaScript</code> 文件逐渐多了起来，不再是一个 <code>js</code> 文件就可以解决的了，而是把每一个 <code>js</code> 文件当做一个模块。那么，这是的 <code>js</code> 引入方式是怎么样的呢？大概是下面这样：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"other1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"other2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>即简单地将所有的 <code>js</code> 文件统统放在一起。但是这些文件的顺序不能出错，比如，<code>jquery</code> 需要先引入，才能引入 <code>jquery</code> 插件，才能在其他的文件中使用 <code>jquery</code>。</p><p><strong>优点：</strong></p><ul><li>相比于使用一个 <code>js</code> 文件，这种多个 <code>js</code> 文件实现最简单的模块化的思想是进步的</li></ul><p><strong>缺点：</strong></p><ul><li><strong>污染全局作用域。</strong>因为每一个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突。当然，我们也可以使用命名空间的方式来解决。</li><li><strong>依赖关系不明显，不利于维护。</strong>比如，<code>jquery</code> 的某个插件就依赖于 <code>jquery</code>，如果忘记引用 <code>jquery</code> 了，那么就会报错。</li></ul><h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><p>IIFE就是自执行函数，这种方式是其实是对 <code>js</code> 单独文件的优化方式。</p><p><strong>优点：</strong>在一个单独的函数作用域中执行代码，<strong>避免变量冲突</strong>。</p><p><strong>缺点：</strong> <strong>依赖关系不明显，不利于维护。</strong>比如，<code>jquery</code> 的某个插件就依赖于 <code>jquery</code>，如果忘记引用 <code>jquery</code> 了，那么就会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		data: []</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><p><code>CommonJS</code> 就是一个 <code>JavaScript</code> 模块化的规范，该规范最初是用在服务端的 <code>node</code> 中，前端的 <code>webpack</code> 也是对 <code>CommonJS</code>原生支持的。根据这个规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。</p><p><code>CommonJS</code> 的核心思想就是通过 <code>require</code> 方法来同步加载所需要依赖的其他模块，然后通过 <code>exports</code> 或者 <code>module.exports</code> 来导出需要暴露的接口。如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> addX = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><p>这里的 <code>a.js</code> 就是一个 <code>CommonJS</code> 规范的模块了。这里的 <code>module</code> 就代表了这个模块，<code>module</code> 的 <code>exports</code> 属性就是对外暴露的接口，可以对外导出外部可以访问的变量，比如这里的 <code>x</code> 和 <code>addX</code>。</p><p><code>exports</code> 是对 <code>module.exports</code> 的引用。比如，我们可以认为在一个模块的顶部有这句代码：<code>exports = module.exports</code>，所以，我们不能直接给 <code>exports</code> 赋值，比如 <code>number</code>、<code>function</code> 等。</p><p>然后我们就可以在其他模块中引入这个模块使用了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">"./a.js"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// &gt; 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a.addX(<span class="number">2</span>)); <span class="comment">// &gt; 7</span></span><br></pre></td></tr></table></figure><p>这里的 <code>require</code> 就会获取到 <code>a.js</code> 所暴露的 <code>module.exports</code> 变量，然后就可以使用暴露的 <code>x</code> 和 <code>addX</code> 了。</p><div class="note warning no-icon"><p><code>module.exports</code> 才是真正的接口，<code>exports</code> 只不过是它的一个辅助工具。最终返回给调用的是 <code>module.exports</code> 而不是 <code>exports</code>。所有的 <code>exports</code> 收集到的属性和方法，都赋值给了 <code>module.exports</code>。当然，这有个前提，就是 <code>module.exports</code> 本身不具备任何属性和方法。<code>module.exports</code> 已经具备一些属性和方法，那么 <code>exprots</code> 收集来的信息将被忽略。使用最好遵循这两点：</p><ol><li>最好别分别定义 <code>module.exports</code> 和 <code>exports</code></li><li>NodeJS开发者建议导出对象用 <code>module.exports</code>，导出多个方法和变量用 <code>exports</code></li></ol></div><p><strong>优点：</strong></p><ul><li><code>CommonJs</code> 规范在服务端率先完成了 <code>JavaScript</code> 的模块化，解决了依赖、全局变量污染的问题，这也是 <code>js</code> 运行在服务端的必要条件</li></ul><p><strong>缺点：</strong></p><ul><li>由于 <code>CommonJS</code> 是同步加载模块的，在服务端文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务端请求过来，那么同步加载就不适用了，所以， <code>CommonJS</code> 是不合适用于浏览器端的。</li></ul><h3 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h3><p><code>CommonJs</code> 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 <code>AMD</code> 规范是非同步加载模块，允许指定回调函数。由于 <code>Node.js</code> 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 <code>CommonJS</code> 规范比较适用。但是，浏览器环境，要从服务端加载模块，这时就必须采用非同步模式，因此浏览器一般采用 <code>AMD</code> 规范。而 <code>AMD</code> 规范的实现，就是大名鼎鼎的 <code>require.js</code>了。</p><p><code>AMD</code> 标准中，定义了下面两个API:</p><ol><li><code>require([module], callback)</code></li><li><code>define(id, [module], callback)</code></li></ol><p>即通过 <code>define</code> 来定义一个模块，然后使用 <code>require</code> 来加载一个模块。并且，<code>require</code> 还支持 <code>CommonJS</code> 的模块导出方式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义模块</span></span><br><span class="line">define(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> alertName = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">        alert(<span class="string">`I am <span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123; alertName &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'alert'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">alert</span>) </span>&#123;</span><br><span class="line">    alert.alertName(<span class="string">"zi jun"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>适合在浏览器环境中异步加载模块，可以并行加载多个模块</li></ul><p><strong>缺点：</strong></p><ul><li>提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖</li></ul><h3 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h3><p><code>CMD</code> 规范是阿里的玉伯提出来的，实现 <code>js</code> 库为 <code>sea.js</code>。它和 <code>require.js</code> 非常类似，即一个 <code>js</code> 文件就是一个模块，但是 <code>CMD</code> 的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">    exports.doSomething = <span class="string">"//"</span>;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="string">"//"</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>同样实现了浏览器端的模块化加载</li><li>可以按需加载，依赖就近</li></ul><p><strong>缺点：</strong></p><ul><li>依赖 <code>SPM</code> 打包，模块的加载逻辑偏重</li></ul><div class="note warning no-icon"><p><code>AMD</code> 和 <code>CMD</code> 的区别：前者对于依赖的模块提前执行，而后者是延迟执行。前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块时再 <code>require</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AMD</span></span><br><span class="line"><span class="comment">// 依赖必须一开始就前置</span></span><br><span class="line">define([<span class="string">"./a"</span>, <span class="string">"./b"</span>], (a, b) =&gt; &#123;</span><br><span class="line">    a.doSomething();</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CMD</span></span><br><span class="line"><span class="comment">// 依赖按需加载，就近原则</span></span><br><span class="line">define(<span class="function">(<span class="params"><span class="built_in">require</span>, exports, <span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>);</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">require</span>(<span class="string">"./b"</span>);</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><h3 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h3><p>之前的几种模块方案都是前端社区自己实现的，只是得到了大家的认可和广泛使用，而ES6的模块化方案才是真正的规范。在ES6中，我们可以使用 <code>import</code> 关键字引入模块，通过 <code>export</code> 关键字导出模块，功能较之前几种方案更为强大，也是我们所推崇的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; square, diag &#125; <span class="keyword">from</span> <span class="string">"./utils"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">2</span>)); <span class="comment">// &gt; 4</span></span><br><span class="line"><span class="built_in">console</span>.log(diag(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// &gt; 5</span></span><br></pre></td></tr></table></figure><h4 id="基本规则或特点"><a href="#基本规则或特点" class="headerlink" title="基本规则或特点"></a>基本规则或特点</h4><ul><li>每个模块只加载一次，每一个 <code>js</code> 只执行一次，如果下次再去加载同目录下的同文件，直接从内存中读取。一个模块就是一个单例，或者说就是一个对象。</li><li>每一个模块内声明的变量都是局部变量，不会污染全局作用域。</li><li>模块内部的变量或者函数可以通过 <code>export</code> 导出。</li><li>一个模块可以导入别的模块。</li></ul><h4 id="import和export导出方式"><a href="#import和export导出方式" class="headerlink" title="import和export导出方式"></a>import和export导出方式</h4><h5 id="综合导出变量"><a href="#综合导出变量" class="headerlink" title="综合导出变量"></a>综合导出变量</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"zi jun"</span>;</span><br><span class="line"><span class="keyword">let</span> sayName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello, zi jun"</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;name, sayName&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, sayName &#125; <span class="keyword">from</span> <span class="string">"./lib"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// &gt; "zi jun";</span></span><br><span class="line"><span class="built_in">console</span>.log(sayName); <span class="comment">// &gt; "hello, zi jun"</span></span><br></pre></td></tr></table></figure><h5 id="导出时修改名称"><a href="#导出时修改名称" class="headerlink" title="导出时修改名称"></a>导出时修改名称</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"zi jun"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;name <span class="keyword">as</span> myName&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName &#125; <span class="keyword">from</span> <span class="string">"./lib"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myName); <span class="comment">// &gt; "zi jun"</span></span><br></pre></td></tr></table></figure><h5 id="直接导出"><a href="#直接导出" class="headerlink" title="直接导出"></a>直接导出</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">"zi jun"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">"./lib"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// &gt; "zi jun"</span></span><br></pre></td></tr></table></figure><h5 id="匿名导出"><a href="#匿名导出" class="headerlink" title="匿名导出"></a>匿名导出</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">"zi jun"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> info <span class="keyword">from</span> <span class="string">"./lib"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(info.name); <span class="comment">// &gt; "zi jun"</span></span><br></pre></td></tr></table></figure><h5 id="通配符导出"><a href="#通配符导出" class="headerlink" title="通配符导出"></a>通配符导出</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// other.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">"zi jun"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> myName <span class="keyword">from</span> <span class="string">"./other"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> myName <span class="keyword">from</span> <span class="string">"./lib"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myName.name); <span class="comment">// &gt; "zi jun"</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端优化-10万条数据处理</title>
    <url>/archives/46a5683c.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:10 GMT+0800 (GMT+08:00) --><p>本篇主要记录后端由于没有分页，一次性返回了10万条数据，前端如何渲染的问题。</p><a id="more"></a><p>以下介绍下初级工程师、中级工程师、高级工程师应对此问题的处理方案。</p><h3 id="初级处理方案"><a href="#初级处理方案" class="headerlink" title="初级处理方案"></a>初级处理方案</h3><p>直接从后端请求数据，渲染到页面的硬编码方案，思路如下：</p><p><img data-src="../../assets/2020006191426.jpg" alt=""></p><p>代码如下：</p><p>请求后端数据：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> fetchList() &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; data &#125; = <span class="keyword">await</span> getMockData();</span><br><span class="line">    <span class="keyword">this</span>.dataList = data; </span><br><span class="line">    <span class="keyword">this</span>.renderList = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染数据：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-item"</span> <span class="attr">v-for</span>=<span class="string">"item in renderList"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>搜索数据：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleSearch() &#123;</span><br><span class="line">  <span class="keyword">this</span>.renderList = <span class="keyword">this</span>.dataList.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.name.includes(<span class="keyword">this</span>.keys);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面完整代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test-page"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 搜索 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-search"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"请输入"</span> <span class="attr">v-model</span>=<span class="string">"keys"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleSearch"</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-wrap"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-item"</span> <span class="attr">v-for</span>=<span class="string">"item in renderList"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      dataList: [],</span><br><span class="line">      renderList: [],</span><br><span class="line"><span class="actionscript">      keys: <span class="string">""</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.fetchList();</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取数据列表</span><br><span class="line">     */</span><br><span class="line">    fetchList() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> result = [];</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="number">100000</span>; i &lt; len; i++) &#123;</span></span><br><span class="line">        result.push(&#123;</span><br><span class="line">          id: i,</span><br><span class="line"><span class="javascript">          name: <span class="string">`这是第<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>行数据：i = <span class="subst">$&#123;i&#125;</span>`</span></span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.dataList = result;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.renderList = result;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 搜索</span><br><span class="line">     */</span><br><span class="line">    handleSearch() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.renderList = <span class="keyword">this</span>.dataList.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> item.name.includes(<span class="keyword">this</span>.keys);</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="note warning"><ul><li><p>这种做法本质上是可以实现基本的需求，但是有明显的缺点，那就是数据一次性渲染到页面中，数据量庞大将导致页面性能急剧降低，造成页面卡顿。</p></li><li><p>根据页面显示：<code>Finish: 25.57s, DOMContentLoaded:888ms, Load:25.21s</code>，可见这100000条数据，在页面一次性渲染花费了25s。消耗巨大。</p></li></ul></div><h3 id="中级处理方案"><a href="#中级处理方案" class="headerlink" title="中级处理方案"></a>中级处理方案</h3><p>熟悉防抖函数和节流函数，并使用懒加载和分页的方案。思路如下：</p><p><img data-src="../../assets/c684f0b9faca41cab12a395f9da749e0.jpg" alt=""></p><p>懒加载 + 分页方案：懒加载的实现主要是通过监听窗口的滚动，当某一个占位元素可见之后再去加载下一个数据，原理如下：这里我们通过监听 <code>window</code> 的 <code>scroll</code> 事件，判断是否滚动到页面底部，从而自己实现一个懒加载方案。</p><p>完整代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test-page"</span> <span class="attr">ref</span>=<span class="string">"poll"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 搜索 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-search"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"请输入"</span> <span class="attr">v-model</span>=<span class="string">"keys"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleSearch"</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-wrap"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-item"</span> <span class="attr">v-for</span>=<span class="string">"item in renderList"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      dataList: [],</span><br><span class="line">      renderList: [],</span><br><span class="line"><span class="actionscript">      keys: <span class="string">""</span>,</span></span><br><span class="line"></span><br><span class="line">      prevY: 0,</span><br><span class="line">      curPage: 1,</span><br><span class="line">      pageSize: 20</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.fetchList();</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> getData = <span class="keyword">this</span>.debounce(<span class="number">300</span>, <span class="keyword">this</span>.scrollAndLoading);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, getData, <span class="literal">false</span>);</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取数据列表</span><br><span class="line">     */</span><br><span class="line">    fetchList() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> result = [];</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="number">100000</span>; i &lt; len; i++) &#123;</span></span><br><span class="line">        result.push(&#123;</span><br><span class="line">          id: i,</span><br><span class="line"><span class="javascript">          name: <span class="string">`这是第<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>行数据：i = <span class="subst">$&#123;i&#125;</span>`</span></span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.dataList = result;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.renderList = <span class="keyword">this</span>.dataList.slice(<span class="number">0</span>, <span class="keyword">this</span>.pageSize * <span class="keyword">this</span>.curPage);</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 搜索</span><br><span class="line">     */</span><br><span class="line">    handleSearch() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.dataList = <span class="keyword">this</span>.dataList.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> item.name.includes(<span class="keyword">this</span>.keys);</span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.curPage = <span class="number">1</span>;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.renderList = <span class="keyword">this</span>.dataList.slice(<span class="number">0</span>, <span class="keyword">this</span>.pageSize * <span class="keyword">this</span>.curPage);</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 防抖函数</span><br><span class="line">     * @param delay &#123;number&#125; 延迟时间</span><br><span class="line"><span class="javascript">     * @param fn &#123;<span class="function"><span class="keyword">function</span>&#125; 回调函数</span></span></span><br><span class="line"><span class="javascript">     * @returns &#123;<span class="function"><span class="keyword">function</span>(<span class="params">...[*]=</span>)&#125;</span></span></span><br><span class="line">     */</span><br><span class="line">    debounce(delay, fn) &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> timer;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span></span><br><span class="line">        timer &amp;&amp; clearTimeout(timer);</span><br><span class="line"><span class="javascript">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">          fn(...args);</span><br><span class="line"><span class="actionscript">          timer = <span class="literal">null</span>;</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 滚动并加载</span><br><span class="line">     */</span><br><span class="line">    scrollAndLoading(data) &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> scrollTop =</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> clientHeight =</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> scrollHeight =</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.documentElement.scrollHeight || <span class="built_in">document</span>.body.scrollHeight;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="built_in">window</span>.scrollY &gt; <span class="keyword">this</span>.prevY) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.prevY = <span class="built_in">window</span>.scrollY;</span></span><br><span class="line">        if (</span><br><span class="line">          scrollHeight &gt; clientHeight &amp;&amp;</span><br><span class="line">          scrollTop + clientHeight &gt;= scrollHeight</span><br><span class="line">        ) &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.curPage++;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.renderList = <span class="keyword">this</span>.dataList.slice(</span></span><br><span class="line">            0,</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.pageSize * <span class="keyword">this</span>.curPage</span></span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="note warning"><ul><li>这种做法无论是搜索前还是搜索后，都利用了懒加载，所以不用太担心数据量大带来的性能瓶颈。</li><li>以上代码存有bug,可以优化，比如搜索结果会覆盖源数据。</li><li>这样处理，由于防抖的原因，加载时会有停顿效果，不能“一滑到底”。</li></ul></div><h3 id="高级处理方案"><a href="#高级处理方案" class="headerlink" title="高级处理方案"></a>高级处理方案</h3><ul><li>运用虚拟滚动技术来优化长列表</li><li>JS缓冲器来分片处理长列表</li><li>Web Worker处理数据，全部用Web Worker处理做异步回调，必要的时候可以引入WebAssembly模块做数据处理</li></ul><p><strong>虚拟滚动技术</strong></p><p>原理：其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。</p><p>比如10万条数据需要同时渲染，我们的屏幕的可见区域的高度为500px，而列表单项的高度为50px，则此时我们在屏幕中最多只能看到10个列表项，那么在首次渲染的时候，我们只需加载10条数据即可。</p><p><img data-src="../../assets/05553d49ce7a4e9290eba7ccbdb71833.jpg" alt=""></p><p>首次加载完，当滚动发生时，通过计算当前滚动值可以得知此时在屏幕可见区域应该显示的列表项。假设滚动发生，滚动条距离顶部的位置为150px，则可见区域内的列表项为第4项到第13项。</p><p><img data-src="../../assets/ca633915f4e94e86acf42786d3a01c86.jpg" alt=""></p><p>实现：在首屏加载的时候，只加载可视区域内需要的列表项，当滚动发生时，动态通过计算获取可视区域内的列表项，并将非可视区域内存在的列表项删除。</p><ul><li>计算当前可视区域起始数据索引（<code>startIndex</code>）</li><li>计算当前可视区域结束数据索引（<code>endIndex</code>）</li><li>计算当前可视区域的数据，并渲染到页面中</li><li>计算 <code>startIndex</code> 对应的数据在整个列表中的偏移位置 <code>startOffset</code> 并设置到列表上</li></ul><p><img data-src="../../assets/907fdf3af0364eb893a2508c73c55ed3.jpg" alt=""></p><p>由于只是对可视区域内的列表项进行渲染，所以为了保持列表容器的高度并可正常的触发滚动，将HTML结果设计如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"infinite-list-container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"infinite-list-phantom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"infinite-list"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- item --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>infinite-list-container</code> 为可视区域的容器</li><li><code>infinite-list-phantom</code> 为容器内的占位，高度为总列表高度，用于形成滚动条</li><li><code>infinite-list</code> 为列表项的渲染区域</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"infinite-list-container"</span> @<span class="attr">scroll</span>=<span class="string">"handleScrollEvent"</span> <span class="attr">ref</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"infinite-list-phantom"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:style</span>=<span class="string">"&#123; height: listHeight + 'px' &#125;"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"infinite-list"</span> <span class="attr">:style</span>=<span class="string">"&#123; transform: getTransform &#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-item"</span> <span class="attr">v-for</span>=<span class="string">"item in renderList"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      dataList: [],</span><br><span class="line">      screenHeight: 0,</span><br><span class="line">      itemHeight: 50,</span><br><span class="line">      scrollTop: 0,</span><br><span class="line">      start: 0,</span><br><span class="line"><span class="actionscript">      end: <span class="literal">null</span>,</span></span><br><span class="line">      startOffset: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    listHeight() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="keyword">this</span>.dataList.length * <span class="keyword">this</span>.itemHeight;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    visibleCount() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.screenHeight / <span class="keyword">this</span>.itemHeight);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    renderList() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="keyword">this</span>.dataList.slice(</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.start,</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Math</span>.min(<span class="keyword">this</span>.end, <span class="keyword">this</span>.dataList.length)</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">    getTransform() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="string">`translate3d(0, <span class="subst">$&#123;<span class="keyword">this</span>.startOffset&#125;</span>px, 0)`</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.fetchList();</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.screenHeight = <span class="keyword">this</span>.$refs.list.clientHeight;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.start = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.end = <span class="keyword">this</span>.start + <span class="keyword">this</span>.visibleCount;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取数据列表</span><br><span class="line">     */</span><br><span class="line">    fetchList() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> result = [];</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="number">100000</span>; i &lt; len; i++) &#123;</span></span><br><span class="line">        result.push(&#123;</span><br><span class="line">          id: i,</span><br><span class="line"><span class="javascript">          name: <span class="string">`这是第<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>行数据：i = <span class="subst">$&#123;i&#125;</span>`</span></span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.dataList = result;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 监听滚动</span><br><span class="line">     */</span><br><span class="line">    handleScrollEvent() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> scrollTop = <span class="keyword">this</span>.$refs.list.scrollTop;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.scrollTop = scrollTop;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.start = <span class="built_in">Math</span>.floor(scrollTop / <span class="keyword">this</span>.itemHeight);</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.end = <span class="keyword">this</span>.start + <span class="keyword">this</span>.visibleCount;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.startOffset = scrollTop - (scrollTop % <span class="keyword">this</span>.itemHeight);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.infinite-list-container</span> &#123;</span></span><br><span class="line">  height: 100vh;</span><br><span class="line">  overflow: auto;</span><br><span class="line">  position: relative;</span><br><span class="line">  -webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.infinite-list-phantom</span> &#123;</span></span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 0;</span><br><span class="line">  top: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  z-index: 1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.infinite-list</span> &#123;</span></span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  top: 0;</span><br><span class="line">  position: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.list-item</span> &#123;</span></span><br><span class="line">  height: 50px;</span><br><span class="line">  p &#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">    margin: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue集成2:配置优化</title>
    <url>/archives/13614b08.html</url>
    <content><![CDATA[<!-- build time:Tue Jul 07 2020 20:34:11 GMT+0800 (GMT+08:00) --><p>本篇主要记录Vue项目基于 <code>Vue</code> + <code>Vant</code> 的二次集成及优化。以便开箱即用。</p><a id="more"></a><h3 id="基本配置文件"><a href="#基本配置文件" class="headerlink" title="基本配置文件"></a>基本配置文件</h3><p>修改（新增）<code>vue.config.js</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PORT = process.env.port || <span class="number">8088</span>;</span><br><span class="line"><span class="keyword">const</span> IS_PRODUCTION = process.env.NODE_ENV === <span class="string">"production"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: IS_PRODUCTION ? <span class="string">"/"</span> : <span class="string">"/"</span>,</span><br><span class="line">  lintOnSave: !IS_PRODUCTION,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: PORT,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    https: <span class="literal">false</span>,</span><br><span class="line">    compress: <span class="literal">false</span>,</span><br><span class="line">    overlay: &#123;</span><br><span class="line">      warnings: <span class="literal">true</span>,</span><br><span class="line">      errors: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="配置路径别名"><a href="#配置路径别名" class="headerlink" title="配置路径别名"></a>配置路径别名</h3><p>修改 <code>vue.config.js</code> 的 <code>chainWebpack</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">dir</span> =&gt;</span> path.join(__dirname, dir);</span><br><span class="line"><span class="keyword">const</span> PORT = process.env.port || <span class="number">8088</span>;</span><br><span class="line"><span class="keyword">const</span> IS_PRODUCTION = process.env.NODE_ENV === <span class="string">"production"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: IS_PRODUCTION ? <span class="string">"/"</span> : <span class="string">"/"</span>,</span><br><span class="line">  lintOnSave: !IS_PRODUCTION,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.resolve.alias</span><br><span class="line">      .set(<span class="string">"@"</span>, resolve(<span class="string">"src"</span>))</span><br><span class="line">      .set(<span class="string">"views"</span>, resolve(<span class="string">"src/views"</span>))</span><br><span class="line">      .set(<span class="string">"components"</span>, resolve(<span class="string">"src/components"</span>))</span><br><span class="line">      .set(<span class="string">"api"</span>, resolve(<span class="string">"src/api"</span>))</span><br><span class="line">      .set(<span class="string">"utils"</span>, resolve(<span class="string">"src/utils"</span>))</span><br><span class="line">      .set(<span class="string">"assets"</span>, resolve(<span class="string">"src/assets"</span>))</span><br><span class="line">      .set(<span class="string">"store"</span>, resolve(<span class="string">"src/store"</span>))</span><br><span class="line">      .set(<span class="string">"styles"</span>, resolve(<span class="string">"src/styles"</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: PORT,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    https: <span class="literal">false</span>,</span><br><span class="line">    compress: <span class="literal">false</span>,</span><br><span class="line">    overlay: &#123;</span><br><span class="line">      warnings: <span class="literal">true</span>,</span><br><span class="line">      errors: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="配置全局样式"><a href="#配置全局样式" class="headerlink" title="配置全局样式"></a>配置全局样式</h3><p>如果给 <code>sass</code>样式文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  css: &#123;</span><br><span class="line"> 	loaderOptions: &#123;</span><br><span class="line">    sass: &#123;</span><br><span class="line">      data: <span class="string">`@import "@/styles/global/index.scss";`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是 <code>less</code>样式文件：</p><ol><li><p>先安装依赖：<code>yarn add style-resources-loader --dev</code> （如果没有 <code>less-loader</code>，也需要安装 <code>less-loader</code>）</p></li><li><p>在 <code>src</code> 下新建目录及文件：<code>styles/global/index.less</code></p></li><li><p>修改 <code>vue.config.js</code> 的 <code>chainWebpack</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ADD_STYLE_SOURCE = <span class="function">(<span class="params">rule</span>) =&gt;</span> &#123;</span><br><span class="line">      rule.use(<span class="string">"style-resource"</span>)</span><br><span class="line">        .loader(<span class="string">"style-resources-loader"</span>)</span><br><span class="line">        .options(&#123;</span><br><span class="line">          patterns: [resolve(<span class="string">'src/styles/global/index.less'</span>)]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> TYPES = [<span class="string">'vue-modules'</span>, <span class="string">'vue'</span>, <span class="string">'normal-modules'</span>, <span class="string">'normal'</span>]</span><br><span class="line">    TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> ADD_STYLE_SOURCE(config.module.rule(<span class="string">'less'</span>).oneOf(type)))</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="针对请求数优化"><a href="#针对请求数优化" class="headerlink" title="针对请求数优化"></a>针对请求数优化</h3><p>修改 <code>vue.config.js</code> 中的 <code>chainWebpakc</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">		config.plugins.delete(<span class="string">"prefetch"</span>);</span><br><span class="line">        config.plugins.delete(<span class="string">"preload"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CDN加载优化"><a href="#CDN加载优化" class="headerlink" title="CDN加载优化"></a>CDN加载优化</h3><ol><li><p>先安装 <code>axios</code> 插件：<code>yarn add axios</code></p></li><li><p>修改 <code>vue.config.js</code>（注意此处还进行了压缩 <code>html</code> 中的 <code>css</code> 优化）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> IS_PRODUCTION = process.env.NODE_ENV === <span class="string">"production"</span>;</span><br><span class="line">    <span class="keyword">const</span> cdn = &#123;</span><br><span class="line">        css: [],</span><br><span class="line">        js: [</span><br><span class="line">            <span class="string">"https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js"</span>,</span><br><span class="line">            <span class="string">"https://cdn.bootcdn.net/ajax/libs/vue-router/3.2.0/vue-router.min.js"</span>,</span><br><span class="line">            <span class="string">"https://cdn.bootcdn.net/ajax/libs/vuex/3.5.1/vuex.min.js"</span>,</span><br><span class="line">            <span class="string">"https://cdn.bootcdn.net/ajax/libs/axios/0.19.2/axios.min.js"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> externals = &#123;</span><br><span class="line">      vue: <span class="string">"Vue"</span>,</span><br><span class="line">      vuex: <span class="string">"Vuex"</span>,</span><br><span class="line">      <span class="string">"vue-router"</span>: <span class="string">"VueRouter"</span>,</span><br><span class="line">      axios: <span class="string">"axios"</span></span><br><span class="line">    &#125;;</span><br><span class="line">	</span><br><span class="line">	chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(IS_PRODUCTION) &#123;</span><br><span class="line">            config.plugin(<span class="string">"html"</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">        		args[<span class="number">0</span>].cdn = cdn;</span><br><span class="line">        		args[<span class="number">0</span>].minify.minifyCSS = <span class="literal">true</span>;</span><br><span class="line">        		<span class="keyword">return</span> args;</span><br><span class="line">      		&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">	</span><br><span class="line">	configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (IS_PRODUCTION) &#123;</span><br><span class="line">      		config.externals = EXTERNALS;</span><br><span class="line">    	&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 <code>html</code> 文件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"&lt;%= BASE_URL %&gt;favicon.ico"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用CDN的CSS文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">for</span> (<span class="attr">var</span> <span class="attr">i</span> <span class="attr">in</span> <span class="attr">htmlWebpackPlugin.options.cdn</span> &amp;&amp; <span class="attr">htmlWebpackPlugin.options.cdn.css</span>) &#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;"</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用CDN的JS文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">for</span> (<span class="attr">var</span> <span class="attr">i</span> <span class="attr">in</span> <span class="attr">htmlWebpackPlugin.options.cdn</span> &amp;&amp; <span class="attr">htmlWebpackPlugin.options.cdn.js</span>) &#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;"</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">as</span>=<span class="string">"script"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>We're sorry but <span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span> doesn't work properly without JavaScript enabled. Please enable it to continue.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">for</span> (<span class="attr">var</span> <span class="attr">i</span> <span class="attr">in</span> <span class="attr">htmlWebpackPlugin.options.cdn</span> &amp;&amp; <span class="attr">htmlWebpackPlugin.options.cdn.js</span>) &#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="代码分割优化"><a href="#代码分割优化" class="headerlink" title="代码分割优化"></a>代码分割优化</h3><p>修改 <code>vue.config.js</code> 中 <code>chainWebpack</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (IS_NOT_DEV) &#123;</span><br><span class="line">              config.optimization.splitChunks(&#123;</span><br><span class="line">                    chunks: <span class="string">"all"</span>,</span><br><span class="line">                    cacheGroups: &#123;</span><br><span class="line">                          libs: &#123;</span><br><span class="line">                                name: <span class="string">"chunk-libs"</span>,</span><br><span class="line">                                test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">                                priority: <span class="number">10</span>,</span><br><span class="line">                                chunks: <span class="string">"initial"</span></span><br><span class="line">                          &#125;,</span><br><span class="line">                          commons: &#123;</span><br><span class="line">                                name: <span class="string">"chunk-commons"</span>,</span><br><span class="line">                                test: resolve(<span class="string">"src/components"</span>),</span><br><span class="line">                                minChunks: <span class="number">3</span>,</span><br><span class="line">                                priority: <span class="number">5</span>,</span><br><span class="line">                                reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">                          &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">              config.optimization.runtimeChunk(<span class="string">"single"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="去除console"><a href="#去除console" class="headerlink" title="去除console"></a>去除console</h3><p>由于 <code>vue-cli 4.x</code> 采用的是 <code>terser</code> 压缩，所以跟之前 <code>vue-cli 3.x</code> 版本不一样：</p><p>修改 <code>vue.config.js</code> 中 <code>configureWebpack</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (IS_PROD) &#123;</span><br><span class="line">        config.optimization.minimizer.map(<span class="function"><span class="params">arg</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> OPTION = arg.options.terserOptions.compress;</span><br><span class="line">          OPTION.drop_console = <span class="literal">true</span>;</span><br><span class="line">          OPTION.pure_funcs = [<span class="string">"console.*"</span>];</span><br><span class="line">          arg.extractComments = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置打包分析工具"><a href="#配置打包分析工具" class="headerlink" title="配置打包分析工具"></a>配置打包分析工具</h3><ol><li><p>安装插件：<code>yarn add webpack-bundle-analyzer --dev</code></p></li><li><p>修改 <code>vue.config.js</code> 中 <code>configureWebpack</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (IS_PROD) &#123;</span><br><span class="line"> 		config.plugin(<span class="string">"analyzer"</span>).use(BundleAnalyzerPlugin);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置gzip压缩"><a href="#配置gzip压缩" class="headerlink" title="配置gzip压缩"></a>配置gzip压缩</h3><p>这个优化需要前后端配合。</p><p>前端方面：</p><ol><li><p>安装插件：<code>yarn add compression-webpack-plugin</code></p></li><li><p>修改 <code>vue.config.js</code> 中 <code>chainWebpack</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (IS_NOT_DEV) &#123;</span><br><span class="line">        config</span><br><span class="line">          .plugin(<span class="string">"compression"</span>)</span><br><span class="line">          .use(CompressionWebpackPlugin)</span><br><span class="line">          .tap(<span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">            &#123;</span><br><span class="line">              algorithm: <span class="string">"gzip"</span>,</span><br><span class="line">              test: <span class="regexp">/\.js$|\.html$|\.css/</span>,</span><br><span class="line">              threshold: <span class="number">10240</span>,</span><br><span class="line">              minRatio: <span class="number">0.8</span>,</span><br><span class="line">              deleteOriginalAssets: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>服务端方面：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">// nginx: nginx.conf</span><br><span class="line">server &#123;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_buffers 4 16K;</span><br><span class="line">    gzip_comp_level 5;</span><br><span class="line">    gzip_min_length 100k;</span><br><span class="line">    gzip_types text/plain application/x-javascript application/javascript application/json text/css application/xml text/javascript image/jpeg image/gif image/png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="code"><pre><span class="line">// tomcat: server.xml</span><br><span class="line">&lt;Connector </span><br><span class="line">    port="8080" </span><br><span class="line">    protocol="HTTP/1.1"</span><br><span class="line">    connectionTimeout="20000"</span><br><span class="line"> </span><br><span class="line">    compression="on"   </span><br><span class="line">    compressableMimeType="text/html,text/xml,text/javascript,text/css,text/plain,application/javascript"</span><br><span class="line">    useSendfile="false"/&gt;</span><br></pre></td></tr></table></figure><h3 id="配置图片压缩"><a href="#配置图片压缩" class="headerlink" title="配置图片压缩"></a><del>配置图片压缩</del></h3><ol><li>安装插件：<code>cnpm install image-webpack-loader --save-dev</code>（这里使用 <code>yarn</code>安装会有点网络问题，所以这里使用 <code>cnpm</code> 安装）</li><li>修改 <code>vue.config.js</code> 中 <code>chainWebpack</code> 属性：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        config.module</span><br><span class="line">              .rule(<span class="string">'images'</span>)</span><br><span class="line">              .use(<span class="string">'image-webpack-loader'</span>)</span><br><span class="line">              .loader(<span class="string">'image-webpack-loader'</span>)</span><br><span class="line">              .options(&#123;</span><br><span class="line">                bypassOnDebug: <span class="literal">true</span>,</span><br><span class="line">                pngquant: &#123;</span><br><span class="line">                  quality: [<span class="number">0.75</span>, <span class="number">0.90</span>],</span><br><span class="line">                  speed: <span class="number">5</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              .end()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>安装的插件：</p><ol><li><code>yarn add style-resources-loader --dev</code></li><li><code>yarn add axios</code></li><li><code>yarn add webpack-bundle-analyzer --dev</code></li><li><code>yarn add compression-webpack-plugin</code></li></ol><p>完整 <code>vue.config.js</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Overview:   Vue配置优化</span></span><br><span class="line"><span class="comment"> * @Author:     Zi_Jun</span></span><br><span class="line"><span class="comment"> * @Email:      zijun2030@163.com</span></span><br><span class="line"><span class="comment"> * @Date:       2020/7/7 20:24</span></span><br><span class="line"><span class="comment"> * @Mark:       1、 配置路径别名</span></span><br><span class="line"><span class="comment"> *              2、 配置全局样式</span></span><br><span class="line"><span class="comment"> *              3、 针对请求数优化</span></span><br><span class="line"><span class="comment"> *              4、 CDN优化</span></span><br><span class="line"><span class="comment"> *              5、 代码分割优化</span></span><br><span class="line"><span class="comment"> *              6、 生产去除console</span></span><br><span class="line"><span class="comment"> *              7、 配置打包分析工具</span></span><br><span class="line"><span class="comment"> *              8、 配置前端gzip压缩</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> CompressionWebpackPlugin = <span class="built_in">require</span>(<span class="string">"compression-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">"webpack-bundle-analyzer"</span>);</span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">dir</span> =&gt;</span> path.join(__dirname, dir);</span><br><span class="line"><span class="keyword">const</span> PORT = process.env.port || <span class="number">8088</span>;</span><br><span class="line"><span class="keyword">const</span> IS_PROD = [<span class="string">"production"</span>, <span class="string">"prod"</span>].includes(process.env.NODE_ENV);</span><br><span class="line"><span class="keyword">const</span> IS_NOT_DEV = process.env.NODE_ENV !== <span class="string">"development"</span>;</span><br><span class="line"><span class="keyword">const</span> cdn = &#123;</span><br><span class="line">  css: [],</span><br><span class="line">  js: [</span><br><span class="line">    <span class="string">"https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js"</span>,</span><br><span class="line">    <span class="string">"https://cdn.bootcdn.net/ajax/libs/vue-router/3.2.0/vue-router.min.js"</span>,</span><br><span class="line">    <span class="string">"https://cdn.bootcdn.net/ajax/libs/vuex/3.5.1/vuex.min.js"</span>,</span><br><span class="line">    <span class="string">"https://cdn.bootcdn.net/ajax/libs/axios/0.19.2/axios.min.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> externals = &#123;</span><br><span class="line">  vue: <span class="string">"Vue"</span>,</span><br><span class="line">  vuex: <span class="string">"Vuex"</span>,</span><br><span class="line">  <span class="string">"vue-router"</span>: <span class="string">"VueRouter"</span>,</span><br><span class="line">  axios: <span class="string">"axios"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: IS_PROD ? <span class="string">"/"</span> : <span class="string">"/"</span>,</span><br><span class="line">  outputDir: process.env.outputDir || <span class="string">"dist"</span>,</span><br><span class="line">  lintOnSave: !IS_PROD,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">  parallel: <span class="built_in">require</span>(<span class="string">"os"</span>).cpus().length &gt; <span class="number">1</span>,</span><br><span class="line">  pwa: &#123;</span><br><span class="line">    iconPaths: &#123;</span><br><span class="line">      favicon32: <span class="string">"favicon.ico"</span>,</span><br><span class="line">      favicon16: <span class="string">"favicon.ico"</span>,</span><br><span class="line">      appleTouchIcon: <span class="string">"favicon.ico"</span>,</span><br><span class="line">      maskIcon: <span class="string">"favicon.ico"</span>,</span><br><span class="line">      msTileImage: <span class="string">"favicon.ico"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> TYPES = [<span class="string">"vue-modules"</span>, <span class="string">"vue"</span>, <span class="string">"normal-modules"</span>, <span class="string">"normal"</span>];</span><br><span class="line">    <span class="keyword">const</span> ADD_STYLE_SOURCE = <span class="function"><span class="params">rule</span> =&gt;</span> &#123;</span><br><span class="line">      rule</span><br><span class="line">        .use(<span class="string">"style-resource"</span>)</span><br><span class="line">        .loader(<span class="string">"style-resources-loader"</span>)</span><br><span class="line">        .options(&#123;</span><br><span class="line">          patterns: [resolve(<span class="string">"src/styles/global/index.less"</span>)]</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span></span><br><span class="line">      ADD_STYLE_SOURCE(config.module.rule(<span class="string">"less"</span>).oneOf(type))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    config.plugins.delete(<span class="string">"preload"</span>);</span><br><span class="line">    config.plugins.delete(<span class="string">"prefetch"</span>);</span><br><span class="line"></span><br><span class="line">    config.resolve.alias</span><br><span class="line">      .set(<span class="string">"@"</span>, resolve(<span class="string">"src"</span>))</span><br><span class="line">      .set(<span class="string">"views"</span>, resolve(<span class="string">"src/views"</span>))</span><br><span class="line">      .set(<span class="string">"components"</span>, resolve(<span class="string">"src/components"</span>))</span><br><span class="line">      .set(<span class="string">"api"</span>, resolve(<span class="string">"src/api"</span>))</span><br><span class="line">      .set(<span class="string">"utils"</span>, resolve(<span class="string">"src/utils"</span>))</span><br><span class="line">      .set(<span class="string">"assets"</span>, resolve(<span class="string">"src/assets"</span>))</span><br><span class="line">      .set(<span class="string">"store"</span>, resolve(<span class="string">"src/store"</span>))</span><br><span class="line">      .set(<span class="string">"style"</span>, resolve(<span class="string">"src/style"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_NOT_DEV) &#123;</span><br><span class="line">      config.optimization.splitChunks(&#123;</span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">          vendor: &#123;</span><br><span class="line">            chunks: <span class="string">"all"</span>,</span><br><span class="line">            test: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            name: <span class="string">"vendor"</span>,</span><br><span class="line">            minChunks: <span class="number">1</span>,</span><br><span class="line">            maxInitialRequests: <span class="number">5</span>,</span><br><span class="line">            minSize: <span class="number">0</span>,</span><br><span class="line">            priority: <span class="number">100</span></span><br><span class="line">          &#125;,</span><br><span class="line">          common: &#123;</span><br><span class="line">            chunks: <span class="string">"all"</span>,</span><br><span class="line">            test: <span class="regexp">/[\\/]src[\\/]js[\\/]/</span>,</span><br><span class="line">            name: <span class="string">"common"</span>,</span><br><span class="line">            minChunks: <span class="number">2</span>,</span><br><span class="line">            maxInitialRequests: <span class="number">5</span>,</span><br><span class="line">            minSize: <span class="number">0</span>,</span><br><span class="line">            priority: <span class="number">60</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      config.optimization.runtimeChunk(<span class="string">"single"</span>);</span><br><span class="line">      config.optimization.minimize(<span class="literal">true</span>);</span><br><span class="line">      config</span><br><span class="line">        .plugin(<span class="string">"compression"</span>)</span><br><span class="line">        .use(CompressionWebpackPlugin)</span><br><span class="line">        .tap(<span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">          &#123;</span><br><span class="line">            algorithm: <span class="string">"gzip"</span>,</span><br><span class="line">            test: <span class="regexp">/\.js$|\.html$|\.css/</span>,</span><br><span class="line">            threshold: <span class="number">10240</span>,</span><br><span class="line">            minRatio: <span class="number">0.8</span>,</span><br><span class="line">            deleteOriginalAssets: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_PROD) &#123;</span><br><span class="line">      config.plugin(<span class="string">"html"</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">        args[<span class="number">0</span>].cdn = cdn;</span><br><span class="line">        args[<span class="number">0</span>].minify.minifyCSS = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> args;</span><br><span class="line">      &#125;);</span><br><span class="line">      config.plugin(<span class="string">"analyzer"</span>).use(BundleAnalyzerPlugin);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (IS_PROD) &#123;</span><br><span class="line">      config.externals = externals;</span><br><span class="line">      config.optimization.minimizer.map(<span class="function"><span class="params">arg</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> OPTION = arg.options.terserOptions.compress;</span><br><span class="line">        OPTION.drop_console = <span class="literal">true</span>;</span><br><span class="line">        OPTION.pure_funcs = [<span class="string">"console.*"</span>];</span><br><span class="line">        arg.extractComments = <span class="literal">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: PORT,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    https: <span class="literal">false</span>,</span><br><span class="line">    compress: <span class="literal">false</span>,</span><br><span class="line">    overlay: &#123;</span><br><span class="line">      warnings: <span class="literal">true</span>,</span><br><span class="line">      errors: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Vue</category>
        <category>集成</category>
      </categories>
      <tags>
        <tag>集成</tag>
      </tags>
  </entry>
</search>
